#include "common.ceu"

_srand(_time(null));

///////////////////////////////////////////////////////////////////////////////
// 0->1->...->N->0
///////////////////////////////////////////////////////////////////////////////

#define N 20

code/await Node (var int i) -> none
    throws Exception.Lua
do
    lua[] do
        var int local  = 8340+i;
        var int remote = 8341+i;
        if i == (N-1) then
            remote = 8340;
        end

        [[
            dofile 'src/common.lua'
            CFG = {
                daemon = {
                    address = '127.0.0.1',
                    port    = @local,
                },
                not_persistency = true,
                chains = {
                    ['tst-35'] = {
                        key   = 'tst-35',
                        zeros = 0,
                        peers = {
                            { address='127.0.0.1', port=@remote },
                        },
                    },
                },
            }
        ]]

        var& Init init = spawn Init();
        await 100ms;

        do
#if 0
            spawn do
                var int  a;
                var bool err;
                var int  c;
                every (a,err,c) in init.shared.ok do
#if 0
[[
print(@i, '>'..string.rep('=',70))
print(GG.chain_tostring('|tst-35|0|'))
print(@i, '<'..string.rep('=',70))
]];
#endif

                    if err then
                        _printf("server | err | %d %d %d\n", a,err,c);
                    end
                end
            end
#endif

            var int j;
            loop j in [1 -> N] do
                // how much time between each message?
                await (_rand() % (100*N*N)) ms;
                [[
                    ARGS = {
                        message = {
                            version = '1.0',
                            chain = {
                                key   = 'tst-35',
                                zeros = 0,
                            },
                            payload = string.format('%03d',@i)..'.'..string.format('%03d',@j),
                        }
                    }
                ]];
                await Client(&init.shared);
//[[print(@i,@j, "clients") ]];
            end
//[[print(@i, "CLIENTS") ]];

            // wait all messages to be received
            AWAIT_CHAIN_LENGTH(init.shared, 'tst-35', 0, N*N);

            // wait for consensus
            loop do
                watching init.shared.ok_server do
                    await (N*N)s;
                    break;
                end
//_dbg(0, "server | shared.ok | 0.0.0.0:%d", port);
            end
//_dbg(0, "server | END | 0.0.0.0:%d", port);
#if 0
[[
print(@i, '>'..string.rep('=',70))
print(GG.chain_tostring('|tst-35|0|'))
print(@i, '<'..string.rep('=',70))
]];
#endif
//[[print(@i, "END") ]];
        end

        [[ ARGS = { chain=FC.chains['tst-35'][0] } ]];
        await FS_write_10();
    end
end

pool[N] Node nodes;

var int i;
loop i in [0 -> N[ do
    spawn Node(i) in nodes;
end

// wait all nodes to terminate
var&? Node n;
loop n in nodes do
    await n;
end

//_ceu_dbg_assert({BLOCKS_RECEIVED} == N*N);

// assert consensus
[[ file1 = io.open('/tmp/freechains/8340/|tst-35|0|.chain'):read'*a' ]]
var int i;
loop i in [0 -> N[ do
    [[
        file2 = io.open('/tmp/freechains/'..@(8340+i)..'/|tst-35|0|.chain'):read'*a'
        assert(file1 == file2, 'differ')
    ]]
end

[[ print'OK!' ]];

escape 0;
