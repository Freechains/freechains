#include "common.ceu"

_srand(_time(null));

///////////////////////////////////////////////////////////////////////////////
// 0<->1<->...<->N<->0
// - all to all
///////////////////////////////////////////////////////////////////////////////

#define N 50

code/await Node (var int i) -> void do
    lua[] do
        var UV_TCP_Server_Data shared = _;

        var int local = 8330+i;

        [=[
            dofile 'src/common.lua'
            dofile 'cfg/config.lua'

            SERVER {
                host = { '127.0.0.1', @local },
            }

            peers = {}
            for j=0, N-1 do
                if j ~= @i then
                    peers[#peers+1] = {
                        host = { '127.0.0.1', (8330+j) },
                    }
                end
            end

            CLIENT {
                peers = peers,
            }
        ]=]

        await Init();
        await 100ms;

        do
            vector[] byte ip      = [] .. [[ APP.server.host[1] ]] .. [0];
            var      int  port    = [[ APP.server.host[2] ]];
            var      int  backlog = [[ APP.server.backlog ]];
            _dbg(0, "server | listening in %s:%d", &&ip[0], port);
            spawn UV_TCP_Server(&shared, &&ip[0], port, backlog);

            var int j;
            loop j in [0 -> N[ do
                // how much time between each message?
                await (_rand()%100)ms;
    _printf(">>> I=%d j=%d\n", i, j);
                [[
                    APP.messages = {}
                    MESSAGE {
                        id = '1.0',
                        chain = {
                            key   = '',
                            zeros = 0,
                        },
                        payload = string.format('%03d',@i)..'.'..string.format('%03d',@j),
                    }
                ]];
                await ClientMessages(&shared);
            end
    _printf("\t\t<<< I=%d\n", i);

            // wait all messages to be received
            loop do
                await 100ms;   // periodic check (any number is ok)
                [[
                    t = GG.chain_head_base_size(APP.chains['||0|'].head_hash)
                ]]
                var int size = [[ t.size ]];
    //_printf("<<< I=%d n=%d\n", i, size);
                if size == N*N+1 then
                    break;
                end
            end

    _printf("<<< out=%d\n", i);
        end

    #if 0
    [[
    print(@i, '>'..string.rep('=',70))
    print(GG.chain_tostring('||0|'))
    print(@i, '<'..string.rep('=',70))
    ]];
    #endif
        vector[] byte path = [] .. [[ '/tmp/'..string.format('%03d',@i)..'.chain' ]];
        [[ ARGS = { chain_id='||0|' } ]];
        await FS_write_10(&path);
    end
end

pool[N] Node nodes;

var int i;
loop i in [0 -> N[ do
    spawn Node(i) in nodes;
end

// wait all nodes to terminate
var&? Node n;
loop n in nodes do
    await n;
end

_printf("BLOCKS_RECEIVED  = %d\n", {BLOCKS_RECEIVED});
_printf("BLOCKS_RECREATED = %d\n", {BLOCKS_RECREATED});
//_ceu_dbg_assert({BLOCKS_RECEIVED} == N*(N-1)*N);

// assert consensus
[[ file1 = io.open('/tmp/000.chain'):read'*a' ]]
var int i;
loop i in [0 -> N[ do
    [[
        file2 = io.open('/tmp/'..string.format('%03d',@i)..'.chain'):read'*a'
        assert(file1 == file2)
    ]]
end

[[ print'OK!' ]];

escape 0;
