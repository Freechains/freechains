#include "common.ceu"

///////////////////////////////////////////////////////////////////////////////
// Read from "x.chain"
///////////////////////////////////////////////////////////////////////////////

var UV_FS_open o = UV_FS_open.build("x.chain", _O_RDONLY, 0);
await o.ok;
_assert(o.fd >= 0);

[[ msg = {} ]];

var int off = 0;

// => HEADER
do
    var byte[4] buf;
    var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
    off = off + 4;
    _assert(buf[0] == MESSAGE_MAGIC_0);
    _assert(buf[1] == MESSAGE_MAGIC_1);
    [[ msg.id = ''..(@buf[2])..(@buf[3]) ]];
    _assert(n == 4);
end

// => BLOCKS
[[ head1 = nil ]];
loop do
    _printf("===\n");
    [[ block = {} ]];

    // => HASH
/*
    do
        var char[HASH_BYTES] buf;
        var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
        if n < 0 then
            break;
        end
        _assert(n == HASH_BYTES);
        off = off + HASH_BYTES;
        [[ block.hash = @buf ]];
        [[ print('block','\n'..tostring2(block.hash)) ]];
    end
*/

    // => TXS
    var u32 txs_n = 0;
    do
        // => TXS_N
// TODO: sizeof(u32)
        var byte[4] buf;
        var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
        if n <= 0 then
            break;
        end
        _assert(n == sizeof(u32));
        off = off + sizeof(u32);
        txs_n = *((u32&&)(_byte&&)&&buf);
    end
    [[ block.txs = {} ]];
    loop i in txs_n do
        // => TXS[i]
        [[
            tx = {}
            block.txs[@i+1] = tx
        ]];

        // => NONCE
        do
            var char[NONCE_BYTES] buf;
            var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
            _assert(n == NONCE_BYTES);
            off = off + NONCE_BYTES;
            [[ tx.nonce = @buf ]];
            [[ print('nonce','\n'..tostring2(tx.nonce)) ]];
        end

        // => TX_BACH_HASH
        do
            var char[HASH_BYTES] buf;
            var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
            _assert(n == HASH_BYTES);
            off = off + HASH_BYTES;
            [[ tx.back_hash = @buf ]];
            [[ print('back_hash','\n'..tostring2(tx.back_hash)) ]];
        end

        // => TX_PAYLOAD
        do
            var u32 payload_len = 0;
            do
// TODO: sizeof(u32)
                var byte[4] buf;
                var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
                _assert(n == sizeof(u32));
                off = off + sizeof(u32);
                payload_len = *((u32&&)(_byte&&)&&buf);
            end
            do
                var char[] buf;
                $buf := payload_len;
                var int n = do UV_FS_read.run(&o,&buf,payload_len,off);
                _assert(n == payload_len);
                off = off + payload_len;
                [[ tx.payload = @buf ]];
                [[ print('payload', tx.payload) ]];
            end
        end
    end
    [[
        block.up = head1
        if head1 then
            head1.tail = block
        end
        head1 = block
    ]]
end

[=[
    dofile 'cfg/config.lua'

    CLIENT {
        peers = {
            {
                host = { '127.0.0.1', '8331' },
            },
        },
    }
]=];

[=[
    MESSAGE {
        id = '1.0',
        chain = {
            key   = '',
            zeros = 0,
        },
        payload = [[111]],
    }

    MESSAGE {
        id = '1.0',
        chain = {
            key   = '',
            zeros = 0,
        },
        payload = [[222]],
    }
]=];
do ClientMessages;

[=[
    MESSAGE {
        id = '1.0',
        chain = {
            key   = '',
            zeros = 0,
        },
        payload = [[333]],
    }

    MESSAGE {
        id = '1.0',
        chain = {
            key   = '',
            zeros = 0,
        },
        payload = [[444]],
    }
]=];
do ClientMessages;

[[
    print('>'..string.rep('=',78))
    print(GG.chain_tostring('||0|'))
    print('<'..string.rep('=',78))
]];

[[
    chain     = APP.chains['||0|']
    head_hash = chain.head_hash
    base      = GG.chain_head_base_size(head_hash).base
]];

[[
head2 = APP.blocks[head_hash]
while head1 do
    assert(head2)

    assert(#head1.txs == #head2.txs)
    for i=1, #head1.txs do
        local tx1 = head1.txs[i]
        local tx2 = APP.txs[ head2.txs[i] ]
        assert(tx1.nonce     == tx2.nonce)
        assert(tx1.back_hash == tx2.back_hash)
        assert(tx1.payload   == tx2.payload)
    end

    head1 = head1.tail
    head2 = APP.blocks[head2.tail_hash]
end
]];

escape 0;
