/*
 * make CEU_SRC=<.>/util/milter.ceu CC_ARGS="-lmilter" one
 */

#include "c.ceu"

native/pre do
    ##include <assert.h>
    ##include <stdlib.h>
    ##include <stdio.h>
    ##include <libmilter/mfapi.h>

    typedef SMFICTX* SMFICTX_ptr;
end

native/pos do
    sfsistat mlfi_envfrom (SMFICTX* ctx, char** argv) {
        tceu_input_ENVFROM args = { ctx, argv };
        ceu_input(CEU_INPUT_ENVFROM, &args);
        //printf("FROM: %p %s\n", ctx, argv[0]);
        return SMFIS_CONTINUE;
    }

    sfsistat mlfi_header (SMFICTX* ctx, char* headerf, char* headerv) {
        tceu_input_HEADER args = { ctx, headerf, headerv };
        ceu_input(CEU_INPUT_HEADER, &args);
        //printf("HEADER: %s %s\n", headerf, headerv);
        return SMFIS_CONTINUE;
    }

    sfsistat mlfi_envrcpt (SMFICTX* ctx, char** argv) {
        tceu_input_ENVRCPT args = { ctx, argv };
        ceu_input(CEU_INPUT_ENVRCPT, &args);
        //printf("RCPT: %p %s\n", ctx, argv[0]);
        return SMFIS_CONTINUE;
    }

    sfsistat mlfi_body (SMFICTX* ctx, unsigned char* bodyp, size_t len) {
        tceu_input_BODY args = { ctx, bodyp, len };
        bodyp[len-1] = '\0';
        //printf("BODY: %ld\n", len);
        ceu_input(CEU_INPUT_BODY, &args);
        return SMFIS_CONTINUE;
    }

    sfsistat mlfi_eom (SMFICTX* ctx) {
        sfsistat ret = SMFIS_ACCEPT;
        tceu_input_EOM args = { ctx, &ret };
        //printf("EOM: %p\n", ctx);
        ceu_input(CEU_INPUT_EOM, &args);
        return ret;
    }

    struct smfiDesc smfilter = {
        "greylist",     /* filter name */
        SMFI_VERSION,   /* version code */
        SMFIF_ADDHDRS,  /* flags */
        NULL,           /* connection info filter */
        NULL,           /* SMTP HELO command filter */
        mlfi_envfrom,   /* envelope sender filter */
        mlfi_envrcpt,   /* envelope recipient filter */
        mlfi_header,    /* header filter */
        NULL,           /* end of header */
        mlfi_body,      /* body block filter */
        mlfi_eom,       /* end of message */
        NULL,           /* message aborted */
        NULL,           /* connection cleanup */
    };
end

native/plain _SMFICTX_ptr, _char, _sfsistat;
input (_SMFICTX_ptr, _char&&&&)         ENVFROM;
input (_SMFICTX_ptr, _char&&&&)         ENVRCPT;
input (_SMFICTX_ptr, _char&&, _char&&)  HEADER;
input (_SMFICTX_ptr, byte&&, usize)     BODY;
input (_SMFICTX_ptr, _sfsistat&&)       EOM;

code/await Handler (var _SMFICTX_ptr ctx, var _char&&&& from) -> void do
    [[
        print'=== MILTER'
        from = @from[0]
    ]]
    do
        var _SMFICTX_ptr ctx2;
        var _char&&&& rcpt;
        (ctx2,rcpt) = await ENVRCPT until (ctx2 == ctx);
        [[
            rcpt = @rcpt[0]
        ]]
    end

    // FC2MAIL | chico -> chico | accept and don't forward to FC
    do/_
        var bool ok = [[ (string.find(rcpt, 'chico@@localhost')) and
                         (string.find(from, 'chico@@localhost')) ]];
        if ok then
            [[print'=== MILTER ACCEPT']]
            escape;
        end
    end

    // FETCHMAIL | * -> chico       | discard and forward to FC
    // FC        | * -> @freechains | discard and forward to FC
    // NORMAL    | * -> *           | accept  and forward to FC
    var bool accept = do
        var bool fecthmail = [[ (string.find(rcpt, 'chico@@localhost')) ]];
        var bool fc        = [[ (string.find(rcpt, '@@freechains.org')) ]];
        if fecthmail or fc then
            [[print'=== MILTER DISCARD']]
            escape false;
        else
            [[print'=== MILTER ACCEPT']]
            escape true;
        end
    end;

    vector[] byte body;
    spawn do
        loop do
            var _SMFICTX_ptr ctx2;
            var _char&& headerf;
            var _char&& headerv;
            (ctx2,headerf,headerv) = await HEADER until (ctx2 == ctx);
            vector[] byte headerf_ = [] .. (headerf as _char&&);
            vector[] byte headerv_ = [] .. (headerv as _char&&);
            var bool to = [[ @headerf_ == 'To' ]];
            if to then
                headerv_ = [] .. "chico";
            end
            body = body .. headerf_;
            body = body .. ": ";
            body = body .. headerv_;
            body = body .. "\n";
        end
    end
    spawn do
        var bool first = true;
        loop do
            var _SMFICTX_ptr ctx2;
            var byte&& bodyp;
            var usize len;
            (ctx2,bodyp,len) = await BODY until (ctx2 == ctx);
            if first then
                first = false;
                body = body .. "\n";
            end
            var usize old = $body;
            _ceu_vector_setlen(&&body, $body+len, 1);
            _ceu_vector_buf_set(&&body, old, bodyp, len);
        end
    end

    do
        var _SMFICTX_ptr ctx2;
        var _sfsistat&& ret;
        (ctx2,ret) = await EOM until (ctx2 == ctx);
        if not accept then
            *ret = {SMFIS_DISCARD};
        end
    end

    [=[
print'=== MILTER2FC'
body = @body
--print('===\n'..body..'===')
str = [[
MESSAGE {
    id = '1.0',
    chain = {
        key   = '',
        zeros = 0,
    },
    payload = ]]..string.format('%q',body)..[[,
}
]]
local f = assert(io.open('/tmp/fifo.in', 'w'))
f:write(string.len(str)..'\n')
f:write(str)
f:close()
    ]=]
end

pool[] Handler hs;

par/or do
    var _SMFICTX_ptr ctx;
    var _char&&&& from;
    every (ctx,from) in ENVFROM do
        spawn Handler(ctx,from) in hs;
    end
with
    {
        smfi_setconn("unix:/var/spool/postfix/freechains.milter");
        assert(smfi_register(smfilter) == MI_SUCCESS);
        assert(smfi_main() == MI_SUCCESS);
    }
end

escape 0;
