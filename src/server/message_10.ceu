#ifndef _MESSAGE10_CEU
#define _MESSAGE10_CEU

code/await Recv_10 (var& UV_TCP_Server_Data shared, var& UV_Stream tcp) -> int
    throws Exception.Uv
do

///////////////////////////////////////////////////////////////////////////
// HEADER
///////////////////////////////////////////////////////////////////////////

// => CHAIN_KEY_LEN
// => CHAIN_KEY_STR
// => CHAIN_ZEROS
do/_
    // key_len
    await UV_Stream_Read_N(&tcp, 1);
    var byte key_len = tcp.buffer[0];
    $tcp.buffer = $tcp.buffer - 1;
    _dbg_tcp(2, &&tcp.handle, "server", "CHAIN_KEY_LEN = %d", key_len);

    // key_str
    await UV_Stream_Read_N(&tcp, (key_len as usize));
    var[256] byte key_str = []..tcp.buffer;
    _dbg_tcp(2, &&tcp.handle, "server", "CHAIN_KEY_STR = %s", &&key_str[0]);
    $tcp.buffer = $tcp.buffer - (key_len as usize);

    // zeros
    await UV_Stream_Read_N(&tcp, 1);
    var byte zeros = tcp.buffer[0];
    _dbg_tcp(2, &&tcp.handle, "server", "CHAIN_ZEROS   = %d", zeros);
    $tcp.buffer = $tcp.buffer - 1;

    [[
        key   = @key_str
        zeros = @zeros
        THIS  = {
            chain = FC.chains[key] and CFG.chains[key].zeros<=zeros and FC.chains[key][zeros] or nil
        }
    ]];

    var bool is_sub = [[ THIS.chain ~= nil ]];
    _dbg_tcp(2, &&tcp.handle, "server", "is_sub      = %d", is_sub);
    if not is_sub then
        tcp.buffer = [{MESSAGE10_NOTSUB}];
        await UV_Stream_Write_N(&tcp,_);
        [[ ARGS = THIS ]]
        escape {MESSAGE10_NOTSUB};
    end
end

do/_
    [[ ARGS = THIS ]];
    CHAIN_LOCK(l, shared, "lock_write");
#if 0
[[ THIS.old = os.time() ]];
spawn do
    await 20s;
    [[ error '111' ]];
end
#endif

#if 0
[[
    if DBG_ON then
        print('>>>', @shared.port, @(ret=={MESSAGE10_HAVE}) and 'NO' or 'YES', FC.tostring(THIS.chain.head.hash), THIS.chain.head.length, THIS.length, FC.tostring(THIS.head_hash))
    end
]]
_ceu_assert(ret != {MESSAGE10_NOTSUB}, "NOTSUB");
#endif

    {SERVERS_ALIVE++;}
    do finalize with
        {SERVERS_ALIVE--;}
    end

    ///////////////////////////////////////////////////////////////////////////
    // BLOCKS
    ///////////////////////////////////////////////////////////////////////////

    code/await Go (none) -> none
        throws Exception.Uv
    do
        loop do
            await UV_Stream_Read_N(&outer.tcp, 1);
            var int ret = outer.tcp.buffer[0];
            $outer.tcp.buffer = $outer.tcp.buffer - 1;
            if ret == 0 then
                break;
            end

            [[
                THIS = {
                    chain = ARGS.chain,
                    block = {
                        chain = ARGS.chain,
                    },
                }
            ]];

            // => HASH
            do
                await UV_Stream_Read_N(&outer.tcp, HASH_BYTES);
                var[HASH_BYTES] byte hash;
                _ceu_vector_copy(&&hash,0, &&outer.tcp.buffer,0, HASH_BYTES);
                [[
                    THIS.block.hash = @hash;
                ]];
                $outer.tcp.buffer = $outer.tcp.buffer - HASH_BYTES;
            end

            // => TIMESTAMP + NONCE
            do
                await UV_Stream_Read_N(&outer.tcp, 2*sizeof(u64));
                var u64 timestamp = GET_BE64TOH(outer.tcp.buffer,0);
                $outer.tcp.buffer = $outer.tcp.buffer - sizeof(u64);
                var u64 nonce = GET_BE64TOH(outer.tcp.buffer,0);
                $outer.tcp.buffer = $outer.tcp.buffer - sizeof(u64);
                [[
                    THIS.block.timestamp = @timestamp
                    THIS.block.nonce     = @nonce
                ]]
            end

            // => TP
            await UV_Stream_Read_N(&outer.tcp, 1);
            var int tp = outer.tcp.buffer[0];
            $outer.tcp.buffer = $outer.tcp.buffer - 1;

            do
                var[] byte str = [] .. [[ FC.tostring(THIS.block.hash) ]] .. [0];
                _dbg_tcp(3, &&outer.tcp.handle, "server", "=> BLOCK_HASH [%d] : %s", tp, &&str[0]);
                //_dbg_tcp(3, &&outer.tcp.handle, "server", "=> TP/TIMESTAMP/NONCE : %d %ld %ld", tp,timestamp,nonce);
            end

            if tp == {NODE_JOIN} then
            else/if tp == {NODE_PUB} then

                // =>   BLOCK[1].hash
                do
                    await UV_Stream_Read_N(&outer.tcp, HASH_BYTES);
                    var[HASH_BYTES] byte hash;
                    _ceu_vector_copy(&&hash,0, &&outer.tcp.buffer,0, HASH_BYTES);
                    [[
                        prv = assert(THIS.block.chain.cache[@hash], 'expected in cache')
                        THIS.block[1] = assert(THIS.block.chain.cache[@hash], 'expected in cache')
                    ]];
                    $outer.tcp.buffer = $outer.tcp.buffer - HASH_BYTES;
                end

                do
                    // => PUB_HASH?
                    await UV_Stream_Read_N(&outer.tcp, HASH_BYTES);
                    var[HASH_BYTES] byte pub_hash;
                    _ceu_vector_copy(&&pub_hash,0, &&outer.tcp.buffer,0, HASH_BYTES);
                    [[
                        pub_hash = @pub_hash
                        cache = THIS.chain.up.pubs[pub_hash]
                        THIS.block.pub = cache or {
                            hash      = pub_hash,
                            chain     = THIS.block.chain,
                            timestamp = nil,
                            nonce     = nil,
                            payload   = nil,
                        }
                    ]]

                    // <= PUB_HASH_ACK!
                    var bool has_pub = [[ cache~=nil ]];
                    if has_pub then
                        outer.tcp.buffer = [{MESSAGE10_HAVE}];
                        await UV_Stream_Write_N(&outer.tcp,_);
                        continue;
                    else
                        outer.tcp.buffer = [{MESSAGE10_OK}];
                        await UV_Stream_Write_N(&outer.tcp,_);
                    end
                end

                // => TIMESTAMP + NONCE
                do
                    await UV_Stream_Read_N(&outer.tcp, 2*sizeof(u64));
                    var u64 timestamp = GET_BE64TOH(outer.tcp.buffer,0);
                    $outer.tcp.buffer = $outer.tcp.buffer - sizeof(u64);
                    var u64 nonce = GET_BE64TOH(outer.tcp.buffer,0);
                    $outer.tcp.buffer = $outer.tcp.buffer - sizeof(u64);
                    [[
                        THIS.block.pub.timestamp = @timestamp
                        THIS.block.pub.nonce     = @nonce
                    ]]
                end

                // <= LEN
                // <= PAYLOAD
                do
                    await UV_Stream_Read_N(&outer.tcp, sizeof(u32));
                    var u32 len = GET_BE32TOH(outer.tcp.buffer,0);
                    $outer.tcp.buffer = $outer.tcp.buffer - sizeof(u32);

                    await UV_Stream_Read_N(&outer.tcp, len as usize);
                    var[len] byte payload;
                    _ceu_vector_copy(&&payload,0, &&outer.tcp.buffer,0, len);
                    $outer.tcp.buffer = $outer.tcp.buffer - (len as usize);

                    [[
                        THIS.block.pub.payload = @payload
                        ARGS = { pub=THIS.block.pub }
                    ]]
                    await Publication_Check();
                end

                [[
                    THIS.block = FC.pub(THIS.block)
                    ARGS = { block=THIS.block }
                ]]
                await Block_Check();
            end
        end
    end

    var int count = 0;
    loop do
        if count >= FORK_LENGTHY then
//[[error'oioioi']]
            var Exception.Freechains.Fork_Lengthy e = val Exception.Freechains.Fork_Lengthy(_);
            throw e;
        end

        await UV_Stream_Read_N(&tcp, 1);
        var int has = tcp.buffer[0];
        $tcp.buffer = $tcp.buffer - 1;
        if has == 0 then
            break;
        end

        // => HASH

        await UV_Stream_Read_N(&tcp, HASH_BYTES);
        var[HASH_BYTES] byte hash;
        _ceu_vector_copy(&&hash,0, &&tcp.buffer,0, HASH_BYTES);
        [[
            THIS.hash = @hash;
        ]];
        $tcp.buffer = $tcp.buffer - HASH_BYTES;

        var bool has = [[ THIS.chain.cache[THIS.hash] ]];
        if has then
            tcp.buffer = [{MESSAGE10_HAVE}];
            await UV_Stream_Write_N(&tcp,_);
            await Go();
        else
            tcp.buffer = [{MESSAGE10_OK}];
            await UV_Stream_Write_N(&tcp,_);
        end

#if 0
        {BLOCKS_RECEIVED++;}

        [[ ARGS = THIS ]]
        await Message10_recv(&tcp);
        var bool is_removed = [[ THIS.block.pub==true ]];
        if not is_removed then
            [[ ARGS = THIS ]]
            await Block_Check();
        end
        [[
            if THIS.chain.head.length <= THIS.block.length then
                THIS.chain.head = THIS.block
            end
            THIS.block.prv.nxt = THIS.block
        ]];
#endif
    end

    do finalize with
        [[ ARGS = { chain=THIS.chain } ]];
        emit shared.chain_has_changed;
    end

    // RECHAIN FORK

    [[
        ARGS = {
            from = THIS.fork,
            to   = { first=THIS.first, last=THIS.block },
        }
    ]]
    await Chain_Fork();

#if 0
        [[
            chain = FC.chain_flatten(THIS.chain.id)
            print('===< '..@shared.port)
            print(string.rep('<',79))
            print(FC.tostring(chain))
            print(string.rep('<',79))
        ]];
#endif

    [[
        --print('>>>', next(THIS.chain.removeds or {}))
        assert(not next(THIS.chain.removeds or {}))
        THIS.chain.removeds = nil
    ]]
end

[[ ARGS = THIS ]]
escape {MESSAGE10_OK};

end

#endif
