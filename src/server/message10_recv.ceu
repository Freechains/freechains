#ifndef _MESSAGE10_RECV_CEU
#define _MESSAGE10_RECV_CEU

code/await Message10_header_recv (var& UV_Stream tcp) -> int
    throws Exception.Uv
    // output: THIS = { chain=... }
do
    // => CHAIN_KEY_LEN
    // => CHAIN_KEY_STR
    // => CHAIN_ZEROS
    // => CHAIN_LENGTH
    do/_
        // key_len
        await UV_Stream_Read_N(&tcp, 1);
        var byte key_len = tcp.buffer[0];
        $tcp.buffer = $tcp.buffer - 1;
        _dbg_tcp(2, &&tcp.handle, "server", "CHAIN_KEY_LEN = %d", key_len);

        // key_str
        var[] byte key_str;
        await UV_Stream_Read_N(&tcp, (key_len as usize));
        _ceu_vector_setlen(&&key_str,key_len,1);
        if key_len > 0 then
            _memcpy(&&key_str[0], &&tcp.buffer[0], key_len);
        end
        _dbg_tcp(2, &&tcp.handle, "server", "CHAIN_KEY_STR = %s", &&key_str[0]);
        $tcp.buffer = $tcp.buffer - (key_len as usize);

        // zeros
        await UV_Stream_Read_N(&tcp, 1);
        var byte zeros = tcp.buffer[0];
        _dbg_tcp(2, &&tcp.handle, "server", "CHAIN_ZEROS   = %d", zeros);
        $tcp.buffer = $tcp.buffer - 1;

        // length
        await UV_Stream_Read_N(&tcp, sizeof(u64));
        var u64 length = GET_BE64TOH(tcp.buffer,0);
        _dbg_tcp(2, &&tcp.handle, "server", "CHAIN_LENGTH  = %ld", length);
        $tcp.buffer = $tcp.buffer - sizeof(u64);

        [[
            THIS = {
                length = @length,
                chain = GG.chain_parse_get( {
                    key   = @key_str,
                    zeros = @zeros,
                } )
            }
            ARGS = THIS
        ]];

        var bool is_sub = [[ THIS.chain ~= nil ]];
        _dbg_tcp(2, &&tcp.handle, "server", "is_sub      = %d", is_sub);
        if not is_sub then
            escape {MESSAGE10_NOTSUB};
        end

        var bool is_lengthier = [[ THIS.chain.length >= @length ]];
        if is_lengthier then
            escape {MESSAGE10_HAVE};
        end
    end

    escape {MESSAGE10_OK};
end

code/await Message10_block_recv (var& UV_Stream tcp) -> none
    // input: { chain={...}, block={TODO} }
    throws Exception.Uv
do
    [[ THIS = ARGS ]];

    // => HASH
    await UV_Stream_Read_N(&tcp, HASH_BYTES);

    var[HASH_BYTES] byte hash;
    _ceu_vector_setlen(&&hash, HASH_BYTES, 1);
    _ceu_vector_buf_set(&&hash, 0, &&tcp.buffer[0], HASH_BYTES);
    [[
        THIS.block.hash = @hash;
    ]];
    $tcp.buffer = $tcp.buffer - HASH_BYTES;

    do
        var[] byte str = [] .. [[ tostring2(THIS.block.hash) ]] .. [0];
        _dbg_tcp(3, &&tcp.handle, "server", "=> BLOCK_HASH : %s", &&str[0]);
    end

    // => TIMESTAMP + NONCE
    await UV_Stream_Read_N(&tcp, 2*sizeof(u64));
    var u64 timestamp = GET_BE64TOH(tcp.buffer,0);
    $tcp.buffer = $tcp.buffer - sizeof(u64);
    var u64 nonce     = GET_BE64TOH(tcp.buffer,0);
    $tcp.buffer = $tcp.buffer - sizeof(u64);

    // => PUBLICATION_HASH
    await UV_Stream_Read_N(&tcp, HASH_BYTES);
    var[HASH_BYTES] byte hash_publication;
    _ceu_vector_setlen(&&hash_publication, HASH_BYTES, 1);
    _ceu_vector_buf_set(&&hash_publication, 0, &&tcp.buffer[0], HASH_BYTES);
    [[
        hash_publication = @hash_publication
    ]]
    $tcp.buffer = $tcp.buffer - HASH_BYTES;

    // => PRV_HASH
    await UV_Stream_Read_N(&tcp, HASH_BYTES);
    var[HASH_BYTES] byte hash_prv = [] .. tcp.buffer;
    [[
        hash_prv = @hash_prv
        assert(THIS.chain.head.hash == hash_prv)
        publication = APP.publications[hash_publication]
    ]]

    // <= ACK-publication
    var bool has_publication = [[ publication~=nil ]];
    var int ret = do
        if has_publication then
            escape {MESSAGE10_HAVE};
        else
            escape {MESSAGE10_OK};
        end
    end;
    outer.tcp.buffer = [ret];
    await UV_Stream_Write_N(&outer.tcp,_);

    if has_publication then
        [[ THIS.block.publication = publication ]]
    else
        // => TIMESTAMP + NONCE + LEN
        await UV_Stream_Read_N(&tcp, 2*sizeof(u64) + sizeof(u32));
        var u64 timestamp = GET_BE64TOH(tcp.buffer,0);
        $tcp.buffer = $tcp.buffer - sizeof(u64);
        var u64 nonce     = GET_BE64TOH(tcp.buffer,0);
        $tcp.buffer = $tcp.buffer - sizeof(u64);
        var u32 len       = GET_BE32TOH(tcp.buffer,0);
        $tcp.buffer = $tcp.buffer - sizeof(u32);

        await UV_Stream_Read_N(&tcp, len as usize);
        var[len] byte payload;
        _ceu_vector_setlen(&&payload, len, 1);
        _ceu_vector_buf_set(&&payload, 0, &&tcp.buffer[0], len);
        $tcp.buffer = $tcp.buffer - (len as usize);
    end
end

[[
    THIS = {
        chain = nil,
    }
]];

///////////////////////////////////////////////////////////////////////////
// HEADER
///////////////////////////////////////////////////////////////////////////

// <= ACK-header
// bytes/reader received from message partially parsed
var int ret = await Message10_header_recv(&outer.tcp);
[[
    THIS = ARGS
    assert(THIS.chain)
]]
outer.tcp.buffer = [ret];
await UV_Stream_Write_N(&outer.tcp,_);

if ret=={MESSAGE10_NOTSUB} or ret=={MESSAGE10_HAVE} then
    escape/out ret;     // terminate if not subcribed or local is lengthier
end

[[ ARGS = THIS ]];
await Chain_Lock(&outer.shared);

{SERVERS_ALIVE++;}
do finalize with
{SERVERS_ALIVE--;}
end

[[
    THIS.fork = nil
]];

// FINDS COMMON BLOCK DOWNWARDS

var u64 len;
loop len do
    await UV_Stream_Read_N(&outer.tcp, HASH_BYTES);
    [[
        block = GG.chain_block(THIS.chain,@outer.tcp.buffer)
    ]]
    var bool has = [[ block~=nil ]];
    var int ret = do
        if has then
            escape {MESSAGE10_HAVE};
        else
            escape {MESSAGE10_OK};
        end
    end;
    outer.tcp.buffer = [ret];
    await UV_Stream_Write_N(&outer.tcp,_);
    if has then
        [[
            THIS.fork  = block.nxt
            THIS.block = block
        ]]
        break;
    end
end

// TODO verify len

// RECEIVE ALL BLOCKS

var u64 i;
loop i in [0 -> len[ do
{BLOCKS_RECEIVED++;}
    [[
        THIS.block = {
            version = '1.0',
            timestamp   = nil,
            nonce       = nil,
            chain       = THIS.chain,
            publication = nil,
            hash        = nil,
            prv         = THIS.block,
            nxt         = nil,
        }
    ]];

    [[ ARGS = THIS ]]
    await Message10_block_recv(&outer.tcp);
// TODO
    //await Block_Check();
    [[
        THIS.chain.head = THIS.block
        THIS.block.prv.nxt = THIS.block
    ]];
end

// RETRANSMIT NEW HEAD

await Client_10(&outer.shared);

// RECHAIN FORK

loop do
    var bool has = [[ THIS.fork~=nil ]];
    if not has then
        break;
    end

    [[
        THIS.block = {
            version = '1.0',
            timestamp   = 0,    -- TODO: 64-bit timestamp
            nonce       = 0,
            chain       = THIS.fork.chain,
            publication = THIS.fork.publication,
            hash        = nil,
            prv         = nil,
            nxt         = nil,
        }
        ARGS = THIS
    ]]
    await Block_Hash_Link();
    [[
        THIS = { chain=THIS.block.chain }
        ARGS = THIS
    ]];
    await Client_10(&outer.shared);
end

escape/out {MESSAGE10_OK};

#endif
