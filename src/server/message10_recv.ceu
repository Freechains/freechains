#ifndef _MESSAGE10_RECV_CEU
#define _MESSAGE10_RECV_CEU

code/await Message10_block_recv (var& UV_Stream tcp) -> none
    // input: { chain={...}, block={TODO} }
    throws Exception.Uv
do
    [[ THIS = ARGS ]];

    // => HASH
    await UV_Stream_Read_N(&tcp, HASH_BYTES);

    var[HASH_BYTES] byte hash;
    _ceu_vector_setlen(&&hash, HASH_BYTES, 1);
    _ceu_vector_buf_set(&&hash, 0, &&tcp.buffer[0], HASH_BYTES);
    [[
        THIS.block.hash = @hash;
    ]];
    $tcp.buffer = $tcp.buffer - HASH_BYTES;

    // => TIMESTAMP + NONCE
    await UV_Stream_Read_N(&tcp, 2*sizeof(u64));
    var u64 timestamp = GET_BE64TOH(tcp.buffer,0);
    $tcp.buffer = $tcp.buffer - sizeof(u64);
    var u64 nonce     = GET_BE64TOH(tcp.buffer,0);
    $tcp.buffer = $tcp.buffer - sizeof(u64);
    [[
        THIS.block.timestamp = @timestamp
        THIS.block.nonce     = @nonce
    ]]

    do
        var[] byte str = [] .. [[ tostring2(THIS.block.hash) ]] .. [0];
        _dbg_tcp(3, &&tcp.handle, "server", "=> BLOCK_HASH : %s", &&str[0]);
        _dbg_tcp(3, &&tcp.handle, "server", "=> TIMESTAMP/NONCE : %ld %ld", timestamp,nonce);
    end

    // => PUBLICATION_HASH
    await UV_Stream_Read_N(&tcp, HASH_BYTES);
    var[HASH_BYTES] byte publication_hash;
    _ceu_vector_setlen(&&publication_hash, HASH_BYTES, 1);
    _ceu_vector_buf_set(&&publication_hash, 0, &&tcp.buffer[0], HASH_BYTES);
    [[
-- TODO: cache of publications
        THIS.publication_hash = @publication_hash
        --THIS.block.publication = APP.publications[THIS.publication_hash]
    ]]
    $tcp.buffer = $tcp.buffer - HASH_BYTES;

    // => PRV_HASH
    await UV_Stream_Read_N(&tcp, HASH_BYTES);
    var[HASH_BYTES] byte hash_prv = [] .. tcp.buffer;
    [[
        hash_prv = @(hash_prv)
        -- only if not a fork
        --assert(THIS.chain.head.hash == hash_prv)
    ]]
    $tcp.buffer = $tcp.buffer - HASH_BYTES;

    // <= ACK-publication
    var bool has_publication = [[ THIS.block.publication~=nil ]];
    var int ret = do
        if has_publication then
            escape {MESSAGE10_HAVE};
        else
            escape {MESSAGE10_OK};
        end
    end;
    outer.tcp.buffer = [ret];
    await UV_Stream_Write_N(&outer.tcp,_);

    if not has_publication then
        // => TIMESTAMP + NONCE + LEN
        await UV_Stream_Read_N(&tcp, 2*sizeof(u64) + sizeof(u32));
        var u64 timestamp = GET_BE64TOH(tcp.buffer,0);
        $tcp.buffer = $tcp.buffer - sizeof(u64);
        var u64 nonce     = GET_BE64TOH(tcp.buffer,0);
        $tcp.buffer = $tcp.buffer - sizeof(u64);
        var u32 len       = GET_BE32TOH(tcp.buffer,0);
        $tcp.buffer = $tcp.buffer - sizeof(u32);

        await UV_Stream_Read_N(&tcp, len as usize);
        var[len] byte payload;
        _ceu_vector_setlen(&&payload, len, 1);
        _ceu_vector_buf_set(&&payload, 0, &&tcp.buffer[0], len);
        $tcp.buffer = $tcp.buffer - (len as usize);

        [[
            THIS.block.publication = {
                chain     = THIS.chain,
                timestamp = @timestamp,
                nonce     = @nonce,
                payload   = @payload,
                hash      = THIS.publication_hash,
            }
            ARGS = { publication=THIS.block.publication }
        ]]
        await Publication_Check();
    end
end

///////////////////////////////////////////////////////////////////////////
// HEADER
///////////////////////////////////////////////////////////////////////////

// => CHAIN_KEY_LEN
// => CHAIN_KEY_STR
// => CHAIN_ZEROS
// => CHAIN_LENGTH
// => CHAIN_HEAD_HASH
do
    // key_len
    await UV_Stream_Read_N(&outer.tcp, 1);
    var byte key_len = outer.tcp.buffer[0];
    $outer.tcp.buffer = $outer.tcp.buffer - 1;
    _dbg_tcp(2, &&outer.tcp.handle, "server", "CHAIN_KEY_LEN = %d", key_len);

    // key_str
    var[] byte key_str;
    await UV_Stream_Read_N(&outer.tcp, (key_len as usize));
    _ceu_vector_setlen(&&key_str,key_len,1);
    if key_len > 0 then
        _memcpy(&&key_str[0], &&outer.tcp.buffer[0], key_len);
    end
    _dbg_tcp(2, &&outer.tcp.handle, "server", "CHAIN_KEY_STR = %s", &&key_str[0]);
    $outer.tcp.buffer = $outer.tcp.buffer - (key_len as usize);

    // zeros
    await UV_Stream_Read_N(&outer.tcp, 1);
    var byte zeros = outer.tcp.buffer[0];
    _dbg_tcp(2, &&outer.tcp.handle, "server", "CHAIN_ZEROS   = %d", zeros);
    $outer.tcp.buffer = $outer.tcp.buffer - 1;

    // length
    await UV_Stream_Read_N(&outer.tcp, sizeof(u64));
    var u64 length = GET_BE64TOH(outer.tcp.buffer,0);
    _dbg_tcp(2, &&outer.tcp.handle, "server", "CHAIN_LENGTH  = %ld", length);
    $outer.tcp.buffer = $outer.tcp.buffer - sizeof(u64);

    // head_hash
    await UV_Stream_Read_N(&outer.tcp, HASH_BYTES);
    var[HASH_BYTES] byte head_hash;
    _ceu_vector_setlen(&&head_hash, HASH_BYTES, 1);
    _ceu_vector_buf_set(&&head_hash, 0, &&outer.tcp.buffer[0], HASH_BYTES);
    $outer.tcp.buffer = $outer.tcp.buffer - HASH_BYTES;

    [[
        THIS = {
            length    = @length,
            head_hash = @head_hash,
            chain     = GG.chain_parse_get( {
                key   = @key_str,
                zeros = @zeros,
            } )
        }
    ]];
end

var int ret = do
    var bool is_sub = [[ THIS.chain ~= nil ]];
    _dbg_tcp(2, &&outer.tcp.handle, "server", "is_sub      = %d", is_sub);
    if not is_sub then
        escape {MESSAGE10_NOTSUB};
    end

    //_dbg_tcp(2, &&outer.tcp.handle, "server", "***");
    //[[ print('***', THIS.chain.head.length, '<-', THIS.length) ]];
    var bool me_lengthier = [[ THIS.chain.head.length > THIS.length ]];
    if me_lengthier then
        escape {MESSAGE10_HAVE};
    end

    var bool me_same = [[ THIS.chain.head.length == THIS.length ]];
    if me_same then
        var bool me_greater = [[ THIS.chain.head.hash >= THIS.head_hash ]];
        if me_greater then
            escape {MESSAGE10_HAVE};
        end
    end

    escape {MESSAGE10_OK};
end;

outer.tcp.buffer = [ret];
await UV_Stream_Write_N(&outer.tcp,_);

if ret=={MESSAGE10_NOTSUB} or ret=={MESSAGE10_HAVE} then
    escape/out ret;     // terminate if not subcribed or local is lengthier
end

[[ ARGS = THIS ]];
CHAIN_LOCK(l,outer.shared);

{SERVERS_ALIVE++;}
do finalize with
    {SERVERS_ALIVE--;}
end
//[[ print('!!!', THIS.chain.head.length, '<-', THIS.length) ]];

///////////////////////////////////////////////////////////////////////////
// BLOCKS
// - first, sends hashes from head -> genesis until finds common block
// - then, receives from common.nxt -> head
///////////////////////////////////////////////////////////////////////////

[[ THIS.common = THIS.chain.head ]];
var int i;
loop i do
    if i >= FORK_LENGTHY then
        var Exception.Freechains.Fork_Lengthy e = val Exception.Freechains.Fork_Lengthy(_);
        throw e;
    end

    // <= HASH
    outer.tcp.buffer = outer.tcp.buffer .. [[ THIS.common.hash ]];
    do
        var[] byte str = [] .. [[ tostring2(@outer.tcp.buffer) ]] .. [0];
        _dbg_tcp(3, &&outer.tcp.handle, "server", "<= BLOCK_HASH? : %s", &&str[0]);
    end
    await UV_Stream_Write_N(&outer.tcp, _);

    // => ACK-HASH
    await UV_Stream_Read_N(&outer.tcp, 1);
    var byte ret = outer.tcp.buffer[0];
    $outer.tcp.buffer = $outer.tcp.buffer - 1;
    if ret == {MESSAGE10_HAVE} then
        break;
    else/if ret == {MESSAGE10_OK} then
        // continue
    else
        var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
        throw e;
    end

    [[ THIS.common = THIS.common.prv ]];
    var bool has = [[ THIS.common~=nil ]];
    if not has then
        // remote must have genesis at least
        var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
        throw e;
    end
end
[[ THIS.fork = THIS.common.nxt ]];

// RECEIVE ALL BLOCKS

//_dbg_tcp(3, &&outer.tcp.handle, "server", "oioi");
//[[ print('444', THIS.length, THIS.common.length, THIS.chain.head.length) ]];

var u64 length = [[ THIS.length-THIS.common.length ]];
var u64 i;
loop i in [1 -> length] do
{BLOCKS_RECEIVED++;}
    [[
        THIS.block = {
            version = '1.0',
            timestamp   = nil,
            nonce       = nil,
            chain       = THIS.chain,
            publication = nil,
            hash        = nil,
            prv         = THIS.block or THIS.common,
            nxt         = nil,
            length      = THIS.common.length+@i,
        }
        THIS.first = THIS.first or THIS.block
    ]];

    [[ ARGS = THIS ]]
    await Message10_block_recv(&outer.tcp);
    [[ ARGS = THIS ]]
    await Block_Check();
    [[
        if THIS.chain.head.length <= THIS.block.length then
--print('???', THIS.chain.head.length, '->', THIS.block.length)
            THIS.chain.head = THIS.block
        end
        THIS.block.prv.nxt = THIS.block
    ]];
end

// RECHAIN FORK

[[
    ARGS = {
        from = THIS.fork,
        to   = { first=THIS.first, last=THIS.block },
    }
    --print('-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-', THIS.block.length)
    --print('FROM: ', ARGS.from and tostring2(ARGS.from.hash))
    --print('HEAD: ', tostring2(ARGS.to.first.chain.head.hash))
    --print('TO: ', tostring2(ARGS.to.first.hash), tostring2(ARGS.to.last.hash))
]]
await Chain_Fork();

// RETRANSMIT NEW HEAD

[[ ARGS = { chain=THIS.chain } ]]
await Client_10(&outer.shared);

escape/out {MESSAGE10_OK};

#endif
