#include "c.ceu"

#define MESSAGE_MAGIC_0 'P'
#define MESSAGE_MAGIC_1 'S'
#define MESSAGE_MAJOR   0
#define MESSAGE_MINOR   0

#define HASH_BYTES      32
#define BC_DATA_BYTES   128

#define AWAIT_UNTIL(r,nxt)          \
    if r.next < nxt then            \
        loop do                     \
            await r.ok;             \
            if r.next >= nxt then   \
                break;              \
            end                     \
        end                         \
    end

#define UV_TCP_SERVER_HANDLER_CEU server.ceu
#include "uv.ceu"
#include "client.ceu"

/*
///////////////////////////////////////////////////////////////////////////////
// client proposes message
///////////////////////////////////////////////////////////////////////////////
// identifies this message (protocol, version)
//  a server may refuse or behave differently
MESSAGE_MAGIC_0  1        // 'P'
MESSAGE_MAGIC_1  1        // 'S'
MESSAGE_MAJOR    1
MESSAGE_MINOR    1
// identifies the blockchain for this message
//  a server may not be interested in this blockchain
BC_ZEROS         1        // number of required zeros for PoWs
BC_SIGNED?       1b       // message must be signed and checked
BC_LEN           7b       // number of bytes for the BC identifier
BC_DATA          <BC_LEN> // BC identifier (pubkey?, topic?) (if signed, must be pubkey)
// identifies the data for this message
//  a server may have this payload
PAYLOAD_HASH     32       // TODO hash of the payload
///////////////////////////////////////////////////////////////////////////////
// server responds 0/1
// client completes message
///////////////////////////////////////////////////////////////////////////////
//  H = hash[PoW .. BACK_HASH .. PAYLOAD_HASH]
PoW              4 u32    // nonce for H
PoS              1        // value of random jump in the BC
BACK_HASH        32       // immutable: a past hash at most TODO jumps away from PAYLOAD_HASH
TAIL_HASH        32       // mutable: immediate past hash which creates the chain
PAYLOAD_LEN      4 u32    // number of bytes to read next for the payload
PAYLOAD          <PAYLOAD_LEN>
///////////////////////////////////////////////////////////////////////////////
//  - H must have BC_ZEROS leading zeros
//  - on creation, BACK_HASH=TAIL_HASH, but nodes can change TAIL_HASH to 
//    reorder the chain
//  - since H uses BACK_HASH, an attacker cannot preprocess a side chain and 
//    attach it to a recent node to force a fork
//  - PoS = BACK_HASH - H(mapped to full memory from BACK_HASH to genesis)
//      - force nodes willing to publish to keep all data
//          - in BTC, miners need to check funds looking all the way back
///////////////////////////////////////////////////////////////////////////////
*/

native do
    enum {
        ERR_NONE         =  0,
        ERR_EXTRA_BYTES  = -1,
        ERR_MESSAGE      = -2,
        ERR_DISCONNECTED = -3,
    };
end

input (int, _char&& &&) OS_START;

var int        argc;
var _char&& && argv;
(argc, argv) = await OS_START;
if argc < 2 then
    _fprintf(_stderr, "Usage: %s (<src.lua>)+\n", argv[0]);
    _assert(0);
end

// load *.lua files
[[ dofile'src/common.lua' ]];
loop i in argc-1 do
    var char&& cfg = argv[i+1];
    [[
        dofile(@cfg)
    ]];
end

par/or do
    do Client;
    await FOREVER;
with
    var char[] ip      = [[ APP.server.host[1] ]];
    var int    port    = [[ APP.server.host[2] ]];
    var int    backlog = [[ APP.server.backlog ]];
    _printf("[server] Listening in %s:%d.\n", (_char&&)&&ip, port);
    do UV_TCP_Server.build(&ip, port, backlog);
end

_assert(0);
escape 0;
