#include "common.ceu"

var UV_TCP_Server_Data shared = _;
[=[
    dofile 'src/common.lua'
    CONFIG, _, _ = table.unpack(arg)
    dofile(CONFIG)
]=];

await Init();

[[ main = {} ]]

var int n = [[ #APP.chains ]];
var int i;
loop i in [1 -> n] do
    [[ chain = APP.chains[@i] ]];
    var bool is_zero = [[ chain.zeros==0 ]];
    if is_zero then
        [[
            path = APP.chains.files..'/'..chain.id..'.chain'
            --print(chain.id, path)
        ]]
        vector[] byte path = [] .. [[path]];
        var int ret = await FS_read_10(&path);
        if ret == _ERR_NONE then
            [[
                -- TODO: assert chain.id==file header
                --chain.genesis_hash  = ARGS.genesis_hash
                chain.head_hash     = ARGS.head_hash
            ]];
        else
            _dbg(0, "main: file not found: %s\n", &&path[0]);
        end
        [[
            chain.prv_head_hash = chain.head_hash
        ]]
    end
end

vector[] byte ip      = [] .. [[ APP.server.host[1] ]];
var      int  port    = [[ APP.server.host[2] ]];
var      int  backlog = [[ APP.server.backlog ]];
_dbg(0, "server | listening in %s:%d", &&ip[0], port);
spawn UV_TCP_Server(&shared, &&ip[0], port, backlog);

par do
    [[
        main.pending = {}
    ]]
    spawn do
        var int msg;
        var int err;
        every (msg, err) in shared.ok do
            _ceu_dbg_assert(msg == 0x100);
            [[ print('>>> PENDING >>>', ARGS.chain.id) ]];
            [[ main.pending[#main.pending+1] = ARGS.chain ]];
        end
    end

    loop do
        loop do
            var bool has_pending = [[ #main.pending>0 ]];
            if has_pending then
                break;
            else
                await shared.ok;
            end
        end

        [[
            main.chain = table.remove(main.pending,1)
            path = APP.chains.files..'/'..main.chain.id..'.chain'
            print('>>> WRITE >>>', main.chain.id, path)
        ]]
        vector[] byte path = [] .. [[path]];

        _dbg(0, "server | received");
        [[ ARGS={ chain_id=main.chain.id } ]];
        var int? ret = await FS_write_10(&path);
        _ceu_dbg_assert(ret! == _ERR_NONE);

        [[
            _, _, OUTPUT = table.unpack(arg)
            local f = assert(io.open(OUTPUT, 'w'))
            local cur_hash = main.chain.head_hash
            while true do
                if cur_hash == main.chain.prv_head_hash then
                    break   -- handled previously
                end
                local block = APP.blocks[cur_hash]
                for _,tx in pairs(block.txs) do
                    tx = APP.txs[tx]
                    --for k,v in pairs(tx) do
                        --print(k,v)
                    --end
                    f:write(string.len(tx.payload)..'\n')
                    f:write(tx.payload)
                end
                cur_hash = block.tail_hash
            end
            main.chain.prv_head_hash = main.chain.head_hash
            f:close()
        ]]
    end
with
    vector[] byte msgs;
    event void ok;
    par do
        lua[] do
            [[
                _, INPUT, _ = table.unpack(arg)
            ]]
            loop do
                await async/thread (msgs) do
                    [[
                        local f = assert(io.open(INPUT, 'r+'))
                        local n = assert(tonumber(assert(f:read('l'))))
                        --print(n)
                        buf = f:read(n)
                        --print(buf)
                    ]]
                end
                msgs = [] .. [[ buf ]];
                par/and do
                    emit ok;
                with
                    await ok;
                end
            end
        end
    with
        await ok;
        loop do
            [[
                assert(load(@msgs))()
            ]]
            _dbg(0, "client...");
            await ClientMessages(&shared);
            _dbg(0, "client | ok");
            emit shared.ok(0x100, _ERR_NONE);
            par/and do
                emit ok;
            with
                await ok;
            end
        end
    end
end
