#define DBG 0

#include "common.ceu"

[[
    dofile 'src/common.lua'
    local config = table.unpack(arg)

    THIS = {
        pending = {},
    }

    CFG = {}
    assert(loadfile(config,nil,CFG))()
]]

event none write_ok;
var UV_TCP_Server_Data shared = _;
spawn Errors(&shared);

await Init();
[[
    os.execute('mkfifo '..CFG.dir..'/fifo.in')
    os.execute('mkfifo '..CFG.dir..'/fifo.out')
]]

var[] byte ip      = [] .. [[ CFG.server.address or '0.0.0.0' ]] .. [0];
var   int  port    = [[ CFG.server.port or 8330 ]];
var   int  backlog = [[ CFG.server.backlog or 128 ]];
spawn UV_TCP_Server(&&ip[0], port, backlog, _, &shared);
_dbg(0, "server | listening in %s:%d", &&ip[0], port);

par do
    spawn do
        var int  msg;
        var bool err;
        var int  ret;
        every (msg,err,ret) in shared.ok do
            if not err then
                _ceu_assert(msg == {MESSAGE10}, "bug found");
                if ret == {MESSAGE10_OK} then
                    //[[ print('>>> PENDING >>>', ARGS.chain.id) ]];
                    [[ THIS.pending[#THIS.pending+1] = ARGS.chain ]];
                    var[256] byte id = []..[[ARGS.chain.id]]..[0];
                    _dbg(0, "server | pending in %s", &&id[0]);
                end
            end
        end
    end

    loop do
        loop do
            var bool has_pending = [[ #THIS.pending>0 ]];
            if has_pending then
                break;
            else
                emit write_ok;
                await shared.ok;
            end
        end

        [[
            THIS.chain = table.remove(THIS.pending,1)
            path = CFG.dir..'/chains/'..THIS.chain.id..'.chain'
            --print('>>> WRITE >>>', THIS.chain.id, path)
        ]]
        var[] byte path = [] .. [[path]] .. [0];

        [[
            local f = assert(io.open(CFG.dir..'/fifo.out', 'a'))
            local function out (cur)   -- reverse order
                if cur == THIS.chain.last_output then
                    return   -- handled previously
                end
                out(cur.prv)
                local t = {
                    version = '1.0',
                    hash = cur.hash,
                    timestamp = cur.timestamp,
                    chain = {
                        key   = cur.chain.key,
                        zeros = cur.chain.zeros,
                    },
                    publication = {
                        hash      = cur.publication.hash,
                        timestamp = cur.publication.timestamp,
                        payload   = cur.publication.payload,
                    },
                }
                f:write(tostring2(t,'plain')..'\n')
            end
            out(THIS.chain.head)
            THIS.chain.last_output = THIS.chain.head
            f:close()
        ]]

        // persist after handling
        [[ ARGS={ chain=THIS.chain } ]];
        await FS_write_10();
    end
with
    // the "par" is required because of the separated "lua[]"
    // because of the "async/thread" because of the blocking "f:read()" that
    // has to remain always open
    event none ok;

    var[] byte msg;
    var bool is_publish   = false;
    var bool is_subscribe = false;

    par do
        await ok;
        loop do
            if is_publish then
                [[
                    assert(load('ARGS = { message='..@msg..' }'))()
                ]]
                _dbg(0, "client...");
                await Client(&shared);
                _dbg(0, "client | ok");
            else/if is_subscribe then
                [[
                    assert(load('new = '..@msg))()
                    for _, old in ipairs(CFG.chains) do
                        assert(old.key ~= new.key)
                    end
                    CFG.chains[#CFG.chains+1] = new
                ]]
                //TODO-write-CFG
                await Init();
            end
            par/and do
                emit ok;
            with
                await ok;
            end
        end
    with
        var[] byte fifo_in = []..[[CFG.dir..'/fifo.in']];
        lua[] do
            [[
                f = assert(io.open(@fifo_in, 'r+'))
            ]]
            do finalize with
                [[ f:close() ]]
            end
            loop do
                await async/thread do
                    [[
                        local line = f:read('l')
                        cmd, p1, p2 = string.match(line, '([^ ]*) ?([^ ]*) ?([^ ]*) ?')

                        is_publish   = false
                        is_subscribe = false
                        
                        if cmd == 'publish' then
                            local n = assert(tonumber(p1))
                            is_publish = true
                            msg = f:read(n)
                            print(n, msg)
                        elseif cmd == 'subscribe' then
                            local n = assert(tonumber(p1))
                            is_subscribe = true
                            msg = f:read(n)
                            print(n, msg)
                        end
                    ]]
                end

                is_publish   = [[ is_publish ]];
                is_subscribe = [[ is_subscribe ]];
                msg          = [] .. [[ msg ]];

                par/and do
                    emit ok;
                with
                    await ok;
                end

                is_publish   = false;
                is_subscribe = false;
            end
        end
    end
end
