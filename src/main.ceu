#if 0
= TODO:
    - remove HAVE_NO => ERR_NO
    - testar contcat de fato com big/small old/new
    - join, verificar maior chain
    - serialize to disk
        - BLOCK_HASH .. PAYLOAD_LEN .. [PoW..BACK_HASH..PAYLOAD]
    - verificar backs, pos
        - reverificar backs em rejoins
    - verificar se sequencia de LEN/HASH ultrapassa PAYLOAD_LEN_LIMIT
    - nonce => timestamp s64
    - BLOCK vs MSG nomenclature
    - Message prepare do client pode ter todos os campos necessarios para o 
      send evita *muitas* copias

= BUGS:
    - common genesis to all chains will conflict on gen.up_hash
        - has to assert before
        - use a hash based on the chain unique identification!

= IDEAS:
    - esquema de nomes bc/path/, pega mais recente, bc/path/^..., git
    - aquivos plain, + arquivos meta em lua/binario

#endif

#include "c.ceu"

#define MESSAGE_BYTES   4
#define MESSAGE_MAGIC_0 'P'
#define MESSAGE_MAGIC_1 'S'

#define HASH_BYTES      32
#define CHAIN_KEY_BYTES 256

native @pure _leading_zeros();
native do
    enum {
        ERR_NONE                    =  0,
        ERR_MESSAGE                 = -1,
        ERR_REMOTE_BUG_OR_MALICIOUS = -2,
    };

    enum {
        MESSAGE10 = 1,
    };

    enum {
        MESSAGE10_NOTSUB = 1,   // [ok ACK] not subscribed to this chain
        MESSAGE10_HAVE,         // [ok ACK] already has it
        MESSAGE10_LIMIT,        // [ok ACK] too big for untrusted client
    };

    // calculate the number of leading zero bits in "bytes"
    // 00abcdef...  => 2
    int leading_zeros (byte* bytes, int len) {
        int i, j;
        int zeros = 0;
        for (i=0; i<len; i++) {             // loop over "bytes"
            byte b = bytes[i];
            for (j=0; j<8; j++) {           // loop over each bit
                if ((b & (1<<j)) != 0) {
                    return zeros;
                } else {
                    zeros++;
                }
            }
        }
        return zeros;
    }
end

class Message with
output/input:
    var byte[] bytes;
    var byte[] offs;
do
    await FOREVER;
end

#include "uv.ceu"
#include "client.ceu"
#define UV_TCP_SERVER_HANDLER_CEU server.ceu
#include "uv-server.ceu"

/*
= Message10_00_chain
- MESSAGE_*:    obligatory
- CHAIN_*:      avoids sequence of unsubscribed hashes
    - ok: not sub
--
= Message10_01_oldest_hash
    - receive many until HAVE_NO
- BLOCK_HASH:   client will typically guess correctly
    - ok: have
- PAYLOAD_LEN
    - ok: too big
---
- POW
- BACK_HASH
- PAYLOAD
    - no: no match
- POS
    - no: no match
(TAIL_HASH: got implicitly from the protocol)
===
- TODO: sig

///////////////////////////////////////////////////////////////////////////////
// MESSAGE_10: client proposes block to the server
///////////////////////////////////////////////////////////////////////////////
    - type of MESSAGE_*: server checks before anything else
    - CHAIN_*:           server checks if it is subscribing to this
    - TXS_PAYLOAD_BYTES: server may not want big messages from untrusted clients
    - block_hash, server may already have it
///////////////////////////////////////////////////////////////////////////////
// CLIENT => SERVER
// identifies this message (protocol, version)
//  - a server may refuse or behave differently
MESSAGE_MAGIC_0 1       // 'P'
MESSAGE_MAGIC_1 1       // 'S'
MESSAGE_MAJOR   1
MESSAGE_MINOR   0
// identifies the blockchain for this block
//  - a server may not be interested in this blockchain
//      - key is unintereresting
//      - zeros is too weak and prone to SPAM
//      - limits are too big for network/machine capacity
CHAIN_LEN       1       // number of bytes for the CHAIN identifier
CHAIN_KEY       <CHAIN_LEN> // CHAIN identifier (pubkey?, topic?) (if signed, must be pubkey)
CHAIN_ZEROS     1       // number of zeros to be trasmitted (or signed)
CHAIN_LIMITS    1       // max number of TXs per block | max bytes of TX payload
    block       4b      // 0=any,1=1,2=10,3=100,4=1k,5=10k,6=100k,7=1M
    payload     4b      // 0=any,1=100b,2=1K,3=10K,4=100K,5=1M,6=10M,7=100M
///////////////////////////////////////////////////////////////////////////////
// CLIENT <= SERVER
//  - server responds if is subscribed to the chain
-               1       // _ERR_NONE | MESSAGE10_NOTSUB
///////////////////////////////////////////////////////////////////////////////
// CLIENT => SERVER
//  - clients sends all BLOCKs
//      - server responds YES/NO for each
//      - if YES
//          - client sends all TX_BYTES+TX_HASH
//              - server responds YES/NO for each
//              - TX_PAYLOAD_BYTES: must be compatible with 
//                CHAIN_LIMITS.payload
//              - TX_HASH: server may already have
//          - loop is bounded to CHAIN_LIMITS.block
//      - loop is bounded to CHAIN_LIMITS.block
///////////////////////////////////////////////////////////////////////////////
LOOP for each BLOCK in CHAIN
    // identifies the block payload
    //  - a server may already have it
    -- CLIENT => SERVER
    BLOCK_HASH      32      // hash of the proposed block
    BLOCK_TXS_N     4 u32   // number of txs in the block
    -- CLIENT <= SERVER
    -               1       // MESSAGE10_HAVE_YES|MESSAGE10_HAVE_NO
    LOOP for each TX in BLOCK
        -- CLIENT => SERVER
        TX_HASH          32     // hash[TIMESTAMP..TX_BACK_HASH..TX_PAYLOAD]
        TX_PAYLOAD_BYTES 4 u32
        -- CLIENT <= SERVER
        -               1       // MESSAGE10_HAVE_YES|MESSAGE10_HAVE_NO
        -- CLIENT => SERVER
        TIMESTAMP       8 s64   // nonce for TX_HASH
        TX_BACK_HASH    32      // recent back hash
        TX_PAYLOAD      <TX_PAYLOAD_BYTES>
        POS             1       // proof of storage
        TODO-SIGNATURE
    LOOP END
LOOP END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
- BLOCK_HASH
    - merkle tree of all TX_HASH
    - no costs to generate
- TX_HASH
    - univocally identifies a specific PAYLOAD sent to a specific CHAIN
    - back pointers all the way back to GENESIS_HASH
- GENESIS_HASH
    - univocally identifies a chain
    - hash[CHAIN_ZEROS, CHAIN_LEN, CHAIN_KEY]
- TX_HASH uses recent TX_BACK_HASH
    - TX_HASH->...->TX_BACK_HASH < GLOBAL_TX_BACK_DISTANCE_BYTES
    - server can refuse the whole block
    - attacker wants to create a big fork
        - preprocess TXs starting from TX_HASH_0 in fork point:
            - TX_HASH_0 -> 1 -> 2 -> 3 -> 4 -> ... -> n
        - propose BLOCK with all these
            - TX_HASH_1 is not to distant from TX_HASH_0
                - because the network didn't stop
                    - and created many blocks in between 0->1
- POS = *( PTR(TX_BACK_HASH) - TX_HASH )
    - go to the address of TX_BACK_HASH
    - subtract TX_HASH
        - since TX_HASH is random
            - can end up in any address down to GENESIS
    - get the contents of the pointed memory
    - force nodes willing to publish to keep all data
        - in BTC, miners need to check funds looking all the way back
///////////////////////////////////////////////////////////////////////////////
*/

input (int, _char&& &&) OS_START;

var int        argc;
var _char&& && argv;
(argc, argv) = await OS_START;
if argc < 2 then
    _fprintf(_stderr, "Usage: %s (<src.lua>)+\n", argv[0]);
    _assert(0);
end

// load *.lua files
[[ dofile'src/common.lua' ]];
loop i in argc-1 do
    var char&& cfg = argv[i+1];
    [[
        dofile(@cfg)
    ]];
end

par/or do
    var int err = do Client;
    if err != _ERR_NONE then
        await FOREVER;
    end
with
    var char[] ip      = [[ APP.server.host[1] ]];
    var int    port    = [[ APP.server.host[2] ]];
    var int    backlog = [[ APP.server.backlog ]];
    _printf("[server] Listening in %s:%d.\n", (_char&&)&&ip, port);
    do UV_TCP_Server.build(&ip, port, backlog);
end

//_assert(0);
escape 0;
