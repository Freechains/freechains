#include "c.ceu"

#define MESSAGE_MAGIC_0 'P'
#define MESSAGE_MAGIC_1 'S'

#define HASH_BYTES      32
#define CHAIN_KEY_BYTES 128

native @pure _leading_zeros();
native do
    enum {
        ERR_NONE         =  0,
        ERR_EXTRA_BYTES  = -1,
        ERR_MESSAGE      = -2,
        ERR_DISCONNECTED = -3,
    };

    enum {
        MESSAGE10_HAVE = 1,             // [ok ACK] already has it
        MESSAGE10_PAYLOAD_LEN_LIMIT,    // [ok ACK] too big for untrusted client
        MESSAGE10_NOTSUB,               // [ok ACK] not subscribed to this chain
        MESSAGE10_POW_FAIL,             // [no ACK] block hash does not match the given PoW
        MESSAGE10_BACK_HASH_JUMP_LIMIT, // [ok ACK] TODO:
    };

    // calculate the number of leading zero bits in "bytes"
    // 00abcdef...  => 2
    int leading_zeros (byte* bytes, int len) {
        int i, j;
        int zeros = 0;
        for (i=0; i<len; i++) {             // loop over "bytes"
            byte b = bytes[i];
            for (j=0; j<8; j++) {           // loop over each bit
                if ((b & (1<<j)) != 0) {
                    return zeros;
                } else {
                    zeros++;
                }
            }
        }
        return zeros;
    }
end

#define AWAIT_UNTIL(r,nxt)          \
    if r.next < nxt then            \
        loop do                     \
            await r.ok;             \
            if r.next >= nxt then   \
                break;              \
            end                     \
        end                         \
    end

class Message with
output/input:
    var byte[] bytes;
    var byte[] offs;
do
    await FOREVER;
end

#include "uv.ceu"
#include "client.ceu"
#define UV_TCP_SERVER_HANDLER_CEU server.ceu
#include "uv-server.ceu"

/*
- MESSAGE_*:    obligatory
- BLOCK_HASH:   client will typically guess correctly
    - ok: have
---
- CHAIN_*:      .
    - ok: not sub
- PAYLOAD_LEN
    - ok: too big
---
- POW
- BACK_HASH
- PAYLOAD
    - no: no match
- TAIL_HASH
    - ok: need it
- POS
    - no: no match
===
- TODO: sig

///////////////////////////////////////////////////////////////////////////////
// client proposes message to the server
    - type of message, server checks before anything else
    - chain_*, server checks if it is subscribing to this
    - payload_len, server may not want big messages from untrusted clients
    - block_hash, server may already have it
///////////////////////////////////////////////////////////////////////////////
// identifies this message (protocol, version)
//  a server may refuse or behave differently
MESSAGE_MAGIC_0  1        // 'P'
MESSAGE_MAGIC_1  1        // 'S'
MESSAGE_MAJOR    1
MESSAGE_MINOR    1
// identifies the blockchain for this message
//  a server may not be interested in this blockchain
CHAIN_SIGNED?    1b       // message must be signed and checked
CHAIN_LEN        7b       // number of bytes for the CHAIN identifier
CHAIN_KEY        <CHAIN_LEN> // CHAIN identifier (pubkey?, topic?) (if signed, must be pubkey)
// identifies the data for this message
//  a server may already have this payload and refuse it
PAYLOAD_LEN      4 u32    // number of bytes to read next for the payload
BLOCK_HASH       32       // hash of the proposed block
///////////////////////////////////////////////////////////////////////////////
// server responds 0/1
// client completes message
///////////////////////////////////////////////////////////////////////////////
// BLOCK_HASH = hash[PoW..CHAIN_SIGNED..CHAIN_KEY..BACK_HASH..PAYLOAD]
PoW              4 u32    // nonce for BLOCK_HASH
PoS              1        // value of random jump (based on BLOCK_HASH) in the CHAIN
BACK_HASH        32       // immutable: a past hash at most TODO jumps away from BLOCK_HASH
TAIL_HASH        32       // mutable: immediate past hash which creates the chain
PAYLOAD          <PAYLOAD_LEN>
TODO-SIGNATURE
///////////////////////////////////////////////////////////////////////////////
    - BLOCK_HASH: the number of leading 0s + CHAIN_SIGNED + CHAIN_KEY 
      idenditifies the target CHAIN
    - on creation, BACK_HASH=TAIL_HASH, but nodes can change TAIL_HASH to 
      reorder the chain
    - since BLOCK_HASH uses BACK_HASH, an attacker cannot preprocess a side 
      chain and attach it to a recent node to force a fork
    - PoS = BACK_HASH - BLOCK_HASH(mapped to full memory from BACK_HASH to 
      genesis)
        - force nodes willing to publish to keep all data
            - in BTC, miners need to check funds looking all the way back
///////////////////////////////////////////////////////////////////////////////
*/

input (int, _char&& &&) OS_START;

var int        argc;
var _char&& && argv;
(argc, argv) = await OS_START;
if argc < 2 then
    _fprintf(_stderr, "Usage: %s (<src.lua>)+\n", argv[0]);
    _assert(0);
end

// load *.lua files
[[ dofile'src/common.lua' ]];
loop i in argc-1 do
    var char&& cfg = argv[i+1];
    [[
        dofile(@cfg)
    ]];
end

par/or do
    do Client;
    //await FOREVER;
with
    var char[] ip      = [[ APP.server.host[1] ]];
    var int    port    = [[ APP.server.host[2] ]];
    var int    backlog = [[ APP.server.backlog ]];
    _printf("[server] Listening in %s:%d.\n", (_char&&)&&ip, port);
    do UV_TCP_Server.build(&ip, port, backlog);
end

//_assert(0);
escape 0;
