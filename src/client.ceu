#ifndef _CLIENT_CEU
#define _CLIENT_CEU

code/await Send_10 (var& UV_Stream tcp) -> none
    // [[ ARGS = { chain={...} } ]]
    throws Exception.Uv, Exception.Freechains.Malformed
do
    [[
        THIS = {
            chain = ARGS.chain,
        }
    ]]

    ///////////////////////////////////////////////////////////////////////////
    // HEADER
    ///////////////////////////////////////////////////////////////////////////

    // <= MESSAGE
    // <= CHAIN_KEY_LEN
    // <= CHAIN_KEY_STR
    // <= CHAIN_ZEROS
    do
        tcp.buffer = [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, 0x01, 0x00];
        var u8     key_len = [[ string.len(THIS.chain.key) ]];
        var[] byte key_str = [] .. [[ THIS.chain.key ]];
        var u8     zeros   = [[ THIS.chain.zeros ]];
        _ceu_assert(key_len<CHAIN_KEY_BYTES, "bug found");
        tcp.buffer = tcp.buffer .. [key_len as byte] .. key_str .. [zeros as byte];
        await UV_Stream_Write_N(&tcp,_);
    end

    ///////////////////////////////////////////////////////////////////////////
    // BLOCKS
    ///////////////////////////////////////////////////////////////////////////

    // TODO: PoS: before/after each block? once per block?
    [[
        THIS.toask = { THIS.chain.head }
        THIS.asked = { }
        THIS.togo  = { }
    ]]

    code/await Go (none) -> none
        throws Exception.Uv
    do
        [[ THIS = { togo=ARGS.togo } ]];
        loop do
            [[
                THIS.cur = THIS.togo[#THIS.togo]
            ]]
            var bool has = [[ THIS.cur~=nil ]];
            if not has then
                outer.tcp.buffer = [0];
                await UV_Stream_Write_N(&outer.tcp,_);
                escape;
            end

            var bool is_ready = [[ #THIS.cur == THIS.togo[THIS.cur] ]];
            if is_ready then
                [[
                    table.remove(THIS.togo)
                ]]
            else
                [[
                    THIS.togo[THIS.cur] = THIS.togo[THIS.cur] + 1
                ]]
                outer.tcp.buffer = [0];
                await UV_Stream_Write_N(&outer.tcp,_);
                escape;
            end

            outer.tcp.buffer = [1];
            await UV_Stream_Write_N(&outer.tcp,_);

            // <= BLOCK_HASH
            // <= TIMESTAMP + NONCE
            // <= TP: 0=join, 1=pub, 2=removed
            // <= JOIN
            // <=   BLOCK[1].hash
            // <=   BLOCK[2].hash
            // <= PUB
            // <=   BLOCK[1].hash
            // <=   PUB_HASH?
            // =>   PUB_HASH ACK!
            // <=   PUB
            // <=       TIMESTAMP + NONCE
            // <=       LEN
            // <=       PAYLOAD
            // <= REMOVED
            // <=   BLOCK[1].hash
            do
                var[] byte str = [] .. [[ FC.tostring(THIS.cur.hash) ]] .. [0];
                _dbg_tcp(3, &&outer.tcp.handle, "client", "<= BLOCK_HASH : %s", &&str[0]);
                outer.tcp.buffer = [] .. [[ THIS.cur.hash ]]
                                      ..  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
                do
                    var u64 timestamp = [[ THIS.cur.timestamp ]];
                    var u64 nonce     = [[ THIS.cur.nonce     ]];
                    PUT_HTOBE64(outer.tcp.buffer, HASH_BYTES, timestamp);
                    PUT_HTOBE64(outer.tcp.buffer, HASH_BYTES+sizeof(u64), nonce);
                end

                var bool is_join = [[ THIS.cur.tp=='join' ]];
                if is_join then
                    outer.tcp.buffer = outer.tcp.buffer .. [ {NODE_JOIN} ];
                    outer.tcp.buffer = outer.tcp.buffer .. [[ THIS.cur[1].hash ]];
                    outer.tcp.buffer = outer.tcp.buffer .. [[ THIS.cur[2].hash ]];
                else
                    outer.tcp.buffer = outer.tcp.buffer .. [ {NODE_PUB} ];

                    // <= BLOCK[1].hash
                    var[] byte str = [] .. [[ FC.tostring(THIS.cur[1].hash) ]] .. [0];
                    _dbg_tcp(3, &&outer.tcp.handle, "client", "<= BLOCK_HASH[1] : %s", &&str[0]);
                    outer.tcp.buffer = outer.tcp.buffer .. [[ THIS.cur[1].hash ]];

                    // <= PUB
                    do
                        // <= PUB_HASH?
                        outer.tcp.buffer = outer.tcp.buffer .. [[ THIS.cur.pub.hash ]];
                        await UV_Stream_Write_N(&outer.tcp,_);

                        // => PUB_HASH_ACK!
                        await UV_Stream_Read_N(&outer.tcp, 1);
                        var int ret = outer.tcp.buffer[0];
                        $outer.tcp.buffer = $outer.tcp.buffer - 1;
                        if ret == {MESSAGE10_HAVE} then
                            continue;
                        end

                        // <= PUB: TIMESTAMP+NONCE+LEN+PAYLOAD
                        do
                            outer.tcp.buffer = [] .. [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                                                  .. [0,0,0,0]
                                                  .. [[ THIS.cur.pub.payload ]];

                            var u64 timestamp   = [[ THIS.cur.pub.timestamp           ]];
                            var u64 nonce       = [[ THIS.cur.pub.nonce               ]];
                            var u32 payload_len = [[ string.len(THIS.cur.pub.payload) ]];
                            PUT_HTOBE64(outer.tcp.buffer, 0, timestamp);
                            PUT_HTOBE64(outer.tcp.buffer, sizeof(u64), nonce);
                            PUT_HTOBE32(outer.tcp.buffer, 2*sizeof(u64), payload_len);
                            await UV_Stream_Write_N(&outer.tcp,_);
                        end
                    end
                end
            end
        end
    end

    loop do
        var bool has_ask = [[ #THIS.toask > 0 ]];
        if not has_ask then
            tcp.buffer = [0];
            await UV_Stream_Write_N(&tcp,_);
            break;
        end

        [[
            THIS.cur = table.remove(THIS.toask)
            THIS.asked[THIS.cur] = true
        ]]

        // <= HASH
        tcp.buffer = [1] .. [[ THIS.cur.hash ]];
        await UV_Stream_Write_N(&tcp,_);

        // => ACK-HASH
        await UV_Stream_Read_N(&tcp, 1);
        var byte ret = tcp.buffer[0];
        $tcp.buffer = $tcp.buffer - 1;
        if ret == {MESSAGE10_HAVE} then
            [[ ARGS = { togo=THIS.togo } ]];
            await Go();
        else/if ret == {MESSAGE10_OK} then
            [[
                THIS.togo[#THIS.togo+1] = THIS.cur
                THIS.togo[THIS.cur] = 1
                for _, a in ipairs(THIS.cur) do
                    if not THIS.asked[a] then
                        THIS.toask[#THIS.toask+1] = a
                    end
                end
            ]]
        else/if ret == {MESSAGE10_NOTSUB} then
            escape;     // possible in the first ACK
        else
            var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
            throw e;
        end
    end
end

code/await Peer_10 (var& UV_TCP_Server_Data shared) -> none
    // [[ ARGS = { peer={...}, chain={...} } ]]
do
    [[
        THIS = {
            peer  = ARGS.peer,
            chain = ARGS.chain,
        }
    ]];

{CLIENTS_ALIVE++;}
do finalize with
    {CLIENTS_ALIVE--;}
end

    var[] byte ip   = [] .. [[ THIS.peer.address ]] .. [0];
    var   int  port = [[ THIS.peer.port ]];
    _dbg(2, "client:%p | connecting to %s:%d", {&_ceu_mem}, &&ip[0], port);

    var Exception.Uv? e1;
    var Exception.Freechains? e2;
    catch e1,e2 do
        var& UV_TCP_Connect c = spawn UV_TCP_Connect(&&ip[0], port, _);

        do finalize with
            _dbg(2, "client:%p | disconnected from %s:%d", {&_ceu_mem}, &&ip[0], port);
        end

        await c.ok;
        _dbg(2, "client:%p | connected to %s:%d", {&_ceu_mem}, &&ip[0], port);

        [[ ARGS = THIS ]]

        await Send_10(&c.stream);
#ifndef NO_PIGGYBACK
        await UV_Stream_Read_N(&c.stream, MESSAGE_BYTES);
        $c.stream.buffer = $c.stream.buffer - MESSAGE_BYTES;
        await Recv_10(&shared, &c.stream);
#endif
    end
    if e1? then
        _dbg(3, "client:%p | %s", {&_ceu_mem}, e1!.message);
    else/if e2? then
        _dbg(3, "client:%p | %s", {&_ceu_mem}, e2!.message);
    end
end

code/await Client_10 (var& UV_TCP_Server_Data shared) -> none
    throws Exception.Freechains
    // [[ ARGS = { chain={...} } ]]
do
    [[
        THIS = {
            chain = ARGS.chain,
            peers = CFG.chains[ARGS.chain.key].peers
        }
    ]];

    var int ps = [[ (THIS.peers and #THIS.peers) or 0 ]];
    var int i;
    pool[] Peer_10 peers;
    loop i in [1 -> ps] do
        var bool min_zeros = [[ THIS.chain.zeros >= (THIS.peers[@i].zeros or 0) ]];
        if min_zeros then
            [[
                ARGS = {
                    peer  = THIS.peers[@i],
                    chain = THIS.chain,
                }
            ]]
            var&? Peer_10 p = spawn Peer_10(&shared) in peers;
            _ceu_assert(p?, "bug found");
        end
    end
    var[] byte id = [] .. [[ THIS.chain.id ]] .. [0];
    _dbg(3, "client:%p | broadcasting %s messages to (max) %d peer(s)", {&_ceu_mem}, &&id[0], ps);
    do finalize with
        _dbg(3, "client:%p | broadcasts OK", {&_ceu_mem});
    end

    var&? Peer_10 p;
    loop p in peers do
        await p;
        //_dbg(0, "client:%p | peer %d", {&_ceu_mem}, err);
    end
end

code/await Client (var& UV_TCP_Server_Data shared) -> none
    // [[ ARGS = { message={...} } ]]
    throws Exception.Freechains
do
    // client mode: terminates

    [[
        chain = ARGS.message.chain
        chain = assert(FC.chains[chain.key][chain.zeros], 'not subscribed to |'..chain.key..'|'..chain.zeros..'|')

        if CFG.deterministic then
            now = 0
        else
            now = os.time() * 1000000   -- in ms since the epoch
        end

        THIS = {
            now = now,
            pub = {
                chain     = chain,
                timestamp = ARGS.message.timestamp or now,
                nonce     = ARGS.message.nonce or 0,
                payload   = ARGS.message.payload,
                removal   = ARGS.message.removal and assert(FC.chain_block_get(chain, ARGS.message.removal)),
                hash      = nil,
            },
        }
        ARGS = THIS
    ]]
    await Publication_New();
    [[
        if THIS.pub.removal then
            THIS.pub.removal.pub = nil
        end
    ]]
    do
        [[ ARGS = { chain=THIS.pub.chain } ]]
        CHAIN_LOCK(l, shared, "lock_write");
        [[
            THIS.block = FC.pub { FC.chains[''][0].head,
                timestamp = THIS.now,
                nonce     = 0,
                pub       = THIS.pub,
            }
            FC.chains[''][0].head = THIS.block

            ARGS = THIS
        ]]
        await Block_Hash();
    end
    par/and do
        loop do
            await shared.chain_has_been_transmitted;
            var bool same = [[ ARGS.chain == THIS.block.chain ]];
            if same then
                break;
            end
        end
    with
        [[ ARGS = { chain=THIS.block.chain } ]];
        emit shared.chain_has_changed;
    end
end

#endif
