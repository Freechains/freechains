#ifndef _CLIENT_CEU
#define _CLIENT_CEU

#if 0
class Message10_tx_send with
    var _uv_tcp_t& tcp;
    var int        i;
    function (_uv_tcp_t& tcp, int i)=>Message10_tx_send run;
do
    function (_uv_tcp_t& tcp, int i)=>Message10_tx_send run do
        this.tcp = &tcp;
        this.i   = i;
    end

    // <= TX_HASH
    // <= TX_LEN
    do
        [[
            tx_hash   = G(tcp).block.txs[@this.i+1]
            G(tcp).tx = assert(APP.txs[tx_hash])
            --print('[client] <= txs['..(@this.i+1)..']', string.len(G(tcp).tx.payload))
            --print(tostring2(G(tcp).tx.hash))
        ]];
        var u32    payload_bytes = [[ string.len(G(tcp).tx.payload) ]];
        var char[] bytes         = [[ G(tcp).tx.hash ]];
        PUT_NETWORK_U32(bytes, HASH_BYTES, payload_bytes);
        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

        // => ACK-tx
        do
            var byte[1] recv;
            var UV_Stream_Read reader =
                    UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
            do UV_Stream_ReadUntil.run(&reader, 1);
            var int err = recv[0];

            //_printf("[client] => ACK-tx = %d\n", err);
            if err == _MESSAGE10_HAVE then
                escape _ERR_NONE;   // next TX (not an error)
            end
        end
    end

    // OK: complete TX
    //_printf("[client] <= complete...\n");
    do
        var byte[] bytes;

        // <= NONCE
        do
            var char[] nonce = [[ G(tcp).tx.nonce ]];
            bytes = []..bytes..nonce;
            //_printf("[client] <= TIMESTAMP = %X\n", timestamp);
        end

        // <= TX_BACK_HASH
        var char[HASH_BYTES] tx_back_hash = [[ G(tcp).tx.back_hash ]];
        bytes = []..bytes..tx_back_hash;
        [[
            --print('[client] <= TX_BACK_HASH')
            --print(tostring2(G(tcp).tx.back_hash))
        ]]

        // <= TX_PAYLOAD
        var char[] tx_payload = [[ G(tcp).tx.payload ]];
        bytes = []..bytes..tx_payload;

        // <= PoS: TODO
        var u8 pos = 0xEE;
        bytes = []..bytes..[pos];
        //_printf("TODO: POS generate!\n");

        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);
    end

    escape _ERR_NONE;
end

class Message10_send with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>Message10_send run;
do
    function (_uv_tcp_t& tcp)=>Message10_send run do
        this.tcp = &tcp;
    end

    ///////////////////////////////////////////////////////////////////////////
    // HEADER
    ///////////////////////////////////////////////////////////////////////////

    // <= MESSAGE
    // <= CHAIN_LEN
    // <= CHAIN_KEY
    // <= CHAIN_ZEROS
    // TODO: <= CHAIN_LIMITS
    do
        // <= MESSAGE
        var byte[] bytes = [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, 1, 0];

        // <= CHAIN_LEN
        // <= CHAIN_KEY
        // <= CHAIN_ZEROS
        do
            [[ chain = APP.chains[G(tcp).block.chain_id] ]];
            var char[] chain_key   = [[ chain.key ]];
            var int    chain_zeros = [[ chain.zeros ]];
            var u32    chain_len   = [[ string.len(chain.key) ]];
            _ceu_dbg_assert(chain_len<CHAIN_KEY_BYTES);
            bytes = []..bytes..[chain_zeros,(u8)chain_len]..chain_key;
        end

        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

        // => ACK-header
        do
            var byte[1] recv;
            var UV_Stream_Read reader =
                    UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
            do UV_Stream_ReadUntil.run(&reader, 1);
            var int ret = recv[0];

            _dbg_tcp(0, &&this.tcp, "client", "=> ACK-header = %d", ret);

            if ret == _MESSAGE10_NOTSUB then
                escape ret;
            else
                // OK: proceed to BLOCKS
            end
        end
    end

    ///////////////////////////////////////////////////////////////////////////
    // BLOCKS
    ///////////////////////////////////////////////////////////////////////////
    loop i do
        // <= BLOCK_HASH
        // <= BLOCK_TXS_N
        do
            var byte[] bytes;

            // <= BLOCK_HASH
            var char[HASH_BYTES] block_hash = [[ G(tcp).block.hash ]];
            bytes = []..bytes..block_hash;
            var char[] str = [[ tostring2(G(tcp).block.hash) ]];
            _dbg_tcp(0, &&this.tcp, "client", "<= BLOCKS[%d] : %s", i, (_char&&)&&str);

            // <= BLOCK_TXS_N
            var u32 txs_n = [[ #G(tcp).block.txs ]];
            PUT_NETWORK_U32(bytes, $bytes, txs_n);

            do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);
        end

        // => ACK-block
        do
            var byte[1] recv;
            var UV_Stream_Read reader =
                    UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
            do UV_Stream_ReadUntil.run(&reader, 1);
            var int ret = recv[0];

            _dbg_tcp(0, &&this.tcp, "client", "=> ACK-block = %d", ret);

            if ret == _MESSAGE10_HAVE then
                break;  // found common block
            end
        end

        ///////////////////////////////////////////////////////////////////////
        // TXS
        ///////////////////////////////////////////////////////////////////////
        var u32 txs_n = [[ #G(tcp).block.txs ]];
        _dbg_tcp(0, &&tcp, "client", "<= %d txs", txs_n);
        loop j in txs_n do
            var int err = do Message10_tx_send.run(&tcp,j);
            if err != _ERR_NONE then
                escape err;
            end
        end

        // next block
        var bool has = [[ G(tcp).block.tail_hash ~= nil ]];
        if not has then
            escape _ERR_REMOTE_BUG_OR_MALICIOUS; // "genesis" always HAVE
        end
        [[ G(tcp).block = assert(APP.blocks[G(tcp).block.tail_hash]) ]];
    end

    escape _ERR_NONE;
end

interface PeerListener with
    event int ok;
end
#endif

code/await PeerSend (event& int ok) => int
    // [[ ARGS = { peer=?, block=? } ]]
do
_CLIENTS_ALIVE = _CLIENTS_ALIVE + 1;
do finalize with
    _CLIENTS_ALIVE = _CLIENTS_ALIVE - 1;
end

    var int this = 0;
    vector[] byte ip   = []..[[ ARGS.peer.host[1] ]];
    var      int  port = [[ ARGS.peer.host[2] ]];
    _dbg(2, "client:%p | connecting to %s:%d", &&this, &&ip[0], port);

    var int err1 = do/err1
        var& _uv_tcp_t tcp;
        event& void ok_connected;

        var int? err2 =
            watching UV_TCP_Connect(&&ip[0], port) => (tcp, ok_connected) do
                await ok_connected;
                _dbg(2, "client:%p | connected to %s:%d", &&this, &&ip[0], port);

                [[
                    G(tcp) = {
                        block = ARGS.block,
                    }
                ]];
                var bool is_10 = [[ G(tcp).block~=nil and G(tcp).block.id=='1.0' ]];
                _ceu_dbg_assert(is_10 as int);

                var int err3 = 0;//await Message10_send(&tcp);
                escape/err1 err3;
            end;
        escape/err1 err2!;
    end;

    _dbg(2, "client:%p | disconnected from %s:%d", &&this, &&ip[0], port);
    if err1 != _ERR_NONE then
#ifdef DBG
        _dbg(3, "client:%p | %s", &&this, _uv_strerror(err1));
#endif
#ifdef FREECHAINS_NO_MALICIOUS
        _ceu_dbg_assert(0);
#endif
    end

    emit ok(err1);
    escape err1;
end

code/await Client (void) => int
    //interface PeerListener;
    // [[ ARGS = { chain_id=? } ]]
do
    var int this = 0;
    event int ok;

    [[
        chain = assert(APP.chains[ARGS.chain_id])
        G(this) = {
            to_awake = ARGS.to_awake,
            chain_id = ARGS.chain_id,
            block    = assert(APP.blocks[chain.head_hash]),
            chain    = chain,
        }
    ]]

#ifdef CLIENT_LOCK
    // LOCK: only one "send" per chain
    do
        var bool is_locked = [[ G(this).chain.send_is_locked ]];
        if is_locked then
            loop do
                par/or do
                    await global:send_chain_unlocked;
                with
                    await 1s;
                end
                is_locked = [[ G(this).chain.send_is_locked ]];
                if not is_locked then
                    break;
                end
            end
        end
        [[ G(this).chain.send_is_locked = true ]];
    end

// TODO: primitive "lock"
do

    finalize with
        //var bool is_locked = [[ G(this).chain.send_is_locked ]];
        //_ceu_dbg_assert(not is_locked);
        [[ G(this).chain.send_is_locked = false ]];
    end
#endif

    pool[] PeerSend ps;
    var int ps_n = [[#APP.client.peers]];
    var int ps_ok = 0;
    loop i in [1 -> ps_n] do
        [[
            peer = APP.client.peers[@i]
            ok = false
            for _, chain in pairs(peer.chains) do
                if chain.key==G(this).chain.key and
                   chain.zeros<=G(this).chain.zeros then
                    ok = true
                    break
                end
            end
        ]];
        var bool ok_ = [[ ok ]];
        if ok_ then
            ps_ok = ps_ok + 1;
            [[
                ARGS = {
                    peer  = peer,
                    --block = G(this).block,
                    block = APP.blocks[G(this).chain.head_hash],
                }
            ]];
            var bool p = spawn PeerSend(&ok) in ps;
            _ceu_dbg_assert(p as int);
        end
    end
    _dbg(0, "client:%p | broadcasting messages to %d peer(s)", &&this, ps_ok);
    loop i in [1 -> ps_ok] do
        var int err = await ok;
        _dbg(0, "client:%p | peer %d", &&this, err);
    end
    _dbg(0, "client:%p | broadcasts OK", &&this);

#ifdef CLIENT_LOCK
    // UNLOCK "send"
    [[ G(this).chain.send_is_locked = false ]];  // TODO: remove?
end
    emit global:send_chain_unlocked;
#endif

    escape _ERR_NONE;   // trasmitted messages
end

code/await ClientMessages (void) => int
do
    var int this = 0;
    var int ms = [[ #APP.messages ]];
    if ms == 0 then
        await FOREVER;  // server mode: don't let application terminate
    end

    // client mode: terminates

    [[
        -- id = 1.0
        block = {
            id        = nil,
            chain_id  = nil,
            txs       = { },
            hash      = nil,
            up_hash   = nil,
            tail_hash = nil,
        }
    ]]
    do finalize with
        [[ APP.messages = {} ]];
    end

    var bool is_10 = [[ APP.messages[1].id=='1.0' ]];

    loop i in [1 -> ms] do
        [[
            msg = APP.messages[@i]
            assert(type(msg)=='table')
            assert(msg.id == APP.messages[1].id)    -- all must be the same
        ]];

        if is_10 then
            [[
                block.id = '1.0'

                assert(type(msg.chain)=='table')

                chain = assert( GG.chain_parse_get(msg.chain) )
                if (@i) == 1 then
                    block.chain_id = chain.id
                else
                    assert(chain.id == block.chain_id)
                end

                head_hash = chain.head_hash
                txs_back  = APP.blocks[head_hash].txs

                block.txs[#block.txs+1] = {
                    nonce     = nil,
                    back_hash = txs_back[#txs_back],
                    payload   = msg.payload,
                }
            ]];
        end
    end

    if is_10 then
        [[ ARGS = { block=block } ]];
        var int ret = await BlockHash(BlockHashSource.New());
                        // returns [[ ARGS = { block=block } ]];
        _ceu_dbg_assert(ret == _ERR_NONE);
        [[
            block = ARGS.block
            chain = APP.chains[block.chain_id]

            -- last thing of BlockHash, no await in between
            assert(block.tail_hash == chain.head_hash)

            APP.blocks[chain.head_hash].up_hash = block.hash
            chain.head_hash = block.hash

            ARGS = {
                app      = APP,
                to_awake = { [@(&&this)]=true },
                chain_id = ARGS.block.chain_id,
            }
        ]];

        await Client();
    else
        _ceu_dbg_assert(0);  // message not supported
    end

    escape _ERR_NONE;
end

#endif
