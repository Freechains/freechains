#ifndef _CLIENT_CEU
#define _CLIENT_CEU

code/await Message10_tx_send (var& UV_Stream tcp, var u32 i) -> none
    throws Exception.Lua, Exception.Uv
do
    // <= TX_HASH
    // <= TX_LEN
    do/_
        [[
            tx_hash   = G(tcp).block.txs[@i+1]
            G(tcp).tx = assert(APP.txs[tx_hash])
            --print('[client] <= txs['..(@i+1)..']', string.len(G(tcp).tx.payload))
            --print(tostring2(G(tcp).tx.hash))
        ]];
        var u32 payload_bytes = [[ string.len(G(tcp).tx.payload) ]];
        tcp.buffer = [] .. [[ G(tcp).tx.hash ]];
        _ceu_vector_setlen(&&tcp.buffer, $tcp.buffer+sizeof(u32), 1);
        PUT_NETWORK_U32(tcp.buffer, HASH_BYTES, payload_bytes);
        await UV_Stream_Write_N(&tcp,_);

        // => ACK-tx
        do/_
            await UV_Stream_Read_N(&tcp, 1);
            var byte err = tcp.buffer[0];
            $tcp.buffer = $tcp.buffer - 1;

            //_printf("[client] => ACK-tx = %d\n", err);
            if err == {MESSAGE10_HAVE} then
                escape;
            end
        end
    end

    // OK: complete TX
    //_printf("[client] <= complete...\n");
    do
        // <= NONCE
        do
            tcp.buffer = [] .. [[ G(tcp).tx.nonce ]];
            //_printf("[client] <= TIMESTAMP = %X\n", timestamp);
        end

        // <= TX_BACK_HASH
        tcp.buffer = tcp.buffer .. [[ G(tcp).tx.back_hash ]];
        [[
            --print('[client] <= TX_BACK_HASH')
            --print(tostring2(G(tcp).tx.back_hash))
        ]]

        // <= TX_PAYLOAD
        tcp.buffer = tcp.buffer .. [[ G(tcp).tx.payload ]];

        // <= PoS: TODO
        var byte pos_ = 0xEE;
        tcp.buffer = tcp.buffer .. [pos_];
        //_printf("TODO: POS generate!\n");

        await UV_Stream_Write_N(&tcp,_);
    end
end

code/await Message10_send (var& UV_Stream tcp) -> none
    throws Exception.Lua, Exception.Uv, Exception.Freechains.Malformed
do
    ///////////////////////////////////////////////////////////////////////////
    // HEADER
    ///////////////////////////////////////////////////////////////////////////

    // <= MESSAGE
    // <= CHAIN_LEN
    // <= CHAIN_KEY
    // <= CHAIN_ZEROS
    // TODO: <= CHAIN_LIMITS
    do/_
        // <= MESSAGE
        tcp.buffer = [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, 1, 0];

        // <= CHAIN_LEN
        // <= CHAIN_KEY
        // <= CHAIN_ZEROS
        do
            [[ chain = APP.chains[G(tcp).block.chain_id] ]];
            var[] byte chain_key   = [] .. [[ chain.key ]];
            var int    chain_zeros = [[ chain.zeros ]];
            var u32    chain_len   = [[ string.len(chain.key) ]];
            _ceu_assert(chain_len<CHAIN_KEY_BYTES, "bug found");
            tcp.buffer = tcp.buffer .. [chain_zeros, chain_len as byte] .. chain_key;
        end

        await UV_Stream_Write_N(&tcp,_);

        // => ACK-header
        do/_
            await UV_Stream_Read_N(&tcp, 1);
            var byte ret = tcp.buffer[0];
            $tcp.buffer = $tcp.buffer - 1;

            _dbg_tcp(0, &&tcp.handle, "client", "=> ACK-header = %d", ret);

            if ret == {MESSAGE10_NOTSUB} then
                escape;
            else
                // OK: proceed to BLOCKS
            end
        end
    end

    ///////////////////////////////////////////////////////////////////////////
    // BLOCKS
    ///////////////////////////////////////////////////////////////////////////
    var int i;
    loop i do
        // <= BLOCK_HASH
        // <= BLOCK_TXS_N
        do
            // <= BLOCK_HASH
            tcp.buffer = [] .. [[ G(tcp).block.hash ]];
            do
                var[] byte str = [] .. [[ tostring2(G(tcp).block.hash) ]] .. [0];
                _dbg_tcp(0, &&tcp.handle, "client", "<= BLOCKS[%d] : %s", i, &&str[0]);
            end

            // <= BLOCK_TXS_N
            var u32 txs_n = [[ #G(tcp).block.txs ]];
            _ceu_vector_setlen(&&tcp.buffer, $tcp.buffer+sizeof(u32), 1);
            PUT_NETWORK_U32(tcp.buffer, HASH_BYTES, txs_n);

            await UV_Stream_Write_N(&tcp, _);
        end

        // => ACK-block
        do
            await UV_Stream_Read_N(&tcp, 1);
            var byte ret = tcp.buffer[0];
            $tcp.buffer = $tcp.buffer - 1;

            _dbg_tcp(0, &&tcp.handle, "client", "=> ACK-block = %d", ret);

            if ret == {MESSAGE10_HAVE} then
                break;  // found common block
            end
        end

        ///////////////////////////////////////////////////////////////////////
        // TXS
        ///////////////////////////////////////////////////////////////////////
        var u32 txs_n = [[ #G(tcp).block.txs ]];
        _dbg_tcp(0, &&tcp.handle, "client", "<= %d txs", txs_n);
        var u32 j;
        loop j in [0 -> txs_n[ do
            await Message10_tx_send(&tcp,j);
        end

        // next block
        var bool has = [[ G(tcp).block.tail_hash ~= nil ]];
        if not has then
            var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
            throw e;
        end
        [[ G(tcp).block = assert(APP.blocks[G(tcp).block.tail_hash]) ]];
    end
end

code/await PeerSend (none) -> none
    throws Exception.Lua
    // [[ ARGS = { peer=?, block=? } ]]
do

{CLIENTS_ALIVE++;}
do finalize with
    {CLIENTS_ALIVE--;}
end

    var[] byte ip   = [] .. [[ ARGS.peer.host[1] ]] .. [0];
    var   int  port = [[ ARGS.peer.host[2] ]];
    _dbg(2, "client:%p | connecting to %s:%d", {&_ceu_mem}, &&ip[0], port);

    var Exception? e;
    catch e do
        var& UV_TCP_Connect c = spawn UV_TCP_Connect(&&ip[0], port, _);

        [[
            G(c.stream) = {
                block = ARGS.block,
            }
        ]];

        var bool is_10 = [[ G(c.stream).block~=nil and G(c.stream).block.id=='1.0' ]];
        // ...

        do finalize with
            _dbg(2, "client:%p | disconnected from %s:%d", {&_ceu_mem}, &&ip[0], port);
        end

        await c.ok;
        _dbg(2, "client:%p | connected to %s:%d", {&_ceu_mem}, &&ip[0], port);
        if is_10 then
            await Message10_send(&c.stream);
        else
            var Exception.Freechains.Unsupported e = val Exception.Freechains.Unsupported(_);
            throw e;
        end
        escape;
    end
    _dbg(3, "client:%p | %s", {&_ceu_mem}, e!.message);
end

code/await Client (var& UV_TCP_Server_Data shared) -> none
    throws Exception.Lua
    // [[ ARGS = { chain=?, block=? } ]]
do
    [[ THIS = ARGS ]];

    // LOCK: only one "send" per chain
    var bool is_locked = [[ THIS.chain.send_is_locked ]];
    if is_locked then
        loop do
            par/or do
                await shared.unlock;
            with
                await 1s;
            end
            is_locked = [[ THIS.chain.send_is_locked ]];
            if not is_locked then
                break;
            end
        end
    end

    do finalize with
        [[ THIS.chain.send_is_locked = false ]];
        emit shared.unlock;
    end

    var int ps = [[#APP.client.peers]];
    var int ps_ok = 0;
    var int i;
    pool[] PeerSend peers;
    loop i in [0 -> ps[ do
        [[
            peer = APP.client.peers[@(i+1)]
            ok = false
            for _, chain in pairs(peer.chains) do
                if chain.key==THIS.chain.key and
                   chain.zeros<=THIS.chain.zeros then
                    ok = true
                    break
                end
            end
        ]];
        var bool ok_ = [[ ok ]];
        if ok_ then
            ps_ok = ps_ok + 1;
            [[
                ARGS = {
                    peer  = peer,
                    --block = THIS.block,
                    block = APP.blocks[THIS.chain.head_hash],
                }
            ]];
            var&? PeerSend p = spawn PeerSend() in peers;
            _ceu_assert(p?, "bug found");
        end
    end
    _dbg(0, "client:%p | broadcasting messages to %d peer(s)", {&_ceu_mem}, ps_ok);
    var&? PeerSend p;
    loop p in peers do
        await p;
        //_dbg(0, "client:%p | peer %d", {&_ceu_mem}, err);
    end
    _dbg(0, "client:%p | broadcasts OK", {&_ceu_mem});
end

code/await ClientMessages (var& UV_TCP_Server_Data shared) -> none
    throws Exception.Lua, Exception.Freechains.Unsupported
do
    var int ms = [[ #APP.messages ]];
    _ceu_assert(ms > 0, "no messages to client");

    // client mode: terminates

    [[
        -- id = 1.0
        block = {
            id        = nil,
            chain_id  = nil,
            txs       = { },
            hash      = nil,
            up_hash   = nil,
            tail_hash = nil,
        }
    ]]
    do finalize with
        [[ APP.messages = {} ]];
    end

    var bool is_10 = [[ APP.messages[1].id=='1.0' ]];

    var int i;
    loop i in [0 -> ms[ do
        [[
            msg = APP.messages[@i+1]
            assert(type(msg)=='table')
            assert(msg.id == APP.messages[1].id)    -- all must be the same
        ]];

        if is_10 then
            [[
                block.id = '1.0'

                assert(type(msg.chain)=='table')

                chain = assert( GG.chain_parse_get(msg.chain) )
                if (@i) == 0 then
                    block.chain_id = chain.id
                else
                    assert(chain.id == block.chain_id)
                end

                head_hash = chain.head_hash
                txs_back  = APP.blocks[head_hash].txs

                block.txs[#block.txs+1] = {
                    nonce     = nil,
                    back_hash = txs_back[#txs_back],
                    payload   = msg.payload,
                }
            ]];
        end
    end

    if is_10 then
        [[ ARGS = { block=block } ]];
        await BlockHash(SourceBlockHash.New());
              // returns [[ ARGS = { block=block } ]];
        [[
            block = ARGS.block
            chain = APP.chains[block.chain_id]

            -- last thing of BlockHash, no await in between
            assert(block.tail_hash == chain.head_hash)

            APP.blocks[chain.head_hash].up_hash = block.hash
            chain.head_hash = block.hash

            local chain = assert(APP.chains[ARGS.block.chain_id])
            ARGS = {
                block = assert(APP.blocks[chain.head_hash]),
                chain = chain,
            }
            THIS = ARGS
        ]];
        await Client(&shared);
        [[ ARGS = THIS ]]
        emit shared.ok({MESSAGE10}, false, {MESSAGE10_OK});
    else
        var Exception.Freechains.Unsupported e = val Exception.Freechains.Unsupported(_);
        throw e;
    end
end

#endif
