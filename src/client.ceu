#ifndef _CLIENT_CEU
#define _CLIENT_CEU

code/await Send_10 (var& UV_Stream tcp) -> none
    // [[ ARGS = { chain={...} } ]]
    throws Exception.Lua, Exception.Uv, Exception.Freechains.Malformed
do
    [[ THIS = ARGS ]]

    ///////////////////////////////////////////////////////////////////////////
    // HEADER
    ///////////////////////////////////////////////////////////////////////////

    // <= MESSAGE
    // <= CHAIN_KEY_LEN
    // <= CHAIN_KEY_STR
    // <= CHAIN_ZEROS
    // <= CHAIN_LENGTH
    do/_
        tcp.buffer = [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, 1, 0];

        do
            var u8     chain_zeros   = [[ THIS.chain.zeros ]];
            var[] byte chain_key_str = [] .. [[ THIS.chain.key ]];
            var u32    chain_key_len = [[ string.len(THIS.chain.key) ]];
            var u64    chain_length  = [[ THIS.chain.length ]];
            _ceu_assert(chain_len<CHAIN_KEY_BYTES, "bug found");
            tcp.buffer = tcp.buffer .. [chain_zeros, chain_key_len as byte] .. chain_key_str;
            var usize off = $tcp.buffer;
            tcp.buffer = tcp.buffer .. [0,0,0,0,0,0,0,0];
            PUT_HTOBE64(tcp.buffer, sizeof(u64), chain_length);
        end

        await UV_Stream_Write_N(&tcp,_);

        // => ACK-header
        do/_
            await UV_Stream_Read_N(&tcp, 1);
            var byte ret = tcp.buffer[0];

            _dbg_tcp(0, &&tcp.handle, "client", "=> ACK-header = %d", ret);

            if ret == {MESSAGE10_OK} then
                // OK: proceed to BLOCKS
            else/if ret=={MESSAGE10_NOTSUB} or ret=={MESSAGE10_HAVE} then
                escape;
            else
                var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
                throw e;
            end
        end
    end

    ///////////////////////////////////////////////////////////////////////////
    // BLOCKS
    // - first, sends hashes from head -> genesis until finds common block
    // - then, sends from common.nxt -> head
    ///////////////////////////////////////////////////////////////////////////

    // TODO: PoS: before/after each block? once per block?

    [[ THIS.block = THIS.chain.head ]];

    loop do
        // <= HASH
        tcp.buffer = [] .. [[ THIS.block.hash ]];
        await UV_Stream_Write_N(&tcp, _);

        // => ACK-HASH
        await UV_Stream_Read_N(&tcp, 1);
        var byte ret = tcp.buffer[0];
        if ret == {MESSAGE_HAVE} then
            break;
        else/if ret == {MESSAGE_OK} then
            // continue
        else
            var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
            throw e;
        end
        [[ THIS.block = THIS.block.prv ]];
    end

    [[ THIS.block = THIS.block.nxt ]];

    var int i;
    loop i do
        // <= BLOCK_HASH
        // <= TIMESTAMP + NONCE
        // <= PUBLICATION_HASH
        // <= PRV_HASH
        do
            tcp.buffer = [] .. [[ THIS.block.hash ]] .. 
                               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                               [[ THIS.block.publication.hash ]] ..
                               [[ THIS.block.prv.hash ]];

            var u64 timestamp = [[ THIS.block.timestamp ]];
            var u64 nonce     = [[ THIS.block.nonce     ]];
            PUT_HTOBE64(pln, 0, timestamp);
            PUT_HTOBE64(pln, sizeof(u64), nonce);

            await UV_Stream_Write_N(&tcp,_);
        end

        // => ACK-PUBLICATION-HASH
        var bool send_publication = do
            await UV_Stream_Read_N(&tcp, 1);
            var byte ret = tcp.buffer[0];
            if ret == {MESSAGE_HAVE} then
                escape false;
            else/if ret == {MESSAGE_OK} then
                escape true;
            else
                var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
                throw e;
            end
        end;
        if send_publication then
            tcp.buffer = [] .. [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                               [0,0,0,0] ..
                               [[ THIS.publication.payload ]];
            var u64 timestamp   = [[ THIS.publication.timestamp ]];
            var u64 nonce       = [[ THIS.publication.nonce     ]];
            var u32 payload_len = [[ string.len(THIS.publication.payload) ]];
            PUT_HTOBE64(pln, 0, timestamp);
            PUT_HTOBE64(pln, sizeof(u64), nonce);
            PUT_HTOBE32(pln, 2*sizeof(u64), payload_len);
            await UV_Stream_Write_N(&tcp,_);
        end

        // => ACK-BLOCK
        // TODO: good place for PoS
        do
            await UV_Stream_Read_N(&tcp, 1);
            var byte ret = tcp.buffer[0];
            $tcp.buffer = $tcp.buffer - 1;

            //_printf("[client] => ACK-tx = %d\n", ret);
            if ret != {MESSAGE10_OK} then
                var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
                throw e;
            end
        end

        [[ THIS.block = THIS.block.nxt ]];
        var bool should_stop = [[ THIS.block==nil ]]
        if should_stop then
            break;
        end
    end
end

code/await Peer_10 (none) -> none
    throws Exception.Lua
    // [[ ARGS = { peer={...}, chain={...} } ]]
do
    [[ THIS = ARGS ]];

{CLIENTS_ALIVE++;}
do finalize with
    {CLIENTS_ALIVE--;}
end

    var[] byte ip   = [] .. [[ THIS.peer.host[1] ]] .. [0];
    var   int  port = [[ THIS.peer.host[2] ]];
    _dbg(2, "client:%p | connecting to %s:%d", {&_ceu_mem}, &&ip[0], port);

    var Exception? e;
    catch e do
        var& UV_TCP_Connect c = spawn UV_TCP_Connect(&&ip[0], port, _);

        do finalize with
            _dbg(2, "client:%p | disconnected from %s:%d", {&_ceu_mem}, &&ip[0], port);
        end

        await c.ok;
        _dbg(2, "client:%p | connected to %s:%d", {&_ceu_mem}, &&ip[0], port);

        [[ ARGS = THIS ]]
        await Send_10(&c.stream);
    end
    if e? then
        _dbg(3, "client:%p | %s", {&_ceu_mem}, e!.message);
    end
end

code/await Client_10 (var& UV_TCP_Server_Data shared) -> none
    throws Exception.Lua
    // [[ ARGS = { chain={...} } ]]
do
    [[ THIS = ARGS ]];

    watching Chain_Change() do
        var int ps = [[#APP.client.peers]];
        var int ps_ok = 0;
        var int i;
        pool[] Peer_10 peers;
        loop i in [0 -> ps[ do
            [[
                peer = APP.client.peers[@(i+1)]
                ok = false
                for _, chain in pairs(peer.chains) do
                    if chain.key==THIS.chain.key and
                       chain.zeros<=THIS.chain.zeros then
                        ok = true
                        break
                    end
                end
            ]];
            var bool ok_ = [[ ok ]];
            if ok_ then
                ps_ok = ps_ok + 1;
                [[
                    ARGS = {
                        peer  = peer,
                        chain = THIS.chain,
                    }
                ]];
                var&? Peer_10 p = spawn Peer_10() in peers;
                _ceu_assert(p?, "bug found");
            end
        end
        var[] byte id = [] .. [[ THIS.chain.id ]] .. [0];
        _dbg(0, "client:%p | broadcasting %s messages to %d peer(s)", {&_ceu_mem}, &&id[0], ps_ok);
        do finalize with
            _dbg(0, "client:%p | broadcasts OK", {&_ceu_mem});
        end
        var&? Peer_10 p;
        loop p in peers do
            await p;
            //_dbg(0, "client:%p | peer %d", {&_ceu_mem}, err);
        end
    end
end

code/await ClientMessages (var& UV_TCP_Server_Data shared) -> none
    throws Exception.Lua, Exception.Freechains.Unsupported
do
    var int ms = [[ #APP.messages ]];
    _ceu_assert(ms > 0, "no messages to client");

    // client mode: terminates

    do finalize with
        [[ APP.messages = {} ]];
    end

    var int i;
    loop i in [0 -> ms[ do
        [[
            msg = APP.messages[@i+1]
            assert(type(msg)=='table')
            assert(type(msg.chain)=='table')
        ]];

        var bool is_10 = [[ APP.messages[@i+1].version=='1.0' ]];

        if is_10 then
            [[
                THIS = {}
                THIS.publication = {
                    chain     = assert(GG.chain_parse_get(msg.chain), msg.chain.id),
                    timestamp = 0,    -- TODO: 64-bit timestamp
                    nonce     = 0,
                    payload   = msg.payload,
                    hash      = nil,
                }
                ARGS = THIS
            ]]
            await Publication_New();
            loop do
                [[ ARGS = { chain=THIS.block.chain } ]]
                watching Chain_Change() do
                    [[
                        THIS.block = {
                            version = '1.0',
                            timestamp   = 0,    -- TODO: 64-bit timestamp
                            nonce       = 0,
                            chain       = THIS.publication.chain,
                            publication = THIS.publication,
                            hash        = nil,
                            prv         = THIS.publication.chain.head,
                            nxt         = nil,          
                        }
                        ARGS = THIS
                    ]]
                    await Block_New();
                    [[
                        THIS = { chain=THIS.block.chain }
                        ARGS = THIS
                    ]];
                    break;
                end
            end
            await Client_10(&shared);
            [[
                ARGS = THIS
            ]]
            emit shared.ok({MESSAGE10}, false, {MESSAGE10_OK});
        else
            var Exception.Freechains.Unsupported e = val Exception.Freechains.Unsupported(_);
            throw e;
        end
    end
end

#endif
