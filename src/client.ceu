#ifndef _CLIENT_CEU
#define _CLIENT_CEU

#include "sodium.ceu"

class Message10_send with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>Message10_send run;
do
    function (_uv_tcp_t& tcp)=>Message10_send run do
        this.tcp = &tcp;
    end

    var byte[] bytes;

    // => MESSAGE
    do
        var int major = [[ MSG.id_t.major ]];
        var int minor = [[ MSG.id_t.minor ]];
        this.bytes = []..this.bytes..
                         [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, major, minor];
    end

    // => CHAIN_ZEROS
    // => CHAIN_LEN
    // => CHAIN_KEY
    var int chain_zeros = [[ MSG.chain.zeros ]];
    var char[] chain_key;
    do
        chain_key = [[ MSG.chain.key ]];

        var u32 chain_len = [[ string.len(MSG.chain.key) ]];
        _assert(chain_len<CHAIN_KEY_BYTES);

        this.bytes = []..this.bytes..[chain_zeros,(u8)chain_len]..chain_key;
    end

    do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &this.bytes);

    //////////////////////////////////////////////////////////////////////////

    // <= ACK-chain
    var int err = _ERR_NONE;
    do
        var byte[1] recv;
        var UV_Stream_Read reader =
                UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
        do UV_Stream_ReadUntil.run(&reader, 1);
        err = recv[0];
    end

    _printf("[client] ACK-chain = %d\n", err);
    if err == _MESSAGE10_NOTSUB then
        escape err;
    end

    _assert(0);

    //////////////////////////////////////////////////////////////////////////

#if 0
    loop do
TODO
        var char[HASH_BYTES] tail_hash = [[ 
                                APP.chains[MSG.chain.key].heads[MSG.chain.zeros]
                             ]];
        [[ MSG.tail_hash = @tail_hash ]];
    end


    escape _ERR_NONE;
#endif
end

#if 0
class T with
    var Message& msg;
    function (Message& msg)=>T build;
do
    function (Message& msg)=>T build do
        this.msg = &msg;
    end

    // => PAYLOAD_LEN
    var char[] payload = [[ MSG.payload ]];
    do
        PUT_NETWORK_U32(this.msg.bytes, $this.msg.bytes, $payload);
    end

    // => BLOCK_HASH (async/thread)
    var char[HASH_BYTES] tail_hash = [[ APP.chains[MSG.chain.key].heads[MSG.chain.zeros] ]];
    var u32              nonce     = 0;
    do
        // calculate nonce for the leading zeros
        var byte[HASH_BYTES] block_hash;
        var byte[] plain =
            [ 0,0,0,0 ]     ..     // PoW nonce
            [ chain_zeros==256 ]  ..     // is signed?
            chain_key       ..
            tail_hash       ..     // BACK_HASH (immutable)
            payload         ;

        var int ms = 0;
        par/or do
            every 100ms do
                ms = ms + 100;
                _printf(".");
                _fflush(_stdout);
            end
        with
            var u8 zeros_wanted = (u8)chain_zeros;    // 256=>0
            async/thread (plain,block_hash,nonce,zeros_wanted) do
                var int zeros_found = 0;
                $block_hash := HASH_BYTES;
                loop do
                    _crypto_generichash((_byte&&)&&block_hash, HASH_BYTES,
                                        (_byte&&)&&plain, $plain,
                                        null, 0);
                    zeros_found = _leading_zeros((_byte&&)&&block_hash, $block_hash);
                    if zeros_found >= zeros_wanted then
                        break;
                    end
                    nonce = nonce + 1;
                    PUT_NETWORK_U32(plain, 0, nonce);
                end
            end
        end
        _printf("\n[client] BLOCK_HASH = %dms\n", ms);
        this.msg.bytes = []..this.msg.bytes..block_hash;
    end

    this.msg.offs = []..this.msg.offs..[$this.msg.bytes];

    //////////////////////////////////////////////////////////////////////////

    // => PoW
    do
        PUT_NETWORK_U32(this.msg.bytes, $this.msg.bytes, nonce);
    end

    // => PoS
    do
        var u8 pos = 0xEE;              // TODO
        this.msg.bytes = []..this.msg.bytes..[pos];
    end

    // => BACK_HASH (immutable, see above)
    // => TAIL_HASH (mutable in further forwards)
    do
        // TODO: on creation is not required
        this.msg.bytes = []..this.msg.bytes..tail_hash; // BACK_HASH
        this.msg.bytes = []..this.msg.bytes..tail_hash; // TAIL_HASH
    end

    // => PAYLOAD
    do
        this.msg.bytes = []..this.msg.bytes..payload;
    end

    this.msg.offs = []..this.msg.offs..[$this.msg.bytes];

    escape _ERR_NONE;
end
#endif

interface PeerListener with
    event int ok;
end

class PeerSend with
input:
    var int peer_i;
    var PeerListener& listener;

    function (int i, PeerListener& listener)=>PeerSend run;
do
    function (int i, PeerListener& listener)=>PeerSend run do
        this.peer_i   = i;
        this.listener = &listener;
    end

    var char[] ip   = [[ APP.client.peers[@this.peer_i][1] ]];
    var int    port = [[ APP.client.peers[@this.peer_i][2] ]];
    _printf("[client] Connecting to %s:%d.\n", (_char&&)&&ip, port);
    var UV_TCP_Client c = UV_TCP_Client.build(&ip, port);

    var bool is_10 = [[ MSG.id=='1.0' ]];
    // ...

    var int err =
    do
        var int err_ = await c.ok;
        if err_ != _ERR_NONE then
            escape err_;
        end

        _printf("[client] Connected to %s:%d.\n", (_char&&)&&ip, port);
        watching c do
            var int err_ = _ERR_NONE;
            if is_10 then
                err_ = do Message10_send.run(&c.tcp);
            else
                // ...
            end
            escape err_;
        end
// TODO: usar erro de c
        escape _ERR_DISCONNECTED;
    end;

    _printf("[client] Diconnected from %s:%d => %d\n", (_char&&)&&ip, port, err);
    emit listener.ok => err;
    escape err;
end

class Client with
    interface PeerListener;
do
    [[ MSG = APP.message ]];
    var bool has = [[ MSG~=nil ]];
    if not has then
        await FOREVER;
    end

    var bool is_10 = [[ MSG.id=='1.0' ]];
    _assert(is_10);  // message not supported

    _printf("[client] Broadcasting message...\n");
    var int n = [[#APP.client.peers]];
    loop i in n do
        var PeerSend&&? p = spawn PeerSend.run(i+1, &this);
        _assert(p! != null);
    end
    loop i in n do
        var int err = await this.ok;
        _printf("[client] peer %d\n", err);
    end
    _printf("[client] Broadcast OK!\n");

    escape _ERR_NONE;
end

#endif
