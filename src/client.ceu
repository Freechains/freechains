#ifndef _CLIENT_CEU
#define _CLIENT_CEU

#include "sodium.ceu"

class Message10_parse_tx with
    var int i;
    var byte[HASH_BYTES]& tx_back_hash;
    function (int i, byte[HASH_BYTES]& tx_back_hash)=>Message10_parse_tx build;
do
    function (int i, byte[HASH_BYTES]& tx_back_hash)=>Message10_parse_tx build do
        this.i = i;
        this.tx_back_hash = &tx_back_hash;
    end

    // APP.txs[tx_hash] = { hash=nil, timestamp=nil, bytes=nil, payload=nil }

    // hash[TIMESTAMP..TX_BACK_HASH..TX_PAYLOAD]
    var char[] tx_payload = [[ TX.payload ]];
    var byte[] plain = [0,0,0,0]..tx_back_hash..tx_payload;
                        // TODO: switch to timestamp

    // calculate nonce for the leading zeros
    var int ms = 0;
    par/or do
        // TODO: remove
        every 100ms do
            ms = ms + 100;
            _printf(".");
            _fflush(_stdout);
        end
    with
        var byte[HASH_BYTES] tx_hash;
        var u32 nonce = 0;
        var u8 zeros_wanted = [[ BLOCK.chain.zeros ]];
        async/thread (plain,tx_hash,nonce,zeros_wanted) do
            var int zeros_found = 0;
            $tx_hash := HASH_BYTES;
            var u32 ii = 0;
            loop i do
                ii = ii + 1;
                _crypto_generichash((_byte&&)&&tx_hash, HASH_BYTES,
                                    (_byte&&)&&plain, $plain,
                                    null, 0);
                zeros_found = _leading_zeros((_byte&&)&&tx_hash, $tx_hash);
                if zeros_found >= zeros_wanted then
                    break;
                end
                nonce = nonce + 1;
                PUT_NETWORK_U32(plain, 0, nonce);
            end
            _printf("[client] POW rounds: %d\n", ii);
        end
        [[
            -- i'm in the database
            TX.timestamp = @nonce
            TX.hash      = @tx_hash
            APP.txs[TX.hash] = TX
            BLOCK.txs[#BLOCK.txs+1] = TX.hash
        ]];
    end
end

class Message10_parse_block with
do
    // <= BLOCK_HASH
    //  - merkle tree of all TX_HASH
    do
        var byte[] plain;
        var int n = [[ #BLOCK.txs ]]; // TODO: assert BLOCK.chain.limits.block
        loop i in n do
            //var char[]
            //plain = []..plain..;
        end
    end

// TODO: remove
#if 0
    // <= block_hash
    // <= pow
    // <= NEW HEAD
    // <= OLD.up_hash = NEW
    do
        end
        _printf("\n[client] BLOCK_HASH = %dms\n", ms);
    end
            -- i'm the head now: relink
            APP.server.chains[MSG.chain.key].heads[MSG.chain.zeros] = MSG.block_hash
            APP.blocks[HEAD_HASH].up_hash = MSG.block_hash  -- prv->up=me
            MSG.tail_hash = HEAD_HASH                       -- me->tail=prv
            MSG.back_hash = HEAD_HASH
#endif

    escape _ERR_NONE;
end

class Message10_send with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>Message10_send run;
do
    function (_uv_tcp_t& tcp)=>Message10_send run do
        this.tcp = &tcp;
    end

    // <= MESSAGE
    // <= CHAIN_ZEROS
    // <= CHAIN_LEN
    // <= CHAIN_KEY
    var int chain_zeros = [[ MSG.chain.zeros ]];
    var char[] chain_key;
    do
        var byte[] bytes;

        // message
        do
            [[ major,minor = string.match(MSG.id,'(%d+)%.(%d+)') ]]
            var int major = [[ major ]];
            var int minor = [[ minor ]];
            bytes = []..bytes..[MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, major, minor];
        end

        // chain
        do
            chain_key = [[ MSG.chain.key ]];

            var u32 chain_len = [[ string.len(MSG.chain.key) ]];
            _assert(chain_len<CHAIN_KEY_BYTES);

            bytes = []..bytes..[chain_zeros,(u8)chain_len]..chain_key;
        end

        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);
    end

    // => ACK-chain
    do
        var byte[1] recv;
        var UV_Stream_Read reader =
                UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
        do UV_Stream_ReadUntil.run(&reader, 1);
        var int err = recv[0];

        _printf("[client] ACK-chain = %d\n", err);
        if err == _MESSAGE10_NOTSUB then
            escape _MESSAGE10_NOTSUB;
        else/if err == _ERR_NONE then
            // OK: proceed to hashes
        else
            escape _ERR_REMOTE_BUG_OR_MALICIOUS;
        end
    end

    //////////////////////////////////////////////////////////////////////////

    // <= BLOCK_HASH
    // <= BLOCK_LEN
    // 
    var int n_to_transmit = 0;
    loop i do
        // <= both
        do
            var u32 len      = [[ #MSG.payload ]];
            var char[] bytes = [[ MSG.block_hash ]];
            PUT_NETWORK_U32(bytes, HASH_BYTES, len);
            do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);
        end

        // => ACK-chain
        var int ret = _ERR_NONE;
        do
            var byte[1] recv;
            var UV_Stream_Read reader =
                    UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
            do UV_Stream_ReadUntil.run(&reader, 1);
            ret = recv[0];

            _printf("[client] ACK-hashes[%d] = %d {\n", i, ret);
            [[ print(hex_dump(MSG.block_hash)) ]];
            [[ print'}' ]];
            if ret == _MESSAGE10_PAYLOAD_LEN_LIMIT then
                // remote thinks it is too big
                escape _MESSAGE10_PAYLOAD_LEN_LIMIT;
            else/if ret == _MESSAGE10_HAVE_NO then
                // continue searching
            else/if ret == _MESSAGE10_HAVE_YES then
                if i == 0 then
                    // remote has all my messages
                    escape _MESSAGE10_HAVE_YES;
                else
                    // remote have this, but not this.up
                    n_to_transmit = i;
                    break;  // OK: proceed to complete this.up send
                end
            else
                escape _ERR_REMOTE_BUG_OR_MALICIOUS;
            end
        end
        _assert(ret == _MESSAGE10_HAVE_NO);

        [[ MSG = APP.blocks[MSG.tail_hash] ]];
        var bool has = [[ MSG~=nil ]];
        if not has then
            escape _ERR_REMOTE_BUG_OR_MALICIOUS;  // remote must have genesis
        end
    end
    [[
        MSG = APP.blocks[MSG.up_hash]
        assert(MSG)
    ]];

    //////////////////////////////////////////////////////////////////////////

    // <= BLOCK
    // send MSG, MSG.up, MSG.up.up, ...
    _printf("[client] I will transmit %d message(s)...\n", n_to_transmit);
    loop i do
        var byte[] bytes;

        // <= PoW
        do
            var u32 nonce = [[ MSG.pow ]];
            PUT_NETWORK_U32(bytes, $bytes, nonce);
        end

        // => BACK_HASH (immutable, see above)
        do
            var char[HASH_BYTES] back_hash = [[ MSG.back_hash ]];
            bytes = []..bytes..back_hash;
        end

        // => PAYLOAD
        do
            var char[] payload = [[ MSG.payload ]];
            bytes = []..bytes..payload;
        end

        // => PoS
        // TODO
        do
            var u8 pos = 0xEE;
            bytes = []..bytes..[pos];
#if 1
            _printf("TODO: POS generate!\n");
#endif
        end

        _printf("[client] Transmitting %d...\n", i);
        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

        [[ MSG = APP.blocks[MSG.up_hash] ]];
        var bool up = [[ MSG~=nil ]];
        if not up then
            break;
        end
    end

    escape _ERR_NONE;
end

interface PeerListener with
    event int ok;
end

class PeerSend with
input:
    var PeerListener& listener;

    function (PeerListener& listener)=>PeerSend run;
do
    function (PeerListener& listener)=>PeerSend run do
        this.listener = &listener;
    end
// TODO: to test multiple topology paths
//await 2s;

    var char[] ip   = [[ PEER.host[1] ]];
    var int    port = [[ PEER.host[2] ]];
    _printf("[client] Connecting to %s:%d.\n", (_char&&)&&ip, port);
    var UV_TCP_Client c = UV_TCP_Client.build(&ip, port);

    var bool is_10 = [[ MSG.id=='1.0' ]];
    // ...

    var int err =
    do
        var int err_ = await c.ok;
        if err_ != _ERR_NONE then
            escape err_;
        end

        _printf("[client] Connected to %s:%d.\n", (_char&&)&&ip, port);
        watching err_ in c do
            err_ = _ERR_NONE;
            if is_10 then
                err_ = do Message10_send.run(&c.tcp);
            else
                // ...
                err_ = _ERR_MESSAGE;
            end
            escape err_;
        end
        escape err_;
// TODO: usar erro de c
        //escape _ERR_DISCONNECTED;
    end;

    _printf("[client] Disconnected from %s:%d => %d\n",
            (_char&&)&&ip, port, err);
    emit listener.ok => err;
    escape err;
end

class Client with
    interface PeerListener;
do
    var bool is_parsed = [[ BLOCK~=nil ]];
    if not is_parsed then
        var int ms = [[ #APP.messages ]];
        if ms == 0 then
            escape -1;      // no messages
        end

        loop i in ms do
            [[
                local msg = APP.messages[@i+1]
                assert(type(msg)=='table')
                if msg.id == '1.0' then
                    assert(type(msg.chain)=='table')
                    chain_parse_id(msg.chain)
                    TX = {
                        bytes   = string.len(msg.payload),
                        payload = msg.payload,
                        hash    = nil,
                    }
                    BLOCK = {
                        id    = msg.id,
                        hash  = nil,
                        chain = msg.chain,
                        txs = { },
                    }
                    HEAD_HASH = APP.chains[BLOCK.chain.id].head
                    assert(type(HEAD_HASH) == 'string')
                else
                    error 'message not supported'
                end
            ]];

            var bool is_10 = [[ BLOCK~=nil ]];
            if is_10 then
                // hash of last tx in current head block
                [[ txs = APP.blocks[HEAD_HASH].txs ]];
                var char[HASH_BYTES] tx_back_hash = [[ txs[#txs] ]];
                do Message10_parse_tx.build(i+1, &tx_back_hash);
                do Message10_parse_block;
            else
                _assert(0);  // message not supported
            end
        end
    end

    var int ps = [[#APP.client.peers]];
    var int ps_ok = 0;
    loop i in ps do
        [[
            PEER = APP.client.peers[@(i+1)]
            ok = false
            for key, chain in pairs(PEER.chains) do
                if key==BLOCK.chain.key and chain.zeros<=BLOCK.chain.zeros then
                    ok = true
                    break
                end
            end
        ]];
        var bool ok_ = [[ ok ]];
        if ok_ then
            ps_ok = ps_ok + 1;
            var PeerSend&&? p = spawn PeerSend.run(&this);
            _assert(p! != null);
        end
    end
    _printf("[client] Broadcasting messages to %d peer(s)...\n", ps_ok);
    loop i in ps_ok do
        var int err = await this.ok;
        _printf("[client] peer %d\n", err);
    end
    _printf("[client] Broadcasts OK!\n");

    escape _ERR_NONE;   // trasmitted messages
end

#endif
