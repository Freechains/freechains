#ifndef _CLIENT_CEU
#define _CLIENT_CEU

code/await Send_10 (var& UV_Stream tcp) -> none
    // [[ ARGS = { chain={...} } ]]
    throws Exception.Uv, Exception.Freechains.Malformed
do
    [[ THIS = ARGS ]]

    ///////////////////////////////////////////////////////////////////////////
    // HEADER
    ///////////////////////////////////////////////////////////////////////////

    // <= MESSAGE
    // <= CHAIN_KEY_LEN
    // <= CHAIN_KEY_STR
    // <= CHAIN_ZEROS
    // <= CHAIN_LENGTH
    do/_
        tcp.buffer = [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, 1, 0];

        do
            var u8     zeros   = [[ THIS.chain.zeros ]];
            var[] byte key_str = [] .. [[ THIS.chain.key ]];
            var u8     key_len = [[ string.len(THIS.chain.key) ]];
            var u64    length  = [[ THIS.chain.head.length ]];
            _ceu_assert(key_len<CHAIN_KEY_BYTES, "bug found");
            tcp.buffer = tcp.buffer .. [key_len as byte] .. key_str .. [zeros as byte] .. [0,0,0,0,0,0,0,0];
            PUT_HTOBE64(tcp.buffer, $tcp.buffer-sizeof(u64), length);
        end

        await UV_Stream_Write_N(&tcp,_);

        // => ACK-header
        do/_
            await UV_Stream_Read_N(&tcp, 1);
            var byte ret = tcp.buffer[0];
            $tcp.buffer = $tcp.buffer - 1;

            _dbg_tcp(0, &&tcp.handle, "client", "=> ACK-header = %d", ret);

            if ret == {MESSAGE10_OK} then
                // OK: proceed to BLOCKS
            else/if ret=={MESSAGE10_NOTSUB} or ret=={MESSAGE10_HAVE} then
                escape;
            else
                var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
                throw e;
            end
        end
    end

    ///////////////////////////////////////////////////////////////////////////
    // BLOCKS
    // - first, reads hashes from head -> genesis until finds common block
    // - then, writes from common.nxt -> head
    ///////////////////////////////////////////////////////////////////////////

    // TODO: PoS: before/after each block? once per block?

    loop do
        // => HASH
        await UV_Stream_Read_N(&tcp, HASH_BYTES);
        do
            var[] byte str = [] .. [[ tostring2(@tcp.buffer) ]] .. [0];
            _dbg_tcp(3, &&tcp.handle, "client", "=> BLOCK_HASH? : %s", &&str[0]);
        end
        [[
            block = GG.chain_block(THIS.chain,@tcp.buffer)
        ]]
        var bool has = [[ block~=nil ]];
        var int ret = do
            if has then
                escape {MESSAGE10_HAVE};
            else
                escape {MESSAGE10_OK};
            end
        end;
        tcp.buffer = [ret];
        // <= ACK-HASH
        _dbg_tcp(3, &&tcp.handle, "client", "<= ACK-BLOCK_HASH? : %d", ret);
        await UV_Stream_Write_N(&tcp,_);
        if has then
            [[
                THIS.common = block
            ]]
            break;
        end
    end

    [[ THIS.cur = THIS.common.nxt ]];

    var int i;
    loop i do
        // <= BLOCK_HASH
        // <= TIMESTAMP + NONCE
        // <= PUBLICATION_HASH
        // <= PRV_HASH
        do
            tcp.buffer = [] .. [[ THIS.cur.hash ]] .. 
                               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                               [[ THIS.cur.publication.hash ]] ..
                               [[ THIS.cur.prv.hash ]];
            do
                var u64 timestamp = [[ THIS.cur.timestamp ]];
                var u64 nonce     = [[ THIS.cur.nonce     ]];
                PUT_HTOBE64(tcp.buffer, HASH_BYTES, timestamp);
                PUT_HTOBE64(tcp.buffer, HASH_BYTES+sizeof(u64), nonce);

                var[] byte str = [] .. [[ tostring2(THIS.cur.hash) ]] .. [0];
                _dbg_tcp(3, &&tcp.handle, "client", "<= BLOCK_HASH : %s", &&str[0]);
                _dbg_tcp(3, &&tcp.handle, "client", "<= TIMESTAMP/NONCE : %ld %ld", timestamp,nonce);
            end

            await UV_Stream_Write_N(&tcp,_);
        end

        // => ACK-PUBLICATION-HASH
        var bool send_publication = do
            await UV_Stream_Read_N(&tcp, 1);
            var byte ret = tcp.buffer[0];
            if ret == {MESSAGE10_HAVE} then
                escape false;
            else/if ret == {MESSAGE10_OK} then
                escape true;
            else
                var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
                throw e;
            end
        end;
        if send_publication then
            tcp.buffer = [] .. [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                               [0,0,0,0] ..
                               [[ THIS.cur.publication.payload ]];
            var u64 timestamp   = [[ THIS.cur.publication.timestamp ]];
            var u64 nonce       = [[ THIS.cur.publication.nonce     ]];
            var u32 payload_len = [[ string.len(THIS.cur.publication.payload) ]];
            PUT_HTOBE64(tcp.buffer, 0, timestamp);
            PUT_HTOBE64(tcp.buffer, sizeof(u64), nonce);
            PUT_HTOBE32(tcp.buffer, 2*sizeof(u64), payload_len);
            await UV_Stream_Write_N(&tcp,_);
        end

/*
        // => ACK-BLOCK
        // TODO: good place for PoS
        do
            await UV_Stream_Read_N(&tcp, 1);
            var byte ret = tcp.buffer[0];
            $tcp.buffer = $tcp.buffer - 1;

            //_printf("[client] => ACK-tx = %d\n", ret);
            if ret != {MESSAGE10_OK} then
                var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
                throw e;
            end
        end
*/

        [[ THIS.cur = THIS.cur.nxt ]];
        var bool should_stop = [[ THIS.cur==nil ]];
        if should_stop then
            break;
        end
    end
end

code/await Peer_10 (none) -> none
    // [[ ARGS = { peer={...}, chain={...} } ]]
do
    [[ THIS = ARGS ]];

{CLIENTS_ALIVE++;}
do finalize with
    {CLIENTS_ALIVE--;}
end

    var[] byte ip   = [] .. [[ THIS.peer.host[1] ]] .. [0];
    var   int  port = [[ THIS.peer.host[2] ]];
    _dbg(2, "client:%p | connecting to %s:%d", {&_ceu_mem}, &&ip[0], port);

    var Exception.Uv? e1;
    var Exception.Freechains? e2;
    catch e1,e2 do
        var& UV_TCP_Connect c = spawn UV_TCP_Connect(&&ip[0], port, _);

        do finalize with
            _dbg(2, "client:%p | disconnected from %s:%d", {&_ceu_mem}, &&ip[0], port);
        end

        await c.ok;
        _dbg(2, "client:%p | connected to %s:%d", {&_ceu_mem}, &&ip[0], port);

        [[ ARGS = THIS ]]
        await Send_10(&c.stream);
    end
    if e1? then
        _dbg(3, "client:%p | %s", {&_ceu_mem}, e1!.message);
    else/if e2? then
        _dbg(3, "client:%p | %s", {&_ceu_mem}, e2!.message);
    end
end

code/await Client_10 (var& UV_TCP_Server_Data shared) -> none
    // [[ ARGS = { chain={...} } ]]
do
    [[ THIS = ARGS ]];

    var int ps = [[#APP.client.peers]];
    var int ps_ok = 0;
    var int i;
    pool[] Peer_10 peers;
    loop i in [1 -> ps] do
        [[
            peer = APP.client.peers[@i]
            ok = false
            for _, chain in pairs(peer.chains) do
                if chain.key==THIS.chain.key and
                   chain.zeros<=THIS.chain.zeros then
                    ok = true
                    break
                end
            end
        ]];
        var bool ok_ = [[ ok ]];
        if ok_ then
            ps_ok = ps_ok + 1;
            [[
                ARGS = {
                    peer  = peer,
                    chain = THIS.chain,
                }
            ]];
            var&? Peer_10 p = spawn Peer_10() in peers;
            _ceu_assert(p?, "bug found");
        end
    end
    var[] byte id = [] .. [[ THIS.chain.id ]] .. [0];
    _dbg(0, "client:%p | broadcasting %s messages to %d peer(s)", {&_ceu_mem}, &&id[0], ps_ok);
    do finalize with
        _dbg(0, "client:%p | broadcasts OK", {&_ceu_mem});
    end
    var&? Peer_10 p;
    loop p in peers do
        await p;
        //_dbg(0, "client:%p | peer %d", {&_ceu_mem}, err);
    end
end

code/await ClientMessages (var& UV_TCP_Server_Data shared) -> none
    throws Exception.Freechains.Unsupported
do
    var int ms = [[ #APP.messages ]];
    _ceu_assert(ms > 0, "no messages to client");

    // client mode: terminates

    do finalize with
        [[ APP.messages = {} ]];
    end

    var int i;
    loop i in [1 -> ms] do
        [[
            msg = APP.messages[@i]
            assert(type(msg)=='table')
            assert(type(msg.chain)=='table')
        ]];

        var bool is_10 = [[ APP.messages[@i].version=='1.0' ]];

        if is_10 then
            [[
                THIS = {}
                THIS.publication = {
                    chain     = assert(GG.chain_parse_get(msg.chain), msg.chain.id),
                    timestamp = 0,    -- TODO: 64-bit timestamp
                    nonce     = 0,
                    payload   = msg.payload,
                    hash      = nil,
                }
                ARGS = THIS
            ]]
            await Publication_New();
            do
                [[ ARGS = { chain=THIS.publication.chain } ]]
                spawn Chain_Lock(&shared);
                [[
                    THIS.block = {
                        version     = '1.0',
                        timestamp   = 0,    -- TODO: 64-bit timestamp
                        nonce       = 0,
                        chain       = THIS.publication.chain,
                        publication = THIS.publication,
                        hash        = nil,
                        prv         = nil,
                        nxt         = nil,
                        length      = nil,
                    }
                    ARGS = THIS
                ]]
                await Block_Hash_Link();
                [[
                    THIS = { chain=THIS.block.chain }
                    ARGS = THIS
                ]];
                await Client_10(&shared);
            end
            [[
                ARGS = THIS
            ]]
            emit shared.ok({MESSAGE10}, false, {MESSAGE10_OK});
        else
            var Exception.Freechains.Unsupported e = val Exception.Freechains.Unsupported(_);
            throw e;
        end
    end
end

#endif
