#ifndef _CLIENT_CEU
#define _CLIENT_CEU

#include "sodium.ceu"

native do
    // calculate the number of leading zero bits in "bytes"
    // 00abcdef...  => 2
    int leading_zeros (byte* bytes, int len) {
        int i, j;
        int zeros = 0;
        for (i=0; i<len; i++) {             // loop over "bytes"
            byte b = bytes[i];
            for (j=0; j<8; j++) {           // loop over each bit
                if ((b & (1<<j)) != 0) {
                    return zeros;
                } else {
                    zeros++;
                }
            }
        }
        return zeros;
    }
end


class Message10_prepare with
    var Message& msg;
    function (Message& msg)=>Message10_prepare build;
do
    function (Message& msg)=>Message10_prepare build do
        this.msg = &msg;
    end

    // => MESSAGE
    do
        var int major = [[ MSG.id_t.major ]];
        var int minor = [[ MSG.id_t.minor ]];
        this.msg.bytes = []..this.msg.bytes..
                         [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, major, minor];
    end

    // => CHAIN_SIGNED?
    // => CHAIN_LEN
    // => CHAIN_KEY
    var bool chain_signed;
    var char[] chain_key;
    do
        chain_signed = [[ MSG.chain.signed ]];
        chain_key    = [[ MSG.chain.key ]];

        var int chain_len = [[ string.len(MSG.chain.key) ]];
        _assert(chain_len>=0 and chain_len<CHAIN_KEY_BYTES);

        var u8 chain = (chain_len | (chain_signed<<7));
        this.msg.bytes = []..this.msg.bytes..[chain]..chain_key;
    end

    // => PAYLOAD_HASH
    do
        // generate MSG.hash_0s
        do
            var char[HASH_BYTES] tail_hash = [[ MSG.chain.config.head ]];
            var char[]           payload   = [[ MSG.payload ]];

            var char[] plain =
                [ 0,0,0,0 ]      ..     // PoW nonce
                [ chain_signed ] ..
                chain_key        ..
                tail_hash        ..
                payload          ;

            var char[HASH_BYTES] hash;
            var u32 nonce = 0;

            var int s = 0;
            par/or do
                every 1s do
                    s = s + 1;
                end
            with
                async/thread (plain,hash,nonce) do
                    var int zeros_wanted = 25;//[[ MSG.chain.zeros ]];
                    var int zeros_found  = 0;

                    $hash := HASH_BYTES;
                    loop do
                        _crypto_generichash((_byte&&)(_char&&)&&hash, HASH_BYTES,
                                            (_byte&&)(_char&&)&&plain, $plain,
                                            null, 0);
                        zeros_found = _leading_zeros((_char&&)&&hash, $hash);
                        if zeros_found >= zeros_wanted then
                            break;
                        end
                        nonce = nonce + 1;
                        PUT_NETWORK_U32(plain, 0, nonce);
                    end
                end
            end
_printf("===> %ds\n", s);
        end

        // read MSG.hash_0s
        loop i in HASH_BYTES do
            if i==0 or i==HASH_BYTES-1 then
                this.msg.bytes = []..this.msg.bytes..[0xEE];  // TODO
            else
                this.msg.bytes = []..this.msg.bytes..[0xFF];  // TODO
            end
        end
    end


    this.msg.offs = []..this.msg.offs..[$this.msg.bytes];

    //////////////////////////////////////////////////////////////////////////

    // => PoW
    do
        var u32 pow = 0xEEFFFFEE;       // TODO
        PUT_NETWORK_U32(this.msg.bytes, $this.msg.bytes, pow);
    end

    // => PoS
    do
        var u8 pos = 0xEE;              // TODO
        this.msg.bytes = []..this.msg.bytes..[pos];
    end

    // => BACK_HASH
    do
        loop i in HASH_BYTES do
            if i==0 or i==HASH_BYTES-1 then
                this.msg.bytes = []..this.msg.bytes..[0xEE];  // TODO
            else
                this.msg.bytes = []..this.msg.bytes..[0xFF];  // TODO
            end
        end
    end

    // => TAIL_HASH
    do
        loop i in HASH_BYTES do
            if i==0 or i==HASH_BYTES-1 then
                this.msg.bytes = []..this.msg.bytes..[0xEE];  // TODO
            else
                this.msg.bytes = []..this.msg.bytes..[0xFF];  // TODO
            end
        end
    end

    // => PAYLOAD_LEN
    // => PAYLOAD
    var char[] payload = [[ MSG.payload ]];
    PUT_NETWORK_U32(this.msg.bytes, $this.msg.bytes, $payload);
    this.msg.bytes = []..this.msg.bytes..payload;

    this.msg.offs = []..this.msg.offs..[$this.msg.bytes];

    escape _ERR_NONE;
end

interface PeerListener with
    event int ok;
end

class PeerSend with
input:
    var int peer_i;
    var Message&      msg;
    var PeerListener& listener;

    function (int i, Message& msg, PeerListener& listener)=>PeerSend build;
do
    function (int i, Message& msg, PeerListener& listener)=>PeerSend build do
        this.peer_i   = i;
        this.msg      = &msg;
        this.listener = &listener;
    end

    var char[] ip   = [[ APP.client.peers[@this.peer_i][1] ]];
    var int    port = [[ APP.client.peers[@this.peer_i][2] ]];
    _printf("[client] Connecting to %s:%d.\n", (_char&&)&&ip, port);
    var UV_TCP_Client c = UV_TCP_Client.build(&ip, port);
    var int status = await c.ok;

    if status == 0 then
        _printf("[client] Connected to %s:%d.\n", (_char&&)&&ip, port);
        watching c do
            var u32 starting = 0;
            loop i in $this.msg.offs do
                // => offs[i]
                var u32 excluding = this.msg.offs[i];
                do UV_Stream_Write.build2(&_UV_STREAM_ALIAS(c.tcp),
                                          &this.msg.bytes,
                                          starting, excluding);

                // <= OK?
                var int ok = 0;
                do
                    var byte[] recv;
                    var UV_Stream_Read r = UV_Stream_Read.build(&_UV_STREAM_ALIAS(c.tcp),&recv);
                    AWAIT_UNTIL(r,1);
                    _assert(r.next >= 1);
                    if r.next > 1 then
                        escape _ERR_EXTRA_BYTES;
                    end
                    ok = recv[0];
                end
                starting = excluding;
            end
        end
        escape _ERR_NONE;
    end

    _printf("[client] Diconnected from %s:%d.\n", (_char&&)&&ip, port);
    escape _ERR_DISCONNECTED;
end

class PeersSend with
    interface PeerListener;
input:
    var Message& msg;

    function (Message& msg)=>PeersSend run;
do
    function (Message& msg)=>PeersSend run do
        this.msg = &msg;
    end

    _printf("[client] Broadcasting message...\n");
    var int n = [[#APP.client.peers]];
    loop i in n do
        spawn PeerSend.build(i+1, &this.msg, &this);
    end
    loop i in n do
        var int err = await this.ok;
        _printf("[client]\tpeer %d\n", err);
    end
    _printf("[client] Broadcast OK!\n");

    escape _ERR_NONE;
end

class Client with
do
    var int ni = [[ #APP.messages ]];

    loop i in ni do
        [[ MSG = APP.messages[@i+1] ]];
        var Message msg;
        var bool is_10 = [[ MSG.id=='1.0' ]];
        if is_10 then
            var int err = do Message10_prepare.build(&msg);
            _assert(err == _ERR_NONE);
        else
            _assert(0);  // message not supported
        end
        do PeersSend.run(&msg);
    end

    escape _ERR_NONE;
end

#endif
