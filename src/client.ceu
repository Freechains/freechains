#ifndef _CLIENT_CEU
#define _CLIENT_CEU

#include "client-server.ceu"

#if 0
    uint32_t htonl(uint32_t hostlong);
    uint16_t htons(uint16_t hostshort);
    uint32_t ntohl(uint32_t netlong);
    uint16_t ntohs(uint16_t netshort);
#endif

class CONTENTS_PUT_send with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>CONTENTS_PUT_send build;
do
    function (_uv_tcp_t& tcp)=>CONTENTS_PUT_send build do
        this.tcp = &tcp;
    end
    var byte[] bytes;

    // => BC_SIGNED?
    // => BC_LEN
    // => BC_DATA
    do
        var bool bc_signed = [[ APP.contents.bc_signed ]];
        var int  bc_len    = [[ APP.contents.bc_len    ]];
        _assert(bc_len>=0 and bc_len<256);
        var u8 bc = (bc_len | (bc_signed<<7));
        bytes = []..bytes..[bc];

        if bc_len > 0 then
            var char[] bc_data = [[ APP.contents.bc_data ]];
            bytes = []..bytes..bc_data;
        end
    end

    // => ZEROS_N
    do
        var int zeros_n = [[ APP.contents.zeros_n ]];
        _assert(zeros_n>=0 and zeros_n<256);
        bytes = []..bytes..[zeros_n];
    end

    // => BLK_BACK_HASH
    // => CONTENTS_DATA_HASH
    do
        // TODO: BLK_BACK_HASH
        loop i in HASH_BYTES do
            bytes = []..bytes..[0xEE];
        end
        // TODO: CONTENTS_DATA_HASH
        loop i in HASH_BYTES do
            bytes = []..bytes..[0xEE];
        end
    end

    // => CONTENTS_PUT
    do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

    // <= OK?
    var int ok = 0;
    do
        $bytes = 0;
        var UV_Stream_Read r = UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&bytes);
        AWAIT_UNTIL(r,1);
        _assert(r.next >= 1);
        if r.next > 1 then
            escape _ERR_EXTRA_BYTES;
        end
        ok = bytes[0];
    end
    _printf("OK = %d\n", ok);

    escape ok;
end

class CONTENTS_DATA_send with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>CONTENTS_DATA_send build;
do
    function (_uv_tcp_t& tcp)=>CONTENTS_DATA_send build do
        this.tcp = &tcp;
    end
    var byte[] bytes;

    // => NOUNCE
    var u8 nounce = 0;
    bytes = []..bytes..[nounce];

    // => CONTENTS_LEN
    // => CONTENTS_DATA
    var char[] contents_data = [[ APP.contents.contents_data ]];
    PUT_NETWORK_U32(bytes, $contents_data);
    bytes = []..bytes..contents_data;

    // => CONTENTS_DATA
    do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

    escape _ERR_NONE;
end

class ClientConnected with
    var UV_TCP_Client& c;
    function (UV_TCP_Client& c)=>ClientConnected build;
do
    function (UV_TCP_Client& c)=>ClientConnected build do
        this.c = &c;
    end

    // VERSION
    do
        do MAGIC_VERSION_send.build(&this.c.tcp);
        var int err = do MAGIC_VERSION_recv.build(&this.c.tcp);
        if err then
            escape err;
        end
        _printf("[client] version ok\n");
    end

    // CONTENTS_PUT_send
    var int ret = do CONTENTS_PUT_send.build(&this.c.tcp);

    // CONTENTS_DATA
    if ret > 0 then
        do CONTENTS_DATA_send.build(&this.c.tcp);
    end

    escape _ERR_NONE;
    //await FOREVER;
end

class Client with
    input:
        var int i;

    function (int i)=>Client build;
do
    function (int i)=>Client build do
        this.i = i;
    end

    loop do
        var char[] ip   = [[ APP.client.peers[@this.i][1] ]];
        var int    port = [[ APP.client.peers[@this.i][2] ]];
        var UV_TCP_Client c = UV_TCP_Client.build(&ip, port);
        var int status = await c.ok;

        if status == 0 then
            _printf("Connected to %s:%d.\n", (_char&&)&&ip, port);
            watching c do
                var int ret = do ClientConnected.build(&c);
                _printf("Error: %d\n", ret);
            end
            _printf("Diconnected from %s:%d.\n", (_char&&)&&ip, port);
        end

        var int dt = [[ APP.client.time_connection_retry ]];
        await (dt)ms;
    end
end

#endif
