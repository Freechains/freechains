#ifndef _CLIENT_CEU
#define _CLIENT_CEU

#include "sodium.ceu"

class Message10_parse with
do
    // <= tail_hash
    // <= back_hash
    [[
        MSG.tail_hash = APP.chains[MSG.chain.key].heads[MSG.chain.zeros]
        MSG.back_hash = MSG.tail_hash
    ]];

    // <= block_hash
    // <= pow
    // <= NEW HEAD
    // <= OLD.up_hash = NEW
    do
        var char[] tail_hash__payload = [[ MSG.payload..MSG.payload ]];
        var byte[] plain = [0,0,0,0]..tail_hash__payload;

        // calculate nonce for the leading zeros
        var int ms = 0;
        par/or do
            // TODO: remove
            every 100ms do
                ms = ms + 100;
                _printf(".");
                _fflush(_stdout);
            end
        with
            var byte[HASH_BYTES] block_hash;
            var u32 nonce = 0;
            var u8 zeros_wanted = [[ MSG.chain.zeros ]];
            async/thread (plain,block_hash,nonce,zeros_wanted) do
                var int zeros_found = 0;
                $block_hash := HASH_BYTES;
                loop do
                    _crypto_generichash((_byte&&)&&block_hash, HASH_BYTES,
                                        (_byte&&)&&plain, $plain,
                                        null, 0);
                    zeros_found = _leading_zeros((_byte&&)&&block_hash, $block_hash);
                    if zeros_found >= zeros_wanted then
                        break;
                    end
                    nonce = nonce + 1;
                end
            end
            [[
                MSG.pow        = @nonce
                MSG.block_hash = @block_hash
                local head_hash = APP.chains[MSG.chain.key].heads[MSG.chain.zeros]
                local head_block = assert(APP.blocks[head_hash])
                head_block.up_hash = MSG.block_hash
                APP.chains[MSG.chain.key].heads[MSG.chain.zeros] = MSG.block_hash
                APP.blocks[MSG.block_hash] = MSG
            ]];
        end
        _printf("\n[client] BLOCK_HASH = %dms\n", ms);
    end

    escape _ERR_NONE;
end

class Message10_send with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>Message10_send run;
do
    function (_uv_tcp_t& tcp)=>Message10_send run do
        this.tcp = &tcp;
    end

    // <= MESSAGE
    // <= CHAIN_ZEROS
    // <= CHAIN_LEN
    // <= CHAIN_KEY
    var int chain_zeros = [[ MSG.chain.zeros ]];
    var char[] chain_key;
    do
        var byte[] bytes;

        // message
        do
            var int major = [[ MSG.id_t.major ]];
            var int minor = [[ MSG.id_t.minor ]];
            bytes = []..bytes..[MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, major, minor];
        end

        // chain
        do
            chain_key = [[ MSG.chain.key ]];

            var u32 chain_len = [[ string.len(MSG.chain.key) ]];
            _assert(chain_len<CHAIN_KEY_BYTES);

            bytes = []..bytes..[chain_zeros,(u8)chain_len]..chain_key;
        end

        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);
    end

    // => ACK-chain
    do
        var byte[1] recv;
        var UV_Stream_Read reader =
                UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
        do UV_Stream_ReadUntil.run(&reader, 1);
        var int err = recv[0];

        _printf("[client] ACK-chain = %d\n", err);
        if err == _MESSAGE10_NOTSUB then
            escape _MESSAGE10_NOTSUB;
        else/if err == _ERR_NONE then
            // OK: proceed to hashes
        else
            escape _ERR_REMOTE_BUG_OR_MALICIOUS;
        end
    end

    //////////////////////////////////////////////////////////////////////////

    // <= BLOCK_HASH
    // <= BLOCK_LEN
    // 
    [[ UP = MSG ]]; // when remote has [[MSG]], it wants [[UP]]
    loop i do
        // <= both
        do
            var u32 len      = [[ #MSG.payload ]];
            var char[] bytes = [[ MSG.block_hash ]];
            PUT_NETWORK_U32(bytes, HASH_BYTES, len);
            do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);
        end

        // => ACK-chain
        do
            var byte[1] recv;
            var UV_Stream_Read reader =
                    UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
            do UV_Stream_ReadUntil.run(&reader, 1);
            var int ret = recv[0];

            _printf("[client] ACK-hashes[%d] = %d\n", i, ret);
            if ret == _MESSAGE10_PAYLOAD_LEN_LIMIT then
                // remote thinks it is too big
                escape _MESSAGE10_PAYLOAD_LEN_LIMIT;
            else/if ret == _MESSAGE10_HAVE_NO then
                // continue searching
            else/if ret == _MESSAGE10_HAVE_YES then
                if i == 0 then
                    // remote has all my messages
                    escape _MESSAGE10_HAVE_YES;
                else
                    // remote didn't have [[UP]]
                    break;  // OK: proceed to complete [[UP]] send
                end
            else
                escape _ERR_REMOTE_BUG_OR_MALICIOUS;
            end
        end

        [[
            UP  = MSG
            MSG = APP.blocks[MSG.tail_hash]
        ]];
        var bool has = [[ MSG~=nil ]];
        if not has then
            escape _ERR_REMOTE_BUG_OR_MALICIOUS;  // remote must have genesis
        end
    end
    [[ MSG = UP ]];

    //////////////////////////////////////////////////////////////////////////

    // <= BLOCK
    do
        var byte[] bytes;

        // <= PoW
        do
            var u32 nonce = [[ MSG.pow ]];
            PUT_NETWORK_U32(bytes, $bytes, nonce);
        end

        // => BACK_HASH (immutable, see above)
        do
            var char[HASH_BYTES] back_hash = [[ MSG.back_hash ]];
            bytes = []..bytes..back_hash;
        end

        // => PAYLOAD
        do
            var char[HASH_BYTES] payload = [[ MSG.payload ]];
            bytes = []..bytes..payload;
        end

        // => PoS
        // TODO
        do
            var u8 pos = 0xEE;
            bytes = []..bytes..[pos];
#if 1
            _printf("TODO: POS generate!\n");
#endif
        end

        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);
    end

    escape _ERR_NONE;
end

interface PeerListener with
    event int ok;
end

class PeerSend with
input:
    var int peer_i;
    var PeerListener& listener;

    function (int i, PeerListener& listener)=>PeerSend run;
do
    function (int i, PeerListener& listener)=>PeerSend run do
        this.peer_i   = i;
        this.listener = &listener;
    end

    var char[] ip   = [[ APP.client.peers[@this.peer_i][1] ]];
    var int    port = [[ APP.client.peers[@this.peer_i][2] ]];
    _printf("[client] Connecting to %s:%d.\n", (_char&&)&&ip, port);
    var UV_TCP_Client c = UV_TCP_Client.build(&ip, port);

    var bool is_10 = [[ MSG.id=='1.0' ]];
    // ...

    var int err =
    do
        var int err_ = await c.ok;
        if err_ != _ERR_NONE then
            escape err_;
        end

        _printf("[client] Connected to %s:%d.\n", (_char&&)&&ip, port);
        watching c do
            var int err_ = _ERR_NONE;
            if is_10 then
                err_ = do Message10_send.run(&c.tcp);
            else
                // ...
            end
            escape err_;
        end
// TODO: usar erro de c
        //escape _ERR_DISCONNECTED;
    end;

    _printf("[client] Diconnected from %s:%d => %d\n", (_char&&)&&ip, port, err);
    emit listener.ok => err;
    escape err;
end

class Client with
    interface PeerListener;
do
    [[ MSG = APP.message ]];
    var bool has = [[ MSG~=nil ]];
    if not has then
        await FOREVER;
    end

    // <= MSG
    do Message10_parse;

    var bool is_10 = [[ MSG.id=='1.0' ]];
    _assert(is_10);  // message not supported

    _printf("[client] Broadcasting message...\n");
    var int n = [[#APP.client.peers]];
    loop i in n do
        var PeerSend&&? p = spawn PeerSend.run(i+1, &this);
        _assert(p! != null);
    end
    loop i in n do
        var int err = await this.ok;
        _printf("[client] peer %d\n", err);
    end
    _printf("[client] Broadcast OK!\n");

    escape _ERR_NONE;
end

#endif
