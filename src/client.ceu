#ifndef _CLIENT_CEU
#define _CLIENT_CEU

#include "sodium.ceu"

class Message10_parse with
do
    // <= block_hash
    // <= pow
    // <= NEW HEAD
    // <= OLD.up_hash = NEW
    do
        [[ HEAD_HASH = APP.chains[MSG.chain.key].heads[MSG.chain.zeros] ]];
        var char[] tail_hash__payload = [[ HEAD_HASH..MSG.payload ]];
        var byte[] plain = [0,0,0,0]..tail_hash__payload;

        // calculate nonce for the leading zeros
        var int ms = 0;
        par/or do
            // TODO: remove
            every 100ms do
                ms = ms + 100;
                _printf(".");
                _fflush(_stdout);
            end
        with
            var byte[HASH_BYTES] block_hash;
            var u32 nonce = 0;
            var u8 zeros_wanted = [[ MSG.chain.zeros ]];
            async/thread (plain,block_hash,nonce,zeros_wanted) do
                var int zeros_found = 0;
                $block_hash := HASH_BYTES;
                var u32 ii = 0;
                loop i do
                    ii = ii + 1;
                    _crypto_generichash((_byte&&)&&block_hash, HASH_BYTES,
                                        (_byte&&)&&plain, $plain,
                                        null, 0);
                    zeros_found = _leading_zeros((_byte&&)&&block_hash, $block_hash);
                    if zeros_found >= zeros_wanted then
                        break;
                    end
                    nonce = nonce + 1;
                    PUT_NETWORK_U32(plain, 0, nonce);
                end
                _printf("[client] POW rounds: %d\n", ii);
            end
            [[
                -- i'm in the database
                MSG.pow        = @nonce
                MSG.block_hash = @block_hash
                APP.blocks[MSG.block_hash] = MSG

                -- i'm the head now: relink
                APP.chains[MSG.chain.key].heads[MSG.chain.zeros] = MSG.block_hash
                APP.blocks[HEAD_HASH].up_hash = MSG.block_hash  -- prv->up=me
                MSG.tail_hash = HEAD_HASH                       -- me->tail=prv
                MSG.back_hash = HEAD_HASH
            ]];
        end
        _printf("\n[client] BLOCK_HASH = %dms\n", ms);
    end

    escape _ERR_NONE;
end

class Message10_send with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>Message10_send run;
do
    function (_uv_tcp_t& tcp)=>Message10_send run do
        this.tcp = &tcp;
    end

    // <= MESSAGE
    // <= CHAIN_ZEROS
    // <= CHAIN_LEN
    // <= CHAIN_KEY
    var int chain_zeros = [[ MSG.chain.zeros ]];
    var char[] chain_key;
    do
        var byte[] bytes;

        // message
        do
            [[ major,minor = string.match(MSG.id,'(%d+)%.(%d+)') ]]
            var int major = [[ major ]];
            var int minor = [[ minor ]];
            bytes = []..bytes..[MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, major, minor];
        end

        // chain
        do
            chain_key = [[ MSG.chain.key ]];

            var u32 chain_len = [[ string.len(MSG.chain.key) ]];
            _assert(chain_len<CHAIN_KEY_BYTES);

            bytes = []..bytes..[chain_zeros,(u8)chain_len]..chain_key;
        end

        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);
    end

    // => ACK-chain
    do
        var byte[1] recv;
        var UV_Stream_Read reader =
                UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
        do UV_Stream_ReadUntil.run(&reader, 1);
        var int err = recv[0];

        _printf("[client] ACK-chain = %d\n", err);
        if err == _MESSAGE10_NOTSUB then
            escape _MESSAGE10_NOTSUB;
        else/if err == _ERR_NONE then
            // OK: proceed to hashes
        else
            escape _ERR_REMOTE_BUG_OR_MALICIOUS;
        end
    end

    //////////////////////////////////////////////////////////////////////////

    // <= BLOCK_HASH
    // <= BLOCK_LEN
    // 
    var int n_to_transmit = 0;
    loop i do
        // <= both
        do
            var u32 len      = [[ #MSG.payload ]];
            var char[] bytes = [[ MSG.block_hash ]];
            PUT_NETWORK_U32(bytes, HASH_BYTES, len);
            do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);
        end

        // => ACK-chain
        var int ret = _ERR_NONE;
        do
            var byte[1] recv;
            var UV_Stream_Read reader =
                    UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
            do UV_Stream_ReadUntil.run(&reader, 1);
            ret = recv[0];

            _printf("[client] ACK-hashes[%d] = %d {\n", i, ret);
            [[ print(hex_dump(MSG.block_hash)) ]];
            [[ print'}' ]];
            if ret == _MESSAGE10_PAYLOAD_LEN_LIMIT then
                // remote thinks it is too big
                escape _MESSAGE10_PAYLOAD_LEN_LIMIT;
            else/if ret == _MESSAGE10_HAVE_NO then
                // continue searching
            else/if ret == _MESSAGE10_HAVE_YES then
                if i == 0 then
                    // remote has all my messages
                    escape _MESSAGE10_HAVE_YES;
                else
                    // remote have this, but not this.up
                    n_to_transmit = i;
                    break;  // OK: proceed to complete this.up send
                end
            else
                escape _ERR_REMOTE_BUG_OR_MALICIOUS;
            end
        end
        _assert(ret == _MESSAGE10_HAVE_NO);

        [[ MSG = APP.blocks[MSG.tail_hash] ]];
        var bool has = [[ MSG~=nil ]];
        if not has then
            escape _ERR_REMOTE_BUG_OR_MALICIOUS;  // remote must have genesis
        end
    end
    [[ MSG = APP.blocks[MSG.up_hash] ]];

    //////////////////////////////////////////////////////////////////////////

    // <= BLOCK
    // send MSG, MSG.up, MSG.up.up, ...
    _printf("[client] I will transmit %d message(s)...\n", n_to_transmit);
    loop i do
        var byte[] bytes;

        // <= PoW
        do
            var u32 nonce = [[ MSG.pow ]];
            PUT_NETWORK_U32(bytes, $bytes, nonce);
        end

        // => BACK_HASH (immutable, see above)
        do
            var char[HASH_BYTES] back_hash = [[ MSG.back_hash ]];
            bytes = []..bytes..back_hash;
        end

        // => PAYLOAD
        do
            var char[HASH_BYTES] payload = [[ MSG.payload ]];
            bytes = []..bytes..payload;
        end

        // => PoS
        // TODO
        do
            var u8 pos = 0xEE;
            bytes = []..bytes..[pos];
#if 1
            _printf("TODO: POS generate!\n");
#endif
        end

        _printf("[client] Transmitting %d...\n", i);
        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

        [[ MSG = APP.blocks[MSG.up_hash] ]];
        var bool up = [[ MSG~=nil ]];
        if not up then
            break;
        end
    end

    escape _ERR_NONE;
end

interface PeerListener with
    event int ok;
end

class PeerSend with
input:
    var PeerListener& listener;

    function (PeerListener& listener)=>PeerSend run;
do
    function (PeerListener& listener)=>PeerSend run do
        this.listener = &listener;
    end

    var char[] ip   = [[ PEER.host[1] ]];
    var int    port = [[ PEER.host[2] ]];
    _printf("[client] Connecting to %s:%d.\n", (_char&&)&&ip, port);
    var UV_TCP_Client c = UV_TCP_Client.build(&ip, port);

    var bool is_10 = [[ MSG.id=='1.0' ]];
    // ...

    var int err =
    do
        var int err_ = await c.ok;
        if err_ != _ERR_NONE then
            escape err_;
        end

        _printf("[client] Connected to %s:%d.\n", (_char&&)&&ip, port);
        watching c do
            var int err_ = _ERR_NONE;
            if is_10 then
                err_ = do Message10_send.run(&c.tcp);
            else
                // ...
            end
            escape err_;
        end
// TODO: usar erro de c
        //escape _ERR_DISCONNECTED;
    end;

    _printf("[client] Diconnected from %s:%d => %d\n", (_char&&)&&ip, port, err);
    emit listener.ok => err;
    escape err;
end

class Client with
    interface PeerListener;
do
    var int ms = [[ #APP.messages ]];
    if ms == 0 then
        escape -1;      // no messages
    end

    loop i in ms do
        [[ MSG = APP.messages[@i+1] ]];

        // <= MSG
        do Message10_parse;
        var bool is_10 = [[ MSG.id=='1.0' ]];
        _assert(is_10);  // message not supported
    end

    var int ps = [[#APP.client.peers]];
    var int ps_ok = 0;
    loop i in ps do
        [[
            PEER = APP.client.peers[@(i+1)]
            ok = false
            for _, chain in ipairs(PEER.chains) do
                if chain.key==MSG.chain.key and chain.zeros<=MSG.chain.zeros then
                    ok = true
                    break
                end
            end
        ]];
        var bool ok = [[ ok ]];
        if ok then
            ps_ok = ps_ok + 1;
            var PeerSend&&? p = spawn PeerSend.run(&this);
            _assert(p! != null);
        end
    end
    _printf("[client] Broadcasting messages to %d peer(s)...\n", ps_ok);
    loop i in ps_ok do
        var int err = await this.ok;
        _printf("[client] peer %d\n", err);
    end
    _printf("[client] Broadcasts OK!\n");

    escape _ERR_NONE;   // trasmitted messages
end

#endif
