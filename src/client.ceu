#ifndef _CLIENT_CEU
#define _CLIENT_CEU

#include "sodium.ceu"

class Message10_parse_tx with
    var void& client;
do

    // APP.txs[tx_hash] = { hash=nil, timestamp=nil, bytes=nil, payload=nil }

    // hash[TIMESTAMP..TX_BACK_HASH..TX_PAYLOAD]
    var char[] tx_back_hash = [[ G(client).tx.back_hash ]];
    var char[] tx_payload   = [[ G(client).tx.payload   ]];
    var byte[] plain = [0,0,0,0]..tx_back_hash..tx_payload;
                        // TODO: switch to timestamp

    // show async/thread progress
    var int ms = 0;
    spawn do
        every 100ms do
            ms = ms + 100;
            _printf(".");
            _fflush(_stdout);
        end
    end

    // calculate nonce for the leading zeros
    var byte[HASH_BYTES] tx_hash;
    var u32 nonce = 0;
    var u8 zeros_wanted = [[ G(client).chain.zeros ]];
    async/thread (plain,tx_hash,nonce,zeros_wanted) do
        var int zeros_found = 0;
        $tx_hash := HASH_BYTES;
        var u32 ii = 0;
        loop i do
            ii = ii + 1;
            _crypto_generichash((_byte&&)&&tx_hash, HASH_BYTES,
                                (_byte&&)&&plain, $plain,
                                null, 0);
            zeros_found = _leading_zeros((_byte&&)&&tx_hash, $tx_hash);
            if zeros_found >= zeros_wanted then
                break;
            end
            nonce = nonce + 1;
            PUT_NETWORK_U32(plain, 0, nonce);
        end
        _printf("[client] POW rounds: %d\n", ii);
    end

    [[
        -- i'm in the database
        G(client).tx.timestamp = @nonce
        G(client).tx.hash      = @tx_hash
        APP.txs[G(client).tx.hash] = G(client).tx
        G(client).block.txs[#G(client).block.txs+1] = G(client).tx.hash
        print('\n[client] <= TX_HASH', string.len(G(client).tx.hash))
        print(tostring2(G(client).tx.hash))
    ]];
    _printf("[client] TX_HASH = %dms\n", ms);

    escape _ERR_NONE;
end

class Message10_parse_block with
    var void& client;
do
    // <= BLOCK_HASH
    //  - merkle tree of all TX_HASH

    var byte[] plain;
    var byte[HASH_BYTES] block_hash;
    $block_hash := HASH_BYTES;

    // TODO: should be merkle tree and not hash(concat)
    var int n = [[ #G(client).block.txs ]]; // TODO: assert BLOCK.chain.limits.block
    loop i in n do
        var char[HASH_BYTES] tx_hash = [[ G(client).block.txs[@i+1] ]];
        plain = []..plain..tx_hash;
    end

    _crypto_generichash((_byte&&)&&block_hash, HASH_BYTES,
                        (_byte&&)&&plain, $plain,
                        null, 0);

    [[
        local block = G(client).block
        block.hash  = @block_hash
        APP.blocks[block.hash] = block

        print('[client] <= BLOCK_HASH', string.len(block.hash))
        print(tostring2(block.hash))

        -- i'm the head now: relink, set new head
        local chain = G(client).chain
        local old   = APP.blocks[chain.head_hash]
        old.up_hash     = block.hash    -- prv->up=me
        block.tail_hash = old.hash      -- me->tail=prv
        chain.head_hash = block.hash
    ]]

    escape _ERR_NONE;
end

class Message10_tx_send with
    var _uv_tcp_t& tcp;
    var int        i;
    function (_uv_tcp_t& tcp, int i)=>Message10_tx_send run;
do
    function (_uv_tcp_t& tcp, int i)=>Message10_tx_send run do
        this.tcp = &tcp;
        this.i   = i;
    end

    // <= TX_HASH
    // <= TX_LEN
    do
        [[
            tx_hash   = G(tcp).block.txs[@this.i+1]
            G(tcp).tx = assert(APP.txs[tx_hash])
            print('[client] <= txs['..(@this.i+1)..']', G(tcp).tx.bytes)
            print(tostring2(G(tcp).tx.hash))
        ]];
        var u32    payload_bytes = [[ G(tcp).tx.bytes ]];
        var char[] bytes         = [[ G(tcp).tx.hash ]];
        PUT_NETWORK_U32(bytes, HASH_BYTES, payload_bytes);
        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

        // => ACK-tx
        do
            var byte[1] recv;
            var UV_Stream_Read reader =
                    UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
            do UV_Stream_ReadUntil.run(&reader, 1);
            var int err = recv[0];

            _printf("[client] => ACK-tx = %d\n", err);
            if err == _MESSAGE10_HAVE then
                escape _ERR_NONE;   // next TX (not an error)
            end
        end
    end

    // OK: complete TX
    _printf("[client] <= complete...\n");
    do
        var byte[] bytes;

        // <= TIMESTAMP: TODO(s64)
        var u32 timestamp = [[ G(tcp).tx.timestamp ]];
        PUT_NETWORK_U32(bytes, $bytes, timestamp);
        _printf("[client] <= TIMESTAMP = %X\n", timestamp);

        // <= TX_BACK_HASH
        var char[HASH_BYTES] tx_back_hash = [[ G(tcp).tx.back_hash ]];
        bytes = []..bytes..tx_back_hash;
        [[
            print('[client] <= TX_BACK_HASH')
            print(tostring2(G(tcp).tx.back_hash))
        ]]

        // <= TX_PAYLOAD
        var char[] tx_payload = [[ G(tcp).tx.payload ]];
        bytes = []..bytes..tx_payload;

        // <= PoS: TODO
        var u8 pos = 0xEE;
        bytes = []..bytes..[pos];
        _printf("TODO: POS generate!\n");

        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);
    end

    escape _ERR_NONE;
end

class Message10_send with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>Message10_send run;
do
    function (_uv_tcp_t& tcp)=>Message10_send run do
        this.tcp = &tcp;
    end

    ///////////////////////////////////////////////////////////////////////////
    // HEADER
    ///////////////////////////////////////////////////////////////////////////

    // <= MESSAGE
    // <= CHAIN_LEN
    // <= CHAIN_KEY
    // <= CHAIN_ZEROS
    // TODO: <= CHAIN_LIMITS
    do
        // <= MESSAGE
        var byte[] bytes = [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, 1, 0];

        // <= CHAIN_LEN
        // <= CHAIN_KEY
        // <= CHAIN_ZEROS
        do
            var char[] chain_key   = [[ G(tcp).chain.key ]];
            var int    chain_zeros = [[ G(tcp).chain.zeros ]];
            var u32    chain_len   = [[ string.len(G(tcp).chain.key) ]];
            _assert(chain_len<CHAIN_KEY_BYTES);
            bytes = []..bytes..[chain_zeros,(u8)chain_len]..chain_key;
        end

        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

        // => ACK-header
        do
            var byte[1] recv;
            var UV_Stream_Read reader =
                    UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
            do UV_Stream_ReadUntil.run(&reader, 1);
            var int ret = recv[0];

            _printf("[client] => ACK-header = %d\n", ret);
            if ret == _MESSAGE10_NOTSUB then
                escape ret;
            else
                // OK: proceed to BLOCKS
            end
        end
    end

    ///////////////////////////////////////////////////////////////////////////
    // BLOCKS
    ///////////////////////////////////////////////////////////////////////////

    loop i do
        _printf("[client] <= BLOCKS[%d]\n", i);

        // <= BLOCK_HASH
        // <= BLOCK_TXS_N
        do
            var byte[] bytes;

            // <= BLOCK_HASH
            var char[HASH_BYTES] block_hash = [[ G(tcp).block.hash ]];
            bytes = []..bytes..block_hash;

            // <= BLOCK_TXS_N
            var u32 txs_n = [[ #G(tcp).block.txs ]];
            PUT_NETWORK_U32(bytes, $bytes, txs_n);

            do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);
        end

        // => ACK-block
        do
            var byte[1] recv;
            var UV_Stream_Read reader =
                    UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
            do UV_Stream_ReadUntil.run(&reader, 1);
            var int ret = recv[0];

            _printf("[client] => ACK-block = %d\n", ret);
            if ret == _MESSAGE10_HAVE then
                break;  // found common block
            end
        end

        ///////////////////////////////////////////////////////////////////////
        // TXS
        ///////////////////////////////////////////////////////////////////////
        var u32 txs_n = [[ #G(tcp).block.txs ]];
        _printf("[client] <= %d txs\n", txs_n);
        loop j in txs_n do
            var int err = do Message10_tx_send.run(&tcp,j);
            if err != _ERR_NONE then
                escape err;
            end
        end

        // next block
        [[ G(tcp).block = assert(APP.blocks[G(tcp).block.tail_hash]) ]];
        var bool has = [[ G(tcp).block ~= nil ]];
        if not has then
            break;
        end
    end

    escape _ERR_NONE;
end

interface PeerListener with
    event int ok;
end

class PeerSend with
input:
    var PeerListener& client;

    function (PeerListener& client)=>PeerSend run;
do
    function (PeerListener& client)=>PeerSend run do
        this.client = &client;
    end
// TODO: to test multiple topology paths
//await 2s;

    var char[] ip   = [[ G(client).peer.host[1] ]];
    var int    port = [[ G(client).peer.host[2] ]];
    _printf("[client] Connecting to %s:%d.\n", (_char&&)&&ip, port);
    var UV_TCP_Client c = UV_TCP_Client.build(&ip, port);

    [[
        G(c.tcp) = {
            chain = CHAIN,
            block = BLOCK,
        }
    ]];

    var bool is_10 = [[ G(c.tcp).block~=nil and G(c.tcp).block.id=='1.0' ]];
    // ...

    var int err =
    do
        var int err_ = await c.ok;
        if err_ != _ERR_NONE then
            escape err_;
        end

        _printf("[client] Connected to %s:%d.\n", (_char&&)&&ip, port);
        watching err_ in c do
            err_ = _ERR_NONE;
            if is_10 then
                err_ = do Message10_send.run(&c.tcp);
            else
                // ...
                err_ = _ERR_MESSAGE;
            end
            escape err_;
        end
        escape err_;
// TODO: usar erro de c
        //escape _ERR_DISCONNECTED;
    end;

    _printf("[client] Disconnected from %s:%d => %d\n",
            (_char&&)&&ip, port, err);
    if err != _ERR_NONE then
        _printf("[client] error: %s\n", _uv_strerror(err));
    end
    emit client.ok => err;
    escape err;
end

class Client with
    interface PeerListener;
do
    [[
        G(this) = {
            chain = CHAIN,
            block = BLOCK,
            txs   = TXS,
        }
    ]];

    var bool is_parsed = [[ G(this).block~=nil ]];
    if not is_parsed then
        var int ms = [[ #APP.messages ]];
        if ms == 0 then
            escape -1;      // no messages
        end

        loop i in ms do
            [[
                local msg = APP.messages[@i+1]
                assert(type(msg)=='table')

                if msg.id == '1.0' then
                    assert(type(msg.chain)=='table')

                    G(this).chain = APP.chains.parse(msg.chain)

                    local head_hash = G(this).chain.head_hash
                    local txs_back  = APP.blocks[head_hash].txs

                    G(this).txs = {
                        {
                            bytes     = string.len(msg.payload),
                            payload   = msg.payload,
                            hash      = nil,
                            back_hash = txs_back[#txs_back],
                        },
                    }
                    G(this).block = {
                        id        = msg.id,
                        txs       = { },
                        hash      = nil,
                        up_hash   = nil,
                        tail_hash = nil,
                    }
                else
                    error 'message not supported'
                end
            ]];

            var bool is_10 = [[ G(this).block~=nil ]];
            if is_10 then
                var int txs_n = [[ #G(this).txs ]];
                loop i in txs_n do
                    [[ G(this).tx = G(this).txs[@i+1] ]];
                    do Message10_parse_tx with
                        this.client = &outer;
                    end;
                    do Message10_parse_block with
                        this.client = &outer;
                    end;
                end
            else
                _assert(0);  // message not supported
            end
        end
    end

    var int ps = [[#APP.client.peers]];
    var int ps_ok = 0;
    loop i in ps do
        [[
            G(this).peer = APP.client.peers[@(i+1)]
            ok = false
            for _, chain in pairs(G(this).peer.chains) do
                if chain.key==G(this).chain.key and
                   chain.zeros<=G(this).chain.zeros then
                    ok = true
                    break
                end
            end
        ]];
        var bool ok_ = [[ ok ]];
        if ok_ then
            ps_ok = ps_ok + 1;
            [[
                CHAIN = G(this).chain
                BLOCK = G(this).block
                TXS   = G(this).txs
            ]];
            var PeerSend&&? p = spawn PeerSend.run(&this);
            _assert(p! != null);
        end
    end
    _printf("[client] Broadcasting messages to %d peer(s)...\n", ps_ok);
    loop i in ps_ok do
        var int err = await this.ok;
        _printf("[client] peer %d\n", err);
    end
    _printf("[client] Broadcasts OK!\n");

    if not is_parsed then
        [[ print(APP.chains.tostring(G(this).chain)) ]];
    end

    escape _ERR_NONE;   // trasmitted messages
end

#endif
