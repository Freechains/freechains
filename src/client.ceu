#ifndef _CLIENT_CEU
#define _CLIENT_CEU

code/await Send_10 (var& UV_Stream tcp) -> none
    // [[ ARGS = { chain={...} } ]]
    throws Exception.Uv, Exception.Freechains.Malformed
do
    [[
        THIS = {
            chain = ARGS.chain,
        }
    ]]

    ///////////////////////////////////////////////////////////////////////////
    // HEADER
    ///////////////////////////////////////////////////////////////////////////

    // <= MESSAGE
    // <= SERVER_PORT
    // <= CHAIN_KEY_LEN
    // <= CHAIN_KEY_STR
    // <= CHAIN_ZEROS
    // <= CHAIN_LENGTH
    // <= CHAIN_HEAD_HASH
    do/_
        tcp.buffer = [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, 0x01, 0x00];
        do
            var u16    port    = [[ FC.daemon.port ]];
            var u8     key_len = [[ string.len(THIS.chain.key) ]];
            var[] byte key_str = [] .. [[ THIS.chain.key ]];
            var u8     zeros   = [[ THIS.chain.zeros ]];
            var u64    length  = [[ THIS.chain.head.length ]];
            _ceu_assert(key_len<CHAIN_KEY_BYTES, "bug found");
            tcp.buffer = tcp.buffer .. [0,0] .. [key_len as byte] .. key_str .. [zeros as byte] .. [0,0,0,0,0,0,0,0];
            PUT_HTOBE16(tcp.buffer, 4, port);
            PUT_HTOBE64(tcp.buffer, $tcp.buffer-sizeof(u64), length);
        end
        tcp.buffer = tcp.buffer .. [[ THIS.chain.head.hash ]];

        await UV_Stream_Write_N(&tcp,_);

        // => ACK-header
        do/_
            await UV_Stream_Read_N(&tcp, 1);
            var byte ret = tcp.buffer[0];
            $tcp.buffer = $tcp.buffer - 1;

            _dbg_tcp(3, &&tcp.handle, "client", "=> ACK-header = %d", ret);

            if ret == {MESSAGE10_OK} then
                // OK: proceed to BLOCKS
            else/if ret=={MESSAGE10_NOTSUB} or ret=={MESSAGE10_HAVE} then
                escape;
            else
                var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
                throw e;
            end
        end
    end

    ///////////////////////////////////////////////////////////////////////////
    // BLOCKS
    // - first, reads hashes from head -> genesis until finds common block
    // - then, writes from common.nxt -> head
    ///////////////////////////////////////////////////////////////////////////

    // TODO: PoS: before/after each block? once per block?

    loop do
        // => HASH
        await UV_Stream_Read_N(&tcp, HASH_BYTES);
        do
            var[] byte str = [] .. [[ FC.tostring(@tcp.buffer) ]] .. [0];
            _dbg_tcp(3, &&tcp.handle, "client", "=> BLOCK_HASH? : %s", &&str[0]);
        end
        [[
            THIS.cur = FC.chain_block_get(THIS.chain,@tcp.buffer)
        ]]
        var bool has = [[ THIS.cur~=nil ]];
        var int ret = do
            if has then
                escape {MESSAGE10_HAVE};
            else
                escape {MESSAGE10_OK};
            end
        end;
        tcp.buffer = [ret];
        // <= ACK-HASH
        _dbg_tcp(3, &&tcp.handle, "client", "<= ACK-BLOCK_HASH? : %d", ret);
        await UV_Stream_Write_N(&tcp,_);
        if has then
            [[
                THIS.common = THIS.cur
            ]]
            break;
        end
    end

    [[ THIS.cur = THIS.common.nxt ]];

    var int i;
    loop i do
        var bool should_stop = [[ THIS.cur==nil ]];
        if should_stop then
            break;
        end

        // <= BLOCK_HASH
        // <= TIMESTAMP + NONCE
        // <= PUBLICATION_HASH (maybe removed)
        // <= PRV_HASH
        do
            tcp.buffer = [] .. [[ THIS.cur.hash ]] .. 
                               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                               [[ (THIS.cur.pub and THIS.cur.pub.hash) or string.rep('\0',@HASH_BYTES) ]] ..
                               [[ THIS.cur.prv.hash ]];
            do
                var u64 timestamp = [[ THIS.cur.timestamp ]];
                var u64 nonce     = [[ THIS.cur.nonce     ]];
                PUT_HTOBE64(tcp.buffer, HASH_BYTES, timestamp);
                PUT_HTOBE64(tcp.buffer, HASH_BYTES+sizeof(u64), nonce);

                var[] byte str = [] .. [[ FC.tostring(THIS.cur.hash) ]] .. [0];
                _dbg_tcp(3, &&tcp.handle, "client", "<= BLOCK_HASH : %s", &&str[0]);
                _dbg_tcp(3, &&tcp.handle, "client", "<= TIMESTAMP/NONCE : %ld %ld", timestamp,nonce);
            end

            await UV_Stream_Write_N(&tcp,_);
        end

        // => ACK-PUBLICATION-HASH
        var bool send_pub = do
            await UV_Stream_Read_N(&tcp, 1);
            var byte ret = tcp.buffer[0];
            if ret == {MESSAGE10_HAVE} then
                escape false;
            else/if ret == {MESSAGE10_OK} then
                escape true;
            else
                var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
                throw e;
            end
        end;
        if send_pub then
            tcp.buffer = [] .. [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                               [0,0,0,0];

            var bool is_removal = [[ THIS.cur.pub.removal~=nil ]];
            if is_removal then
                tcp.buffer = tcp.buffer .. [[ THIS.cur.pub.removal.hash ]];
            else
                tcp.buffer = tcp.buffer .. [[ THIS.cur.pub.payload ]];
            end

            var u64 timestamp   = [[ THIS.cur.pub.timestamp ]];
            var u64 nonce       = [[ THIS.cur.pub.nonce     ]];
            var u32 payload_len = [[ (@(is_removal) and 0) or string.len(THIS.cur.pub.payload) ]];
            PUT_HTOBE64(tcp.buffer, 0, timestamp);
            PUT_HTOBE64(tcp.buffer, sizeof(u64), nonce);
            PUT_HTOBE32(tcp.buffer, 2*sizeof(u64), payload_len);

            await UV_Stream_Write_N(&tcp,_);
        end

/*
        // => ACK-BLOCK
        // TODO: good place for PoS
        do
            await UV_Stream_Read_N(&tcp, 1);
            var byte ret = tcp.buffer[0];
            $tcp.buffer = $tcp.buffer - 1;

            //_printf("[client] => ACK-tx = %d\n", ret);
            if ret != {MESSAGE10_OK} then
                var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
                throw e;
            end
        end
*/

        [[ THIS.cur = THIS.cur.nxt ]];
    end
end

code/await Peer_10 (none) -> none
    // [[ ARGS = { peer={...}, chain={...} } ]]
do
    [[
        THIS = {
            peer  = ARGS.peer,
            chain = ARGS.chain,
        }
    ]];

{CLIENTS_ALIVE++;}
do finalize with
    {CLIENTS_ALIVE--;}
end

    var[] byte ip   = [] .. [[ THIS.peer.address ]] .. [0];
    var   int  port = [[ THIS.peer.port ]];
    _dbg(2, "client:%p | connecting to %s:%d", {&_ceu_mem}, &&ip[0], port);

    var Exception.Uv? e1;
    var Exception.Freechains? e2;
    catch e1,e2 do
        var& UV_TCP_Connect c = spawn UV_TCP_Connect(&&ip[0], port, _);

        do finalize with
            _dbg(2, "client:%p | disconnected from %s:%d", {&_ceu_mem}, &&ip[0], port);
        end

        await c.ok;
        _dbg(2, "client:%p | connected to %s:%d", {&_ceu_mem}, &&ip[0], port);

        [[ ARGS = THIS ]]
        await Send_10(&c.stream);
    end
    if e1? then
        _dbg(3, "client:%p | %s", {&_ceu_mem}, e1!.message);
    else/if e2? then
        _dbg(3, "client:%p | %s", {&_ceu_mem}, e2!.message);
    end
end

code/await Client_10 (var& UV_TCP_Server_Data shared) -> none
    throws Exception.Freechains
    // [[ ARGS = { chain={...} } ]]
do
    [[
        THIS = {
            chain = ARGS.chain,
            peers = CFG.chains[ARGS.chain.key].peers
        }
    ]];

    [[ ARGS = { chain=THIS.chain } ]]
    var bool should_write = [[ not CFG.no_persistency ]];
    if should_write then
        await FS_write_10();
    end

    [[ ARGS = { chain=THIS.chain } ]]
    CHAIN_LOCK(l, shared, "lock_send");

    var int ps = [[ (THIS.peers and #THIS.peers) or 0 ]];
    var int i;
    pool[] Peer_10 peers;
    loop i in [1 -> ps] do
        var bool min_zeros = [[ THIS.chain.zeros >= (THIS.peers[@i].zeros or 0) ]];
        if min_zeros then
            [[
                ARGS = {
                    peer  = THIS.peers[@i],
                    chain = THIS.chain,
                }
            ]]
            var&? Peer_10 p = spawn Peer_10() in peers;
            _ceu_assert(p?, "bug found");
        end
    end
    var[] byte id = [] .. [[ THIS.chain.id ]] .. [0];
    _dbg(3, "client:%p | broadcasting %s messages to (max) %d peer(s)", {&_ceu_mem}, &&id[0], ps);
    do finalize with
        _dbg(3, "client:%p | broadcasts OK", {&_ceu_mem});
    end
    var&? Peer_10 p;
    loop p in peers do
        await p;
        //_dbg(0, "client:%p | peer %d", {&_ceu_mem}, err);
    end
end

code/await Client (var& UV_TCP_Server_Data shared) -> none
    // [[ ARGS = { message={...} } ]]
    throws Exception.Freechains
do
    // client mode: terminates

    [[
        chain = ARGS.message.chain
        chain = assert(FC.chains[chain.key][chain.zeros], 'not subscribed to |'..chain.key..'|'..chain.zeros..'|')

        if CFG.deterministic then
            now = 0
        else
            now = os.time() * 1000000   -- in ms since the epoch
        end

        THIS = {
            now = now,
            pub = {
                chain     = chain,
                timestamp = ARGS.message.timestamp or now,
                nonce     = ARGS.message.nonce or 0,
                payload   = ARGS.message.payload,
                removal   = ARGS.message.removal and assert(FC.chain_block_get(chain, ARGS.message.removal)),
                hash      = nil,
            },
        }
        ARGS = THIS
    ]]
    await Publication_New();
    [[
        if THIS.pub.removal then
            THIS.pub.removal.pub = nil
        end
    ]]
    do
        [[ ARGS = { chain=THIS.pub.chain } ]]
        CHAIN_LOCK(l, shared, "lock_write");
        [[
            THIS.block = {
                timestamp   = THIS.now,
                nonce       = 0,
                chain       = THIS.pub.chain,
                pub         = THIS.pub,
                hash        = nil,
                prv         = nil,
                nxt         = nil,
                length      = nil,
            }
            ARGS = THIS
        ]]
        await Block_Hash_Link();
    end
    do
        [[
            THIS = { chain=THIS.block.chain }
            ARGS = THIS
        ]];
        await Client_10(&shared);
    end
    [[
        ARGS = THIS
    ]]
    emit shared.ok_client({MESSAGE10}, {MESSAGE10_OK});
end

#endif
