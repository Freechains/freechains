#ifndef _CLIENT_CEU
#define _CLIENT_CEU

code/await Peer_10 (var& UV_TCP_Server_Data shared) -> none
    // [[ ARGS = { peer={...}, chain={...} } ]]
do
    [[
        THIS = {
            peer  = ARGS.peer,
            chain = ARGS.chain,
        }
    ]];

    var[] byte ip   = [] .. [[ THIS.peer.address ]] .. [0];
    var   int  port = [[ THIS.peer.port ]];
    _dbg(2, "client:%p | connecting to %s:%d", {&_ceu_mem}, &&ip[0], port);

    var Exception.Uv? e1;
    var Exception.Freechains? e2;
    catch e1,e2 do
        var& UV_TCP_Connect c = spawn UV_TCP_Connect(&&ip[0], port, _);

        do finalize with
            _dbg(2, "client:%p | disconnected from %s:%d", {&_ceu_mem}, &&ip[0], port);
        end

        await c.ok;
        _dbg(2, "client:%p | connected to %s:%d", {&_ceu_mem}, &&ip[0], port);

        [[ ARGS = { chain=THIS.chain } ]]
        await Send_10_Header(&c.stream);

        [[ ARGS = { chain=THIS.chain } ]]
        await Send_10_Nodes(&c.stream);

        [[ ARGS = { chain=THIS.chain } ]]
        await Recv_10_Nodes(&shared, &c.stream);
    end
    if e1? then
        _dbg(3, "client:%p | %s", {&_ceu_mem}, e1!.message);
    else/if e2? then
        _dbg(3, "client:%p | %s", {&_ceu_mem}, e2!.message);
    end
end

code/await Client_10 (var& UV_TCP_Server_Data shared) -> none
    throws Exception.Freechains
    // [[ ARGS = { chain={...} } ]]
do
    [[
        THIS = {
            chain = ARGS.chain,
            peers = CFG.chains[ARGS.chain.key].peers
        }
    ]];

    var int ps = [[ (THIS.peers and #THIS.peers) or 0 ]];
    var int i;
    pool[] Peer_10 peers;
    loop i in [1 -> ps] do
        var bool min_zeros = [[ THIS.chain.zeros >= (THIS.peers[@i].zeros or 0) ]];
        if min_zeros then
            [[
                ARGS = {
                    peer  = THIS.peers[@i],
                    chain = THIS.chain,
                }
            ]]
            var&? Peer_10 p = spawn Peer_10(&shared) in peers;
            _ceu_assert(p?, "bug found");
        end
    end
    var[] byte id = [] .. [[ THIS.chain.id ]] .. [0];
    _dbg(3, "client:%p | broadcasting %s messages to (max) %d peer(s)", {&_ceu_mem}, &&id[0], ps);
    do finalize with
        _dbg(3, "client:%p | broadcasts OK", {&_ceu_mem});
    end

    var&? Peer_10 p;
    loop p in peers do
        await p;
        //_dbg(0, "client:%p | peer %d", {&_ceu_mem}, err);
    end
end

code/await Client (var& UV_TCP_Server_Data shared) -> none
    // [[ ARGS = { message={...} } ]]
    throws Exception.Freechains
do
    // client mode: terminates

    [[
        chain = ARGS.message.chain
        chain = assert(FC.chains[chain.key][chain.zeros], 'not subscribed to |'..chain.key..'|'..chain.zeros..'|')

        if CFG.deterministic then
            now = 0
        else
            now = os.time() * 1000000   -- in ms since the epoch
        end

        THIS = {
            now = now,
            pub = {
                chain     = chain,
                timestamp = ARGS.message.timestamp or now,
                nonce     = ARGS.message.nonce or 0,
                payload   = ARGS.message.payload,
                removal   = ARGS.message.removal and assert(FC.chain_node_get(chain, ARGS.message.removal)),
                hash      = nil,
            },
        }
        ARGS = THIS
    ]]
    await Publication_New();
    [[
        if THIS.pub.removal then
            THIS.pub.removal.pub = nil
        end
    ]]
    do
        [[ ARGS = { chain=THIS.pub.chain } ]]
        //CHAIN_LOCK(l, shared, "lock_write");
        [[
            THIS.node = {
                chain     = THIS.pub.chain,
                timestamp = THIS.now,
                nonce     = 0,
                pub       = THIS.pub,
            }
            FC.children(THIS.node, THIS.pub.chain.head)

            ARGS = THIS
        ]]
        await Node_Hash();
        [[
            FC.head_new(THIS.node)
        ]]
    end
    par/and do
        loop do
            await shared.chain_has_been_transmitted;
            var bool same = [[ ARGS.chain == THIS.node.chain ]];
            if same then
                break;
            end
        end
    with
        [[ ARGS = { chain=THIS.node.chain } ]];
        emit shared.chain_has_changed;
    end
end

#endif
