#ifndef _CLIENT_CEU
#define _CLIENT_CEU

class Message10_parse_tx with
    // [[ ARGS = { block=?, tx=? } ]]
do
    [[
        G(this) = {tx = ARGS.tx}
    ]];

    // hash[TIMESTAMP..TX_BACK_HASH..TX_PAYLOAD]
    var char[] tx_back_hash = [[ ARGS.tx.back_hash ]];
    var char[] tx_payload   = [[ ARGS.tx.payload   ]];
    var byte[] plain = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]..
                        tx_back_hash..tx_payload;

    // show async/thread progress
    var int ms = 0;
#if 1
    spawn do
        every 100ms do
            ms = ms + 100;
            _printf(".");
            _fflush(_stdout);
        end
    end
#endif

    // calculate nonce for the leading zeros
    var byte[HASH_BYTES] tx_hash;
    var u8 zeros_wanted = [[ APP.chains[ARGS.block.chain_id].zeros ]];
#if 1
    async/thread (plain,tx_hash,zeros_wanted)
#endif
    do
        var int len;
        atomic do
            len = $plain;
        end
        _assert(len <= 1024);

        var _byte[1024] plain2 = [];
        _memcpy(plain2, (_byte&&)&&plain, len*sizeof(byte));;

        var _byte[HASH_BYTES] tx_hash2 = [];

        var int zeros_found = 0;
        var u32 n = do
            var u32 n_ = 0;
            loop b00 in 256 do loop b01 in 256 do loop b02 in 256 do loop b03 in 256 do
            loop b04 in 256 do loop b05 in 256 do loop b06 in 256 do loop b07 in 256 do
            loop b08 in 256 do loop b09 in 256 do loop b10 in 256 do loop b11 in 256 do
            loop b12 in 256 do loop b13 in 256 do loop b14 in 256 do loop b15 in 256 do
                n_ = n_ + 1;
                plain2[ 0]=b00; plain2[ 1]=b01; plain2[ 2]=b02; plain2[ 3]=b03;
                plain2[ 4]=b04; plain2[ 5]=b05; plain2[ 6]=b06; plain2[ 7]=b07;
                plain2[ 8]=b08; plain2[ 9]=b09; plain2[10]=b10; plain2[11]=b11;
                plain2[12]=b12; plain2[13]=b13; plain2[14]=b14; plain2[15]=b15;
                _crypto_generichash(tx_hash2, HASH_BYTES,
                                    plain2, len,
                                    null, 0);
                zeros_found = _leading_zeros(tx_hash2, HASH_BYTES);
                if zeros_found >= zeros_wanted then
                    atomic do
                        _ceu_vector_copy_buffer(&&plain, 0,
                                                plain2, len*sizeof(byte), 0);
                        $tx_hash := HASH_BYTES;
                        _ceu_vector_copy_buffer(&&tx_hash, 0,
                                                tx_hash2, HASH_BYTES*sizeof(byte), 0);
                    end
                    escape n_;
                end
            end end end end
            end end end end
            end end end end
            end end end end
            escape 0;
        end;
        _dbg(0, "client: POW rounds: %d\n", n);
    end

    [[ nonce = {} ]];
    loop i in NONCE_BYTES do
        [[ nonce[@(i+1)] = string.char(@(plain[i])) ]];
    end

    [[
        -- i'm in the database
        G(this).tx.nonce = table.concat(nonce)
        G(this).tx.hash  = @tx_hash;
        --print('\n[client] <= TX_HASH', string.len(G(this).tx.hash))
        --print('nonce', tostring2(G(this).tx.nonce))
        --print('<X<<', tostring2(G(this).tx.nonce), tostring2(@tx_back_hash), tostring2(G(this).tx.payload))
        --print('<X<<', '\n'..tostring2(@plain,true))
    ]];
    //_printf("[client] TX_HASH = %dms\n", ms);

    escape _ERR_NONE;
end

class Message10_block_parse_head with
    // [[ ARGS = { block=? } ]]
do
    // <= BLOCK_HASH
    //  - merkle tree of all TX_HASH

    var byte[] plain;
    var byte[HASH_BYTES] block_hash;
    $block_hash := HASH_BYTES;

    // TODO: should be merkle tree and not hash(concat)
    var int n = [[ #ARGS.block.txs ]]; // TODO: assert ARGS.block.chain.limits.block
    loop i in n do
        var char[HASH_BYTES] tx_hash = [[ ARGS.block.txs[@i+1] ]];
        plain = []..plain..tx_hash;
    end

    _crypto_generichash((_byte&&)&&block_hash, HASH_BYTES,
                        (_byte&&)&&plain, $plain,
                        null, 0);

    [[
        block = ARGS.block
        block.hash  = @block_hash
        APP.blocks[block.hash] = block

        --print('[client] <= BLOCK_HASH', string.len(block.hash))
        --print(tostring2(block.hash))

        -- i'm the head now: relink, set new head
        chain = APP.chains[ARGS.block.chain_id]
        old   = APP.blocks[chain.head_hash]
        old.up_hash     = block.hash    -- prv->up=me
        block.tail_hash = old.hash      -- me->tail=prv
        chain.head_hash = block.hash
    ]]

    escape _ERR_NONE;
end

class Message10_tx_send with
    var _uv_tcp_t& tcp;
    var int        i;
    function (_uv_tcp_t& tcp, int i)=>Message10_tx_send run;
do
    function (_uv_tcp_t& tcp, int i)=>Message10_tx_send run do
        this.tcp = &tcp;
        this.i   = i;
    end

    // <= TX_HASH
    // <= TX_LEN
    do
        [[
            tx_hash   = G(tcp).block.txs[@this.i+1]
            G(tcp).tx = assert(APP.txs[tx_hash])
            --print('[client] <= txs['..(@this.i+1)..']', G(tcp).tx.bytes)
            --print(tostring2(G(tcp).tx.hash))
        ]];
        var u32    payload_bytes = [[ G(tcp).tx.bytes ]];
        var char[] bytes         = [[ G(tcp).tx.hash ]];
        PUT_NETWORK_U32(bytes, HASH_BYTES, payload_bytes);
        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

        // => ACK-tx
        do
            var byte[1] recv;
            var UV_Stream_Read reader =
                    UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
            do UV_Stream_ReadUntil.run(&reader, 1);
            var int err = recv[0];

            //_printf("[client] => ACK-tx = %d\n", err);
            if err == _MESSAGE10_HAVE then
                escape _ERR_NONE;   // next TX (not an error)
            end
        end
    end

    // OK: complete TX
    //_printf("[client] <= complete...\n");
    do
        var byte[] bytes;

        // <= NONCE
        do
            var char[] nonce = [[ G(tcp).tx.nonce ]];
            bytes = []..bytes..nonce;
            //_printf("[client] <= TIMESTAMP = %X\n", timestamp);
        end

        // <= TX_BACK_HASH
        var char[HASH_BYTES] tx_back_hash = [[ G(tcp).tx.back_hash ]];
        bytes = []..bytes..tx_back_hash;
        [[
            --print('[client] <= TX_BACK_HASH')
            --print(tostring2(G(tcp).tx.back_hash))
        ]]

        // <= TX_PAYLOAD
        var char[] tx_payload = [[ G(tcp).tx.payload ]];
        bytes = []..bytes..tx_payload;

        // <= PoS: TODO
        var u8 pos = 0xEE;
        bytes = []..bytes..[pos];
        //_printf("TODO: POS generate!\n");

        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);
    end

    escape _ERR_NONE;
end

class Message10_send with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>Message10_send run;
do
    function (_uv_tcp_t& tcp)=>Message10_send run do
        this.tcp = &tcp;
    end

    ///////////////////////////////////////////////////////////////////////////
    // HEADER
    ///////////////////////////////////////////////////////////////////////////

    // <= MESSAGE
    // <= CHAIN_LEN
    // <= CHAIN_KEY
    // <= CHAIN_ZEROS
    // TODO: <= CHAIN_LIMITS
    do
        // <= MESSAGE
        var byte[] bytes = [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, 1, 0];

        // <= CHAIN_LEN
        // <= CHAIN_KEY
        // <= CHAIN_ZEROS
        do
            [[ chain = APP.chains[G(tcp).block.chain_id] ]];
            var char[] chain_key   = [[ chain.key ]];
            var int    chain_zeros = [[ chain.zeros ]];
            var u32    chain_len   = [[ string.len(chain.key) ]];
            _assert(chain_len<CHAIN_KEY_BYTES);
            bytes = []..bytes..[chain_zeros,(u8)chain_len]..chain_key;
        end

        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

        // => ACK-header
        do
            var byte[1] recv;
            var UV_Stream_Read reader =
                    UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
            do UV_Stream_ReadUntil.run(&reader, 1);
            var int ret = recv[0];

            _dbg_tcp(0, &&this.tcp, "client", "=> ACK-header = %d", ret);

            if ret == _MESSAGE10_NOTSUB then
                escape ret;
            else
                // OK: proceed to BLOCKS
            end
        end
    end

    ///////////////////////////////////////////////////////////////////////////
    // BLOCKS
    ///////////////////////////////////////////////////////////////////////////

    loop i do
        // <= BLOCK_HASH
        // <= BLOCK_TXS_N
        var int port = _ceu_uv_tcp_getpeerport(&&this.tcp);
        do
            var byte[] bytes;

            // <= BLOCK_HASH
            var char[HASH_BYTES] block_hash = [[ G(tcp).block.hash ]];
            bytes = []..bytes..block_hash;
            var char[] str = [[ tostring2(G(tcp).block.hash) ]];
            _dbg_tcp(0, &&this.tcp, "client", "<= BLOCKS[%d] : %s", i, (_char&&)&&str);

            // <= BLOCK_TXS_N
            var u32 txs_n = [[ #G(tcp).block.txs ]];
            PUT_NETWORK_U32(bytes, $bytes, txs_n);

            do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);
        end

        // => ACK-block
        do
            var byte[1] recv;
            var UV_Stream_Read reader =
                    UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&recv);
            do UV_Stream_ReadUntil.run(&reader, 1);
            var int ret = recv[0];

            _dbg_tcp(0, &&this.tcp, "client", "=> ACK-block = %d", ret);

            if ret == _MESSAGE10_HAVE then
                break;  // found common block
            end
        end

        ///////////////////////////////////////////////////////////////////////
        // TXS
        ///////////////////////////////////////////////////////////////////////
        var u32 txs_n = [[ #G(tcp).block.txs ]];
        _dbg_tcp(0, &&tcp, "client", "<= %d txs", txs_n);
        loop j in txs_n do
            var int err = do Message10_tx_send.run(&tcp,j);
            if err != _ERR_NONE then
                escape err;
            end
        end

        // next block
        var bool has = [[ G(tcp).block.tail_hash ~= nil ]];
        if not has then
            escape _ERR_REMOTE_BUG_OR_MALICIOUS; // "genesis" always HAVE
        end
        [[ G(tcp).block = assert(APP.blocks[G(tcp).block.tail_hash]) ]];
    end

    escape _ERR_NONE;
end

interface PeerListener with
    event int ok;
end

class PeerSend with
    // [[ ARGS = { peer=?, block=? } ]]
input:
    var PeerListener& client;

    function (PeerListener& client)=>PeerSend run;
do
    function (PeerListener& client)=>PeerSend run do
        this.client = &client;
    end

    var char[] ip   = [[ ARGS.peer.host[1] ]];
    var int    port = [[ ARGS.peer.host[2] ]];
    _dbg(2, "client | connecting to %s:%d", (_char&&)&&ip, port);
    var UV_TCP_Client c = UV_TCP_Client.build(&ip, port);

    [[
        G(c.tcp) = {
            block = ARGS.block,
        }
    ]];

    var bool is_10 = [[ G(c.tcp).block~=nil and G(c.tcp).block.id=='1.0' ]];
    // ...

    var int err =
    do
        var int err_ = await c.ok;
        if err_ != _ERR_NONE then
            escape err_;
        end

        _dbg(2, "client | connected to %s:%d", (_char&&)&&ip, port);
        watching err_ in c do
            err_ = _ERR_NONE;
            if is_10 then
                err_ = do Message10_send.run(&c.tcp);
            else
                // ...
                err_ = _ERR_MESSAGE;
            end
            escape err_;
        end
        escape err_;
// TODO: usar erro de c
        //escape _ERR_DISCONNECTED;
    end;

    _dbg(2, "client | disconnected from %s:%d", (_char&&)&&ip, port);
    if err != _ERR_NONE then
        _dbg(2, "client | %s", _uv_strerror(err));
    end
    emit client.ok => err;
    escape err;
end

class Client with
    interface PeerListener;
    // [[ ARGS = { chain=?, block=? } ]]
do
    [[ G(this) = ARGS ]];

    // LOCK: only one "send" per chain
    do
        var bool is_locked = [[ G(this).chain.send_is_locked ]];
        if is_locked then
            loop do
                par/or do
                    await global:send_chain_unlocked;
                with
                    await 1s;
                end
                is_locked = [[ G(this).chain.send_is_locked ]];
                if not is_locked then
                    break;
                end
            end
        end
        [[ G(this).chain.send_is_locked = true ]];
    end

// TODO: primitive "lock"
do
#if 0
    lock X do
        finalize with
            ...
        end
        ...
    end
#endif

    finalize with
        //var bool is_locked = [[ G(this).chain.send_is_locked ]];
        //_assert(not is_locked);
        [[ G(this).chain.send_is_locked = false ]];
    end

    var int ps = [[#APP.client.peers]];
    var int ps_ok = 0;
    loop i in ps do
        [[
            peer = APP.client.peers[@(i+1)]
            ok = false
            for _, chain in pairs(peer.chains) do
                if chain.key==G(this).chain.key and
                   chain.zeros<=G(this).chain.zeros then
                    ok = true
                    break
                end
            end
        ]];
        var bool ok_ = [[ ok ]];
        if ok_ then
            ps_ok = ps_ok + 1;
            [[
                ARGS = {
                    peer  = peer,
                    block = G(this).block,
                }
            ]];
            var PeerSend&&? p = spawn PeerSend.run(&this);
            _assert(p! != null);
        end
    end
    _dbg(0, "client | broadcasting messages to %d peer(s)", ps_ok);
    loop i in ps_ok do
        var int err = await this.ok;
        _dbg(0, "client | peer %d", err);
    end
    _dbg(0, "client | broadcasts OK");

    // UNLOCK "send"
    [[ G(this).chain.send_is_locked = false ]];
end
    emit global:send_chain_unlocked;

    escape _ERR_NONE;   // trasmitted messages
end

class Client10 with
    // [[ ARGS = { block=? } ]]
do
    [[
        ARGS = {
            chain = assert(APP.chains[ARGS.block.chain_id]),
            block = ARGS.block,
        }
    ]];
    do Client;
end

class ClientMessages with
do
    var int ms = [[ #APP.messages ]];
    if ms == 0 then
        await FOREVER;  // server mode: don't let application terminate
    end

    // client mode: terminates

    [[
        G(this) = {
            id = APP.messages[1].id,

            -- id = 1.0
            block = {
                id        = nil,
                chain_id  = nil,
                txs       = { },
                hash      = nil,
                up_hash   = nil,
                tail_hash = nil,
            },
        }
    ]]
    finalize with
        [[ APP.messages = {} ]];
    end

    var bool is_10 = [[ G(this).id=='1.0' ]];

    loop i in ms do
        [[
            msg = APP.messages[@i+1]
            assert(type(msg)=='table')
            assert(msg.id == G(this).id)    -- all must be the same
        ]];

        if is_10 then
            [[
                block = G(this).block
                block.id = '1.0'

                assert(type(msg.chain)=='table')

                chain = GG.chain_parse(msg.chain)
                if (@i) == 0 then
                    block.chain_id = chain.id
                else
                    assert(chain.id == block.chain_id)
                end

                head_hash = chain.head_hash
                txs_back  = APP.blocks[head_hash].txs

--msg.payload = string.sub(msg.payload,1,3)..string.sub(os.time(),6)
                G(this).tx = {
                    bytes     = string.len(msg.payload),
                    payload   = msg.payload,
                    hash      = nil,
                    back_hash = txs_back[#txs_back],
                }
                ARGS = { block=block, tx=G(this).tx }
            ]];
            do Message10_parse_tx;
            [[
                G(this).block.txs[@i+1] = G(this).tx.hash
                APP.txs[G(this).tx.hash] = G(this).tx
            ]];
        end
    end

    if is_10 then
        [[ ARGS = { block=G(this).block } ]];
        do Message10_block_parse_head;
        do Client10;
    else
        _assert(0);  // message not supported
    end
end

#endif
