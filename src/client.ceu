#ifndef _CLIENT_CEU
#define _CLIENT_CEU

interface Message with
    var byte[] bytes;
    var u32[]  offs;
    var int    err;
end

class Message_0_0_prepare with
    interface Message;
    var int err = _ERR_NONE;
do
    // => MESSAGE
    do
        var int major = [[ MSG.id_t.major ]];
        var int minor = [[ MSG.id_t.minor ]];
        bytes = []..bytes..[MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, major, minor];
    end

    // => BC_ZEROS
    // => BC_SIGNED?
    // => BC_LEN
    // => BC_DATA
    do
        var int bc_zeros = [[ MSG.bc_zeros ]];
        _assert(bc_zeros>=0 and bc_zeros<256);
        bytes = []..bytes..[bc_zeros];

        var bool bc_signed = [[ MSG.bc_signed ]];
        var int  bc_len    = [[ MSG.bc_len    ]];
        _assert(bc_len>=0 and bc_len<256);
        var u8 bc = (bc_len | (bc_signed<<7));
        bytes = []..bytes..[bc];

        if bc_len > 0 then
            var char[] bc_data = [[ MSG.bc_data ]];
            bytes = []..bytes..bc_data;
        end
    end

    // => PAYLOAD_HASH
    do
        loop i in HASH_BYTES do
            if i==0 or i==HASH_BYTES-1 then
                bytes = []..bytes..[0xEE];  // TODO
            else
                bytes = []..bytes..[0xFF];  // TODO
            end
        end
    end


    offs = []..offs..[$bytes];

    //////////////////////////////////////////////////////////////////////////

    // => PoW
    do
        var u32 pow = 0xEEFFFFEE;       // TODO
        PUT_NETWORK_U32(bytes, pow);
    end

    // => PoS
    do
        var u8 pos = 0xEE;              // TODO
        bytes = []..bytes..[pos];
    end

    // => BACK_HASH
    do
        loop i in HASH_BYTES do
            if i==0 or i==HASH_BYTES-1 then
                bytes = []..bytes..[0xEE];  // TODO
            else
                bytes = []..bytes..[0xFF];  // TODO
            end
        end
    end

    // => TAIL_HASH
    do
        loop i in HASH_BYTES do
            if i==0 or i==HASH_BYTES-1 then
                bytes = []..bytes..[0xEE];  // TODO
            else
                bytes = []..bytes..[0xFF];  // TODO
            end
        end
    end

    // => PAYLOAD_LEN
    // => PAYLOAD
    var char[] payload = [[ MSG.payload ]];
    PUT_NETWORK_U32(bytes, $payload);
    bytes = []..bytes..payload;

    offs = []..offs..[$bytes];

    this.err = _ERR_NONE;
    await FOREVER;
end

interface PeerListener with
    event int ok;
end

class PeerSend with
input:
    var int peer_i;
    var Message&      message;
    var PeerListener& listener;

    function (int i, Message& message, PeerListener& listener)=>PeerSend build;
do
    function (int i, Message& message, PeerListener& listener)=>PeerSend build do
        this.peer_i   = i;
        this.message  = &message;
        this.listener = &listener;
    end

    var char[] ip   = [[ APP.client.peers[@this.peer_i][1] ]];
    var int    port = [[ APP.client.peers[@this.peer_i][2] ]];
    _printf("[client] Connecting to %s:%d.\n", (_char&&)&&ip, port);
    var UV_TCP_Client c = UV_TCP_Client.build(&ip, port);
    var int status = await c.ok;

    if status == 0 then
        _printf("[client] Connected to %s:%d.\n", (_char&&)&&ip, port);
        watching c do
            var u32 starting = 0;
            loop i in $this.message.offs do
                // => offs[i]
                var u32 excluding = this.message.offs[i];
                do UV_Stream_Write.build2(&_UV_STREAM_ALIAS(c.tcp),
                                          &this.message.bytes,
                                          starting, excluding);

                // <= OK?
                var int ok = 0;
                do
                    var byte[] recv;
                    var UV_Stream_Read r = UV_Stream_Read.build(&_UV_STREAM_ALIAS(c.tcp),&recv);
                    AWAIT_UNTIL(r,1);
                    _assert(r.next >= 1);
                    if r.next > 1 then
                        escape _ERR_EXTRA_BYTES;
                    end
                    ok = recv[0];
                end
                starting = excluding;
            end
        end
        escape _ERR_NONE;
    end

    _printf("[client] Diconnected from %s:%d.\n", (_char&&)&&ip, port);
    escape _ERR_DISCONNECTED;
end

class Client with
    interface PeerListener;
do
    var int ni = [[ #APP.messages ]];

    loop i in ni do
        [[ MSG = APP.messages[@i+1] ]];
        var Message_0_0_prepare msg;
        _assert(msg.err == _ERR_NONE);

        _printf("[client] Sending message...\n");
        var int nj = [[#APP.client.peers]];
        loop j in nj do
            spawn PeerSend.build(j+1, &msg, &this);
        end
        loop j in nj do
            var int err = await this.ok;
            _printf("[client]\tpeer %d\n", err);
        end
        _printf("[client] Send OK!\n");
    end

    escape _ERR_NONE;
end

#endif
