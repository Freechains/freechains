#ifndef _SODIUM_CEU
#define _SODIUM_CEU

native/nohold
    _crypto_generichash,
    _crypto_sign_detached,
    _crypto_sign_verify_detached,
    _sodium_symetric_decrypt,
    _sodium_symetric_encrypt,
    _sodium_passphrase2pwhash,
    _sodium_passphrase2keys,
;

native/pre do
    ##include <sodium.h>

    int sodium_passphrase2pwhash (byte* pwhash, usize pwhash_len, byte* passphrase, usize passphrase_len)
    {
#if 1
            if (pwhash_len     < crypto_pwhash_BYTES_MIN  ||
                pwhash_len     > crypto_pwhash_BYTES_MAX  ||
                passphrase_len < crypto_pwhash_PASSWD_MIN ||
                passphrase_len > crypto_pwhash_PASSWD_MAX )
            {
                return -1;
            }
#endif

            byte salt[crypto_pwhash_SALTBYTES];
            memset(salt, 0, crypto_pwhash_SALTBYTES);

            return crypto_pwhash(pwhash, pwhash_len,
                                 passphrase, passphrase_len,
                                 salt,
                                 crypto_pwhash_OPSLIMIT_INTERACTIVE,
                                 crypto_pwhash_MEMLIMIT_INTERACTIVE,
                                 crypto_pwhash_ALG_DEFAULT);
    }

    int sodium_passphrase2keys (byte* passphrase, usize passphrase_len, byte* pk, byte* sk)
    {
        unsigned char seed[crypto_sign_SEEDBYTES];
#if 0
        {
            ceu_assert(crypto_sign_SEEDBYTES >= crypto_generichash_BYTES, "bug found");
            int ret = crypto_generichash(seed, crypto_sign_SEEDBYTES,
                                         (unsigned char*)passphrase, passphrase_len,
                                         NULL, 0);
            ceu_assert(ret == 0, "bug found");
        }
        return crypto_sign_seed_keypair(pk, sk, seed);
#else
        int ret = sodium_passphrase2pwhash(seed, crypto_sign_SEEDBYTES, passphrase, passphrase_len);
        if (ret != 0) {
            return ret;
        }
        return crypto_sign_seed_keypair(pk, sk, seed);
#endif
    }

    int sodium_symetric_encrypt (byte* buf, usize plain_len, byte* key)
    {
#ifdef DETERMINISTIC
        memset(buf, 0, crypto_secretbox_NONCEBYTES);
#else
        randombytes_buf(buf, crypto_secretbox_NONCEBYTES);
#endif
        return crypto_secretbox_easy(buf+crypto_secretbox_NONCEBYTES,
                                     buf+crypto_secretbox_NONCEBYTES+crypto_secretbox_MACBYTES, plain_len,
                                     buf, key);
    }

    int sodium_symetric_decrypt (byte* buf, usize buf_len, byte* key)
    {
        return crypto_secretbox_open_easy(buf+crypto_secretbox_NONCEBYTES+crypto_secretbox_MACBYTES,
                                          buf+crypto_secretbox_NONCEBYTES, buf_len-crypto_secretbox_NONCEBYTES,
                                          buf, key);
    }
end

#endif

