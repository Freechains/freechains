#ifndef _COMMON_CEU
#define _COMMON_CEU

//#define DBG 0

#include "c.ceu"
#include "uv.ceu"

#define MESSAGE_BYTES   4
#define MESSAGE_MAGIC_0 'P'
#define MESSAGE_MAGIC_1 'S'

#define HASH_BYTES      32
#define NONCE_BYTES     16
#define CHAIN_KEY_BYTES 256

native @pure _leading_zeros();
native @nohold _dbg(), _dbg_tcp();
native do
    ##define VOID_ALIAS(x) ((void*)&x)

    enum {
        ERR_NONE                    =  0,
        ERR_MESSAGE                 = -1,
        ERR_REMOTE_BUG_OR_MALICIOUS = -2,
    };

    enum {
        MESSAGE10 = 1,
    };

    enum {
        MESSAGE10_NOTSUB = 1,   // [ok ACK] not subscribed to this chain
        MESSAGE10_HAVE,         // [ok ACK] already has it
        MESSAGE10_LIMIT,        // [ok ACK] too big for untrusted client
    };

    void dbg (int level, const char* fmt, ...) {
#ifdef DBG
        if (level < DBG) return;
        fprintf(stderr, "[%d] | ", level);
        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    void dbg_tcp (int level, uv_tcp_t* tcp, char* client_server, const char* fmt, ...) {
#ifdef DBG
        if (level < DBG) return;
        int p1 = ceu_uv_tcp_getsockport(tcp);
        int p2 = ceu_uv_tcp_getpeerport(tcp);
        char str[255];
        char* arrow;
        if (strcmp(client_server,"server") == 0) {
            arrow = "<-";
        } else {
            arrow = "->";
        }
        fprintf(stderr, "[%d] | %s:%d%s%d | ", level, client_server, p1, arrow, p2);

        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    // calculate the number of leading zero bits in "bytes"
    // 00abcdef...  => 2
    int leading_zeros (byte* bytes, int len) {
        int i, j;
        int zeros = 0;
        for (i=0; i<len; i++) {             // loop over "bytes"
            byte b = bytes[i];
            for (j=0; j<8; j++) {           // loop over each bit
                if ((b & (1<<(7-j))) != 0) {
                    return zeros;
                } else {
                    zeros++;
                }
            }
        }
        return zeros;
    }
end
#define G(v) GG[@(&&(v))]

interface Global with
    event void recv_chain_unlocked;
    event void send_chain_unlocked;
end
event void recv_chain_unlocked;
event void send_chain_unlocked;

class FS_read_10 with
    var char[]& path;
    // output [[ head = {} ]]
    function (char[]& path)=>FS_read_10 run;
do
    function (char[]& path)=>FS_read_10 run do
        this.path = &path;
    end

    [[
        G(this) = {
            id = nil,
        }
    ]];

    var UV_FS_open o = UV_FS_open.build(&this.path, _O_RDONLY, 0);
    await o.ok;
    if o.fd < 0 then
        escape o.fd;
    end

    var _uv_stat_t stat = _uv_stat_t();
    do UV_FS_fstat.run(&o, &stat);
    var u64 size = stat.st_size;

    var int off = size;
_printf("SIZE = %ld\n", size);

    // => HEADER
    do
        var byte[4] buf;
        var int n = do UV_FS_read.run(&o,&buf,$$buf,0);
        _assert(buf[0] == MESSAGE_MAGIC_0);
        _assert(buf[1] == MESSAGE_MAGIC_1);
        [[ G(this).id = ''..(@buf[2])..(@buf[3]) ]];
        _assert(n == 4);
    end

    // => BLOCKS
    [[
        head1 = nil
        base  = nil
    ]];
    loop do
        if off == 4 then
            break;  // back to the header
        end

_printf("===\n");
        [[ block = {} ]];

        // => HASH
    /*
        do
            var char[HASH_BYTES] buf;
            var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
            if n < 0 then
                break;
            end
            _assert(n == HASH_BYTES);
            off = off + HASH_BYTES;
            [[ block.hash = @buf ]];
            [[ print('block','\n'..tostring2(block.hash)) ]];
        end
    */

        // => TXS
        var u32 txs_n = 0;
        do
            // => TXS_N
            off = off - sizeof(u32);
    // TODO: sizeof(u32)
            var byte[4] buf;
            var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
            if n <= 0 then
                break;
            end
            _assert(n == sizeof(u32));
            txs_n = *((u32&&)(_byte&&)&&buf);
_printf("txs_n = %d\n", txs_n);
        end
        [[ block.txs = {} ]];
        loop i in txs_n do
            // => TXS[i]
            [[
                tx = {}
                block.txs[@(txs_n-i)] = tx
            ]];

            // => TX_PAYLOAD
            do
                var u32 payload_len = 0;
                do
                    off = off - sizeof(u32);
    // TODO: sizeof(u32)
                    var byte[4] buf;
                    var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
                    _assert(n == sizeof(u32));
                    payload_len = *((u32&&)(_byte&&)&&buf);
                    [[ print('payload_len', @payload_len) ]];
                end
//async do end;
                do
                    off = off - payload_len;
                    var char[] buf;
                    $buf := payload_len;
                    var int n = do UV_FS_read.run(&o,&buf,payload_len,off);
_printf("n=%d len=%d\n", n, payload_len);
                    _assert(n == payload_len);
                    [[ tx.payload = @buf ]];
                    [[ print('payload', tx.payload) ]];
                end
            end

            // => TX_BACH_HASH
            do
                off = off - HASH_BYTES;
                var char[HASH_BYTES] buf;
                var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
                _assert(n == HASH_BYTES);
                [[ tx.back_hash = @buf ]];
                [[ print('back_hash','\n'..tostring2(tx.back_hash)) ]];
            end

            // => NONCE
            do
                off = off - NONCE_BYTES;
                var char[NONCE_BYTES] buf;
                var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
                _assert(n == NONCE_BYTES);
                [[ tx.nonce = @buf ]];
                [[ print('nonce','\n'..tostring2(tx.nonce)) ]];
            end
        end
        [[
            if not head1 then
                head1 = block
            end
            block.up = base
            if base then
                base.tail = block
            end
            base = block
        ]]
    end

    escape _ERR_NONE;
end

class FS_write_10 with
    var char[]& path;
    // output [[ head = {} ]]
    function (char[]& path)=>FS_write_10 run;
do
    function (char[]& path)=>FS_write_10 run do
        this.path = &path;
    end

    #if 0
    PS10
    [i]/*BLOCK_HASH*/ (genesis)
        TXS_N
        [j]/*TX_HASH*/ NONCE TX_BACK_HASH TX_PAYLOAD_LEN TX_PAYLOAD
        ...
    ...
    [n]/*BLOCK_HASH*/ (head)
        ...
    #endif

    // create/truncate file
    do
        var int flags = _O_CREAT|_O_WRONLY|_O_TRUNC;
        var _mode_t mode = _S_IRUSR|_S_IWUSR|_S_IRGRP|_S_IWGRP|_S_IROTH;
        var UV_FS_open o = UV_FS_open.build(&this.path, flags, mode);
        await o.ok;
        if o.fd < 0 then
            escape o.fd;
        end
    end

    // <= (append)
    var UV_FS_open o = UV_FS_open.build(&this.path, _O_APPEND|_O_WRONLY, 0);
    await o.ok;
    _assert(o.fd >= 0);

    // <= HEADER
    do
        var byte[4] buf = [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, 1, 0];
        var int n = do UV_FS_write.run(&o,&buf,$buf,0);
        _assert(n == 4);
    end

    // <= BLOCKS
    loop do
    /*
        // <= BLOCK_HASH
        do
            var char[HASH_BYTES] buf = [[ base.hash ]];
            var int n = do UV_FS_write.run(&o,&buf,$buf,0);
            _assert(n == HASH_BYTES);
        end
    */

        // <= TXS
        var u32 txs_n = [[ #base.txs ]];
        loop i in txs_n do
            // <= TXS[i]
            // TX_HASH NONCE TX_BACK_HASH TX_PAYLOAD_LEN TX_PAYLOAD

            [[
                tx_hash = base.txs[@i+1]
                tx      = assert(APP.txs[tx_hash])
            ]];

    /*
            // <= TX_HASH
            do
                var char[HASH_BYTES] buf = [[ tx.hash ]];
                var int n = do UV_FS_write.run(&o,&buf,$buf,0);
                _assert(n == HASH_BYTES);
            end
    */

            // <= NONCE
            do
                var char[NONCE_BYTES] buf = [[ tx.nonce ]];
                var int n = do UV_FS_write.run(&o,&buf,$buf,0);
                _assert(n == NONCE_BYTES);
            end

            // <= TX_BACK_HASH
            do
                var char[HASH_BYTES] buf = [[ tx.back_hash ]];
                var int n = do UV_FS_write.run(&o,&buf,$buf,0);
                _assert(n == HASH_BYTES);
            end

            // <= TX_PAYLOAD
            // <= TX_PAYLOAD_LEN
            do
                var u32 len = [[ string.len(tx.payload) ]];
                // <= TX_PAYLOAD
                do
                    var char[] buf = [[ tx.payload ]];
                    var int n = do UV_FS_write.run(&o,&buf,$buf,0);
                    _assert(n == len);
                end
                // <= TX_PAYLOAD_LEN
                do
                    var char[sizeof(u32)] buf;
                    _ceu_vector_copy_buffer(&&buf, 0, (byte&&)&&len, sizeof(u32), 1);
                    var int n = do UV_FS_write.run(&o,&buf,$buf,0);
                    _assert(n == sizeof(u32));
                end
            end
        end
        do
            // <= TXS_N
            var char[sizeof(u32)] buf;
            _ceu_vector_copy_buffer(&&buf, 0, (byte&&)&&txs_n, sizeof(u32), 1);
            var int n = do UV_FS_write.run(&o,&buf,$buf,0);
            _assert(n == sizeof(u32));
        end

        // NEXT BLOCK
        var bool has = [[ base.up_hash ~= nil ]];
        if not has then
            break;
        end
        [[
            base = assert(APP.blocks[base.up_hash])
        ]];
    end

    escape _ERR_NONE;
end

#include "client.ceu"
#define UV_TCP_SERVER_HANDLER_CEU server.ceu
#include "uv-server.ceu"

[[
    dofile'src/common.lua'
    GG.ERR_REMOTE_BUG_OR_MALICIOUS = @((int)_ERR_REMOTE_BUG_OR_MALICIOUS)
    GG.MESSAGE10_NOTSUB = @((int)_MESSAGE10_NOTSUB)
]];

#endif
