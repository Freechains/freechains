#ifndef _COMMON_CEU
#define _COMMON_CEU

#define DBG 0

#include "c.ceu"
#include "uv/uv.ceu"
#include "uv/fs.ceu"
#include "uv/tcp.ceu"
#include "sodium.ceu"

#define MESSAGE_BYTES   4
#define MESSAGE_MAGIC_0 {'P'}
#define MESSAGE_MAGIC_1 {'S'}

#define HASH_BYTES      32
#define NONCE_BYTES     16
#define CHAIN_KEY_BYTES 256
#define FORK_LENGTHY    100

native/nohold _dbg, _dbg_tcp;
native/pure _leading_zeros;

data Exception.Freechains;
data Exception.Freechains.Unsupported with
    var _char&& message = "unsupported message";
end
data Exception.Freechains.Malformed with
    var _char&& message = "malformed message";
end
data Exception.Freechains.Fork_Lengthy with
    var _char&& message = "fork is too lengthy";
end

native/pre do
    ##define VOID_ALIAS(x) ((void*)&x)

    enum {
        MESSAGE10 = 0x100,
    };

    enum {
        MESSAGE10_OK = 0,
        MESSAGE10_NOTSUB,   // [ok ACK] not subscribed to this chain
        MESSAGE10_HAVE,     // [ok ACK] already has it
        //MESSAGE10_ABORTED,  // [?? ???] aborted from external retransmit
    };

    void dbg (int level, const char* fmt, ...) {
#ifdef DBG
        if (level < DBG) return;
        fprintf(stderr, "[%d] | ", level);
        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    void dbg_tcp (int level, uv_stream_t* tcp, char* client_server, const char* fmt, ...) {
#ifdef DBG
        if (level < DBG) return;
        int p1 = ceu_uv_tcp_getsockport((uv_tcp_t*) tcp);
        int p2 = ceu_uv_tcp_getpeerport((uv_tcp_t*) tcp);
        char str[255];
        char* arrow;
        if (strcmp(client_server,"server") == 0) {
            arrow = "<-";
        } else {
            arrow = "->";
        }
        fprintf(stderr, "[%d] | %s:%d%s%d | ", level, client_server, p1, arrow, p2);

        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    // calculate the number of leading zero bits in "bytes"
    // 00abcdef...  => 2
    int leading_zeros (byte* bytes, int len) {
        int i, j;
        int zeros = 0;
        for (i=0; i<len; i++) {             // loop over "bytes"
            byte b = bytes[i];
            for (j=0; j<8; j++) {           // loop over each bit
                if ((b & (1<<(7-j))) != 0) {
                    return zeros;
                } else {
                    zeros++;
                }
            }
        }
        return zeros;
    }
end
#define G(v) GG[@(&&(v))]
#define THIS GG[@(&&{*_ceu_mem})]

data UV_TCP_Server_Data with
    event (int,bool,int) ok;
    event none unlock;
    event none retransmit;
end

data SourceBlockHash;
data SourceBlockHash.Network;
data SourceBlockHash.File;
data SourceBlockHash.New;

code/await Publication_New (none) -> none
    // input:  [[ ARGS={publication={TODO}} ]]
    // output: [[ ARGS={publication={DONE}} ]]
do
    [[ THIS = ARGS ]];

    var[HASH_BYTES] byte hash;
    _ceu_vector_setlen(&&hash,HASH_BYTES,1);

    var u8 zeros = [[ THIS.publication.chain.zeros ]];

    var[] byte pln = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                     [[ THIS.publication.chain.key ]]   ..
                     [[ THIS.publication.payload ]];

    // show async/thread progress
    var int ms = 0;
#if 1
    spawn do
        every 100ms do
            ms = ms + 100;
            _printf(".");
            _fflush(_stdout);
        end
    end
#endif

#if 1
    await async/thread (zeros,pln,hash)
#endif
    do
        var u64 timestamp = [[ THIS.publication.timestamp ]];
        var u64 nonce     = [[ THIS.publication.nonce     ]];

        var u64 n = do
            var u64 n_ = 0;
            var u64 i;
            loop i in [timestamp -> 0xFFffFFffFFffFFff] do
                PUT_HTOBE64(pln, 0, i);

                var u64 j;
                loop j in [nonce -> 0xFFffFFffFFffFFff] do
                    PUT_HTOBE64(pln, sizeof(u64), j);

                    _ceu_assert(n_ < 0xFFffFFffFFffFFff, "bug found");
                    n_ = n_ + 1;

                    _crypto_generichash(&&hash[0],HASH_BYTES, &&pln[0],$pln, null,0);
                    if zeros <= _leading_zeros(&&hash[0],HASH_BYTES) then
                        [[
                            THIS.publication.timestamp = @i
                            THIS.publication.nonce     = @j
                            THIS.publication.hash      = @hash
                        ]];
                        escape n_;
                    end
                end
            end
            _ceu_assert(0, "bug found");
        end;
        _dbg(0, "client: POW rounds: %d\n", n);
    end

    [[ ARGS = THIS ]];
end

/*
 * Verifies if the hash has the expected leading zeros and if the chain key and
 * payload match the hash.
 */
code/await Publication_Check (none) -> none
    // input: [[ ARGS={publication={DONE}} ]]
    throws Exception.Freechains.Malformed
do
    [[ THIS = ARGS ]];

    var[HASH_BYTES] byte hash = [] .. [[ THIS.publication.hash ]];

    var u8 zeros = [[ THIS.publication.chain.zeros ]];
    if zeros > _leading_zeros(&&hash[0],HASH_BYTES) then
        var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
        throw e;
    end

    var[] byte pln = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                     [[ THIS.publication.chain.key ]]   ..
                     [[ THIS.publication.payload ]];
    do
        var u64 timestamp = [[ THIS.publication.timestamp ]];
        var u64 nonce     = [[ THIS.publication.nonce     ]];
        PUT_HTOBE64(pln, 0, timestamp);
        PUT_HTOBE64(pln, sizeof(u64), nonce);
    end

    _crypto_generichash(&&hash[0],HASH_BYTES, &&pln[0],$pln, null,0);
    var bool ok = [[ THIS.publication.hash == @hash ]];
    if not ok then
        var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
        throw e;
    end
end

code/await Block_Hash (none) -> none
    // input:  [[ ARGS={block={TODO}} ]]
    // effect: [[ ARGS={block={DONE}} ]]
do
    [[ THIS = ARGS ]];

    [[
        --print('>>>', THIS.block.length, THIS.block.prv and THIS.block.prv.length)
        assert(THIS.block.prv)
        assert(THIS.block.prv.length==THIS.block.length-1)
    ]]

    var[HASH_BYTES] byte hash;
    _ceu_vector_setlen(&&hash, HASH_BYTES, 1);

    var u8 zeros = [[ THIS.block.chain.zeros ]];

    var[] byte pln = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                     [[ THIS.block.publication.hash ]] ..
                     [[ THIS.block.prv.hash ]];

    // show async/thread progress
    var int ms = 0;
#if 1
    spawn do
        every 100ms do
            ms = ms + 100;
            _printf(".");
            _fflush(_stdout);
        end
    end
#endif

#if 1
    await async/thread (zeros,pln,hash)
#endif
    do
        var u64 timestamp = [[ THIS.block.timestamp ]];
        var u64 nonce     = [[ THIS.block.nonce     ]];

        var u64 n = do
            var u64 n_ = 0;
            var u64 i;
            loop i in [timestamp -> 0xFFffFFffFFffFFff] do
                PUT_HTOBE64(pln, 0, i);

                var u64 j;
                loop j in [nonce -> 0xFFffFFffFFffFFff] do
                    PUT_HTOBE64(pln, sizeof(u64), j);

                    _ceu_assert(n_ < 0xFFffFFffFFffFFff, "bug found");
                    n_ = n_ + 1;

                    _crypto_generichash(&&hash[0],HASH_BYTES, &&pln[0],$pln, null,0);
                    if zeros <= _leading_zeros(&&hash[0],HASH_BYTES) then
                        [[
                            THIS.block.timestamp = @i
                            THIS.block.nonce     = @j
                            THIS.block.hash      = @hash
                        ]];
                        escape n_;
                    end
                end
            end
            _ceu_assert(0, "bug found");
        end;
        //{ceu_trace(((tceu_trace){&_ceu_mem->trace, __FILE__, __LINE__}),"alo");};
        _dbg(0, "client: POW rounds: %d\n", n);
    end
end

code/await Block_Hash_Link (none) -> none
    // input:  [[ ARGS={block={TODO}} ]]
    // effect: [[ ARGS={block={DONE}} ]]
do
    [[ THIS = ARGS ]]

    [[
        assert(not THIS.block.prv)
        assert(not THIS.block.nxt)
        assert(not THIS.block.length)
        THIS.block.prv = THIS.block.chain.head
        THIS.block.length = (THIS.block.prv and THIS.block.prv.length+1) or 1
    ]]

    [[ ARGS = THIS ]]
    await Block_Hash();

    [[
        THIS.block.chain.head.nxt = THIS.block
        THIS.block.chain.head     = THIS.block
    ]]
end

/*
 * Verifies if the hash has the expected leading zeros and if the publication
 * hash and back hash match the hash.
 */
code/await Block_Check (none) -> none
    // input: [[ ARGS={block={DONE}} ]]
    throws Exception.Freechains.Malformed
do
    [[ THIS = ARGS ]];

    var[HASH_BYTES] byte hash = [] .. [[ THIS.block.hash ]];

    var u8 zeros = [[ THIS.block.chain.zeros ]];
    if zeros > _leading_zeros(&&hash[0],HASH_BYTES) then
        var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
        throw e;
    end

    var[] byte pln = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                     [[ THIS.block.publication.hash ]] ..
                     [[ THIS.block.prv.hash ]];
    do
        var u64 timestamp = [[ THIS.block.timestamp ]];
        var u64 nonce     = [[ THIS.block.nonce     ]];
        PUT_HTOBE64(pln, 0, timestamp);
        PUT_HTOBE64(pln, sizeof(u64), nonce);
    end

    _crypto_generichash(&&hash[0],HASH_BYTES, &&pln[0],$pln, null,0);
    var bool ok = [[ THIS.block.hash == @hash ]];
    if not ok then
        var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
        throw e;
    end
end

code/await Chain_Fork (none) -> none
    // input:  [[ ARGS={from=., to={first=.,last=.} ]]
do
    [[ THIS = ARGS ]]
    loop do
        var bool has = [[ THIS.from~=nil ]];
        if not has then
            break;
        end

        [[
            found = false
            cur = THIS.to.first
            while true do
                if cur.publication.hash == THIS.from.publication.hash then
error'OKOKOK'
                    found = true
                    break
                end
                if cur == THIS.to.last then
                    break
                end
                cur = cur.nxt
            end
        ]]
        var bool found = [[ found ]];
        if found then
            continue;
        end

        [[
--print('>>>', tostring2(THIS.from.hash), THIS.from.publication.payload)
            assert(THIS.from.chain == THIS.to.first.chain)
            THIS.block = {
                version     = '1.0',
                timestamp   = 0,    -- TODO: 64-bit timestamp
                nonce       = 0,
                chain       = THIS.from.chain,
                publication = THIS.from.publication,
                hash        = nil,
                prv         = nil,
                nxt         = nil,
                length      = nil,
            }
            ARGS = THIS
        ]]
        await Block_Hash_Link();

        [[ THIS.from = THIS.from.nxt ]]
    end
end

code/await FS_read_10 (var&[] byte path) -> none
    throws Exception.Uv, Exception.Freechains.Malformed
    // output [[ ARGS = { chain_id, head_hash } ]]
do
    [[
        THIS = {
            chain_id = nil,
            head     = nil,
            base     = nil,
        }
    ]];

    var& UV_FS_Open o = spawn UV_FS_Open(&&path[0],_,_,_);
    await o.file.ok;

    var _uv_stat_t stat = _;
    await UV_FS_Fstat(&o.file, &stat);
    var u64 size = stat.st_size;

    // => HEADER
    do
        var ssize n = await UV_FS_Read_N(&o.file, MESSAGE_BYTES);
        if n == 0 or
           o.file.buffer[0] != MESSAGE_MAGIC_0 or
           o.file.buffer[1] != MESSAGE_MAGIC_1 or
           o.file.buffer[2] != 1 or
           o.file.buffer[3] != 0
        then
            var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
            throw e;
        end
        $o.file.buffer = 0;
    end

    // => CHAIN_ID
    do
        var usize len;
        do
            var ssize n = await UV_FS_Read_N(&o.file, 1);
            _ceu_assert(n == 1, &&path[0]);
            len = o.file.buffer[0] as usize;
            $o.file.buffer = 0;
        end

        do
            var ssize n = await UV_FS_Read_N(&o.file, len);
            _ceu_assert(n == len, "bug found");
            [[ THIS.chain_id = @o.file.buffer ]];
            $o.file.buffer = 0;
        end
        //[[ print('>>> chain_id',@buf) ]];
    end

    // => BLOCKS
    loop do
        // => TXS
        var u32 txs_n = _;
        do
            // => TXS_N
            var[sizeof(u32)] byte buf;
            var ssize n = await UV_FS_Read_N(&o.file, sizeof(u32));
            if n <= 0 then
                break;          // EOF
            end
            _ceu_assert(n == sizeof(u32), "bug found");
            txs_n = *(&&o.file.buffer[0] as u32&&);
            $o.file.buffer = 0;
        end

        // OK, non-emtpy block
        [[
            THIS.previous = THIS.block
            THIS.block = {
                txs = {},
                tail_hash = (THIS.previous and THIS.previous.hash) or nil,
            }
        ]];

        var u32 i;
        loop i in [0 -> txs_n[ do
            // => TXS[i]
            [[
                THIS.tx = {}
                THIS.block.txs[@(i+1)] = THIS.tx
            ]];

            // => NONCE
            do
                var ssize n = await UV_FS_Read_N(&o.file, NONCE_BYTES);
                _ceu_assert(n == NONCE_BYTES, "bug found");
                [[ THIS.tx.nonce = @o.file.buffer ]];
                //[[ print('nonce','\n'..tostring2(THIS.tx.nonce)) ]];
                $o.file.buffer = 0;
            end

            // => TX_BACH_HASH
            do
                var ssize n = await UV_FS_Read_N(&o.file, HASH_BYTES);
                _ceu_assert(n == HASH_BYTES, "bug found");
                [[ THIS.tx.back_hash = @o.file.buffer ]];
                //[[ print('back_hash','\n'..tostring2(THIS.tx.back_hash)) ]];
                $o.file.buffer = 0;
            end

            // => TX_PAYLOAD
            do
                var u32 payload_len;
                do
                    var ssize n = await UV_FS_Read_N(&o.file, sizeof(u32));
                    _ceu_assert(n == sizeof(u32), "bug found");
                    payload_len = *(&&o.file.buffer[0] as u32&&);
                    //[[ print('payload_len', @payload_len) ]];
                    $o.file.buffer = 0;
                end
                do
                    var ssize n = await UV_FS_Read_N(&o.file, payload_len as usize);
                    _ceu_assert(n == (payload_len as ssize), "bug found");
                    [[ THIS.tx.payload = @o.file.buffer ]];
                    //[[ print('payload', THIS.tx.payload) ]];
                    $o.file.buffer = 0;
                end
            end
        end

        [[
            THIS.block.chain_id = THIS.chain_id
            ARGS = {
                block = THIS.block,
            }
        ]];
        //await BlockHash(SourceBlockHash.File());

        [[
            if THIS.previous then
                THIS.previous.up_hash = THIS.block.hash
            else
                --assert(not THIS.genesis_hash)
                --THIS.genesis_hash = THIS.block.hash
            end
        ]];
    end

    [[
        ARGS = {
            chain_id  = THIS.chain_id,
            head_hash = THIS.block.hash,
            --genesis_hash = THIS.genesis_hash,
        }
    ]];
end

code/await Chain_Lock (var& UV_TCP_Server_Data shared) -> NEVER
do
    [[ THIS = ARGS ]]
    var bool is_locked = [[ THIS.chain.is_locked ]];
    if is_locked then
        loop do
            await shared.unlock;
            is_locked = [[ THIS.chain.is_locked ]];
            if not is_locked then
                break;
            end
        end
    end
    [[ THIS.chain.is_locked = true ]];
    do finalize with
        [[ THIS.chain.is_locked = false ]];
        emit shared.unlock;
    end
    await FOREVER;
end

code/await FS_write_10 (var&[] byte path) -> none
    throws Exception.Uv
    // input [[ ARGS = { chain_id } ]]
do
#if 0
    PS10
    [i]/*BLOCK_HASH*/ (genesis)
        TXS_N
        [j]/*TX_HASH*/ NONCE TX_BACK_HASH TX_PAYLOAD_LEN TX_PAYLOAD
        ...
    ...
    [n]/*BLOCK_HASH*/ (head)
        ...
#endif

    [[
        chain = APP.chains[ ARGS.chain_id ]
        t = GG.chain_head_base_size(chain.head_hash)
        THIS = {
            base  = t.base,
            chain = chain,
        }
    ]];

    // create/truncate file
    do/_
        var int flags = _O_CREAT|_O_WRONLY|_O_TRUNC;
        var _mode_t mode = _S_IRUSR|_S_IWUSR|_S_IRGRP|_S_IWGRP|_S_IROTH;
        var& UV_FS_Open o = spawn UV_FS_Open(&&path[0], _, flags, mode);
        await o.file.ok;
    end

    // <= (append)
    var& UV_FS_Open o = spawn UV_FS_Open(&&path[0], 128000, _O_APPEND|_O_WRONLY, 0);
    await o.file.ok;
    _ceu_assert(o.file.handle >= 0, "bug found");

    // <= HEADER
    do
        o.file.buffer = [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, 1, 0];
        var ssize n = await UV_FS_Write_N(&o.file, MESSAGE_BYTES);
        _ceu_assert(n == 4, "bug found");
    end

    // <= CHAIN_ID
    do
        var byte len = [[ string.len(THIS.chain.id) ]];
        do
            o.file.buffer = [len];
            var ssize n = await UV_FS_Write_N(&o.file, 1);
            _ceu_assert(n == 1, "bug found");
        end
        do
            o.file.buffer = [] .. [[ THIS.chain.id ]];
            var ssize n = await UV_FS_Write_N(&o.file, len as usize);
            _ceu_assert(n == (len as ssize), "bug found");
        end
    end

    // <= BLOCKS
    loop do
        // <= TXS
        var u32 txs_n = [[ #THIS.base.txs ]];
        do
            // <= TXS_N
            _ceu_vector_setlen(&&o.file.buffer, sizeof(u32), 1);
            _ceu_vector_buf_set(&&o.file.buffer, 0, (&&txs_n as byte&&), sizeof(u32));
            var ssize n = await UV_FS_Write_N(&o.file, sizeof(u32));
            _ceu_assert(n == sizeof(u32), "bug found");
        end
        var u32 i;
        loop i in [0 -> txs_n[ do
            // <= TXS[i]
            // TX_HASH NONCE TX_BACK_HASH TX_PAYLOAD_LEN TX_PAYLOAD

            [[
                tx_hash = THIS.base.txs[@i+1]
                THIS.tx = assert(APP.txs[tx_hash])
            ]];

            // <= NONCE
            do
                o.file.buffer = [] .. [[ THIS.tx.nonce ]];
                var ssize n = await UV_FS_Write_N(&o.file, NONCE_BYTES);
                _ceu_assert(n == NONCE_BYTES, "bug found");
            end

            // <= TX_BACK_HASH
            do
                o.file.buffer = [] .. [[ THIS.tx.back_hash ]];
                var ssize n = await UV_FS_Write_N(&o.file, HASH_BYTES);
                _ceu_assert(n == HASH_BYTES, "bug found");
            end

            // <= TX_PAYLOAD_LEN
            // <= TX_PAYLOAD
            do
                var u32 len = [[ string.len(THIS.tx.payload) ]];
                // <= TX_PAYLOAD_LEN
                do
                    _ceu_vector_setlen(&&o.file.buffer, sizeof(u32), 1);
                    _ceu_vector_buf_set(&&o.file.buffer, 0, (&&len as byte&&), sizeof(u32));
                    var ssize n = await UV_FS_Write_N(&o.file, sizeof(u32));
                    _ceu_assert(n == sizeof(u32), "bug found");
                end
                // <= TX_PAYLOAD
                do
// TODO: may not fit default buffer length (1024)
                    o.file.buffer = [] .. [[ THIS.tx.payload ]];
                    var ssize n = await UV_FS_Write_N(&o.file, len as usize);
                    _ceu_assert(n == (len as usize), "bug found");
                end
            end
        end

        // NEXT BLOCK
        var bool has = [[ THIS.base.up_hash ~= nil ]];
        if not has then
            break;
        end
        [[
            --print('<<<', '|'..tostring2(THIS.base.hash)..'|')
            THIS.base = assert(APP.blocks[THIS.base.up_hash])
        ]];
    end
end

native/pre do
    int SERVERS_ALIVE    = 0;
    int CLIENTS_ALIVE    = 0;
    int BLOCKS_RECEIVED  = 0;
    int BLOCKS_RECREATED = 0;
    int TXS_RECREATED = 0;
end
#if 0
spawn do
    every 10s do
        _printf("SERVERS_ALIVE = %d\n", {SERVERS_ALIVE});
        _printf("CLIENTS_ALIVE = %d\n", {CLIENTS_ALIVE});
    end
end
#endif

#include "client.ceu"
#include "server.ceu"
#include "uv/tcp-server.ceu"

code/await Init (none) -> none
    throws Exception.Freechains.Malformed
do
    [[
        THIS = {}
        GG['Exception.Freechains.Malformed'] = @({CEU_DATA_Exception__dot__Freechains__dot__Malformed} as int)
        GG.MESSAGE10_NOTSUB = @({MESSAGE10_NOTSUB} as int)
    ]]

    var int n_chains = [[ #APP.chains ]];
    var int i;
    loop i in [1 -> n_chains] do
        [[
            THIS.chain = APP.chains[@i]
            assert(not THIS.chain.head)

            path = APP.chains.files..'/'..THIS.chain.id..'.chain'
        ]]

        do
            var[HASH_BYTES] byte chain_hash;
            _ceu_vector_setlen(&&chain_hash, HASH_BYTES, 1);
            var[] byte chain_id = [] .. [[ THIS.chain.id ]];
            _crypto_generichash(&&chain_hash[0],HASH_BYTES, &&chain_id[0],$chain_id, null,0);
#if 0
            do
                var[] byte str = [] .. [[ tostring2(@chain_hash) ]] .. [0];
                _dbg(3, "|| CHAIN_HASH : %s", &&str[0]);
            end
#endif
            [[
                THIS.chain.head = {
                    chain  = THIS.chain,
                    hash   = @chain_hash,
                    prv    = nil,
                    length = 0,
                }
            ]]
        end

// TODO: FS_*
#if 0
        var[] byte path = [] .. [[path]] .. [0];
        var Exception? e;
        catch e do
            await FS_read_10(&path);
        end
        if not e? then
            [[
                -- TODO: assert chain.id==file header
                --chain.genesis_hash = ARGS.genesis_hash
                THIS.chain.head_hash = ARGS.head_hash
            ]];
        else
            //_dbg(0, "main: file not found: %s", &&path[0]);
        end
#endif
    end
end

#endif
