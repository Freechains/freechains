#ifndef _COMMON_CEU
#define _COMMON_CEU

#define DBG 9

#include "c.ceu"
#include "uv/uv.ceu"
#include "uv/tcp.ceu"
#include "sodium.ceu"

#define MESSAGE_BYTES   4
#define MESSAGE_MAGIC_0 {'P'}
#define MESSAGE_MAGIC_1 {'S'}

#define HASH_BYTES      32
#define NONCE_BYTES     16
#define CHAIN_KEY_BYTES 256
#define FORK_LENGTHY    100

#define THIS FC[@(&&{*_ceu_mem})]

native/nohold ___dbg, ___dbg_tcp;
native/pure _leading_zeros;

data Exception.Freechains;
data Exception.Freechains.Unsupported with
    var _char&& message = "unsupported message";
end
data Exception.Freechains.Malformed with
    var _char&& message = "malformed message";
end
data Exception.Freechains.Not_Subscribed with
    var _char&& message = "not subscribed";
end
data Exception.Freechains.Timeout with
    var _char&& message = "timeout";
end

#if 0
#define _dbg(a,...)                         \
    do                                      \
        var bool dbg_on = [[DBG_ON==true]]; \
        if dbg_on then                      \
            ___dbg(a, ##__VA_ARGS__);        \
        end                                 \
    end
#define _dbg_tcp(a,...)                     \
    do                                      \
        var bool dbg_on = [[DBG_ON==true]]; \
        if dbg_on then                      \
            ___dbg_tcp(a, ##__VA_ARGS__);    \
        end                                 \
    end
#else
#define _dbg(a,...)     ___dbg(a, ##__VA_ARGS__)
#define _dbg_tcp(a,...) ___dbg_tcp(a, ##__VA_ARGS__)
#endif

native/pre do
    enum {
        NODE_JOIN = 0,
        NODE_PUB,
    };

    enum {
        MESSAGE10 = 0x0100,     // broadcast chain
        MESSAGE20 = 0x0200,     // GET a chain state
        MESSAGE30 = 0x0300,     // PUBLISH to a chain
        MESSAGE40 = 0x0400,     // SUBSCRIBE to a chain
        MESSAGE50 = 0x0500,     // CONFIGURE freechains
        MESSAGE60 = 0x0600,     // LISTEN for new nodes
        MESSAGE70 = 0x0700,     // STOP freechains
    };

    void __dbg (int level, const char* fmt, ...) {
#ifdef DBG
        if (level > DBG) return;
        fprintf(stderr, "[%d] | ", level);
        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    void __dbg_tcp (int level, uv_stream_t* tcp, char* client_server, const char* fmt, ...) {
#ifdef DBG
        if (level > DBG) return;
        int p1 = ceu_uv_tcp_getsockport((uv_tcp_t*) tcp);
        int p2 = ceu_uv_tcp_getpeerport((uv_tcp_t*) tcp);
        char str[255];
        char* arrow;
        if (strcmp(client_server,"server") == 0) {
            arrow = "<-";
        } else {
            arrow = "->";
        }
        fprintf(stderr, "[%d] | %s:%d%s%d | ", level, client_server, p1, arrow, p2);

        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    // calculate the number of leading zero bits in "bytes"
    // 00abcdef...  => 2
    int leading_zeros (byte* bytes, int len) {
        int i, j;
        int zeros = 0;
        for (i=0; i<len; i++) {             // loop over "bytes"
            byte b = bytes[i];
            for (j=0; j<8; j++) {           // loop over each bit
                if ((b & (1<<(7-j))) != 0) {
                    return zeros;
                } else {
                    zeros++;
                }
            }
        }
        return zeros;
    }
end

data UV_TCP_Server_Data with
    event int       go_client_10_pre;
    event int       ok_client_10_pre;
    event (int,int) err_client_10_pre;

    event int       go_client_10_pos;
    event int       ok_client_10_pos;
    event (int,int) err_client_10_pos;

    event int       ok_server;
    event (int,int) err_server;

    var int n = -1;
end

#define AWAIT_CHAIN_N(shared,key,zeros,len)             \
    loop do                                             \
        [[ --print('>>> N', FC.chains[key][zeros].n) ]];  \
        var int len_ = [[ FC.chains[key][zeros].n ]];   \
        if len_ >= (len) then                           \
            break;                                      \
        end                                             \
        await shared.go_client_10_pos;                 \
    end

#if 0
#define CHAIN_LOCK(var_id,shared,lock_id)                       \
    [[ assert(ARGS and ARGS.chain) ]];                          \
    var& Chain_Lock var_id = spawn Chain_Lock(&shared,lock_id); \
    if var_id.is_locked then                                    \
        await var_id.ok;                                        \
    end

code/await Chain_Lock (var& UV_TCP_Server_Data shared, var _char&& id) ->
                        (var bool is_locked, event none ok) ->
                            NEVER
do
    [[
        THIS = {
            chain = ARGS.chain,
            id    = @id,
        }
    ]]
    is_locked = [[ THIS.chain[THIS.id] ]];
    if is_locked then
        loop do
#if 1
            spawn do
                await 30s;
                [[ error('locked for too long '..THIS.id) ]];
            end
#endif
            await shared.unlock;
            is_locked = [[ THIS.chain[THIS.id] ]];
            if not is_locked then
                break;
            end
        end
    end
    [[ THIS.chain[THIS.id] = true ]];
    do finalize with
        [[ THIS.chain[THIS.id] = false ]];
        emit shared.unlock;
    end
    emit ok;
    await FOREVER;
end
#endif

code/await Publication_New (none) -> none
    // input:  [[ ARGS={pub={TODO}} ]]
    // output: [[ ARGS={pub={DONE}} ]]
do
    [[
        THIS = {
            pub = ARGS.pub,
        }
        assert(THIS.pub.removal or string.len(THIS.pub.payload)>0)
    ]];

    var[HASH_BYTES] byte hash;
    _ceu_vector_setlen(&&hash,HASH_BYTES,1);

    var u8 zeros = [[ THIS.pub.chain.zeros ]];

    var[] byte pln = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                     [[ THIS.pub.chain.key ]]   ..
                     [[ (THIS.pub.removal and THIS.pub.removal.pub.payload) or THIS.pub.payload ]];

    // when removing, append the original payload hash to avoid nonce reuse
    var bool is_removal = [[ THIS.pub.removal~=nil ]];
    if is_removal then
        pln = pln .. [[ THIS.pub.removal.pub.hash ]];
    end

    // show async/thread progress
    var int ms = 0;
#if 1
    spawn do
        every 100ms do
            ms = ms + 1;
            //_printf("(%d)",ms);
            _printf(".");
            _fflush(_stdout);
        end
    end
#endif

    var u64 timestamp = [[ THIS.pub.timestamp ]];
    var u64 nonce     = [[ THIS.pub.nonce     ]];
#if 1
    await async/thread (zeros,pln,hash, timestamp,nonce)
#endif
    do
        var u64 n = do
            var u64 n_ = 0;
            loop timestamp in [timestamp -> 0xFFffFFffFFffFFff] do
                PUT_HTOBE64(pln, 0, timestamp);

                loop nonce in [nonce -> 0xFFffFFffFFffFFff] do
                    PUT_HTOBE64(pln, sizeof(u64), nonce);

                    _ceu_assert(n_ < 0xFFffFFffFFffFFff, "bug found");
                    n_ = n_ + 1;

                    _crypto_generichash(&&hash[0],HASH_BYTES, &&pln[0],$pln, null,0);
                    if zeros <= _leading_zeros(&&hash[0],HASH_BYTES) then
                        escape n_;
                    end
                end
            end
            _ceu_assert(0, "bug found");
        end;
        _dbg(3, "client: POW rounds: %d\n", n);
    end

    [[
        THIS.pub.timestamp = @timestamp
        THIS.pub.nonce     = @nonce
        THIS.pub.hash      = @hash
        THIS.pub.chain.up.pubs[THIS.pub.hash] = THIS.pub
        ARGS = THIS
    ]];
end

/*
 * Verifies if the hash has the expected leading zeros and if the chain key and
 * payload match the hash.
 */
code/await Publication_Check (none) -> none
    // input: [[ ARGS={pub={DONE}} ]]
    throws Exception.Freechains.Malformed
do
    [[
        THIS = {
            pub = ARGS.pub,
        }
    ]];

    var[HASH_BYTES] byte hash = [] .. [[ THIS.pub.hash ]];

    var u8 zeros = [[ THIS.pub.chain.zeros ]];
    if zeros > _leading_zeros(&&hash[0],HASH_BYTES) then
        var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
        throw e;
    end

    var[] byte pln = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                     [[ THIS.pub.chain.key ]]   ..
                     [[ (THIS.pub.removal and THIS.pub.removal.pub.payload) or THIS.pub.payload ]];
    do
        var u64 timestamp = [[ THIS.pub.timestamp ]];
        var u64 nonce     = [[ THIS.pub.nonce     ]];
        PUT_HTOBE64(pln, 0, timestamp);
        PUT_HTOBE64(pln, sizeof(u64), nonce);
    end

    // when removing, append the original pub hash to avoid nonce reuse
    var bool is_removal = [[ THIS.pub.removal~=nil ]];
    if is_removal then
        pln = pln .. [[ THIS.pub.removal.pub.hash ]];
    end

    _crypto_generichash(&&hash[0],HASH_BYTES, &&pln[0],$pln, null,0);
    var bool ok = [[ THIS.pub.hash == @hash ]];
    if not ok then
        var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
        throw e;
    end

    [[
        THIS.pub.chain.up.pubs[THIS.pub.hash] = THIS.pub
    ]]
end

code/await Node_Hash (none) -> none
    // input:  [[ ARGS={node={TODO}} ]]
    // effect: [[ ARGS={node={DONE}} ]]
do
    [[
        THIS = {
            node = ARGS.node,
        }
    ]];

    var[HASH_BYTES] byte hash;
    _ceu_vector_setlen(&&hash, HASH_BYTES, 1);

    var u8 zeros = [[ THIS.node.chain.zeros ]];

    var[] byte pln = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                     [[ THIS.node.pub.hash ]];

    var int n = [[ #THIS.node ]];
    var int i;
    loop i in [1 -> n] do
        pln = pln .. [[ THIS.node[@i].hash ]];
    end

    // show async/thread progress
    var int ms = 0;
#if 1
    spawn do
        every 100ms do
            ms = ms + 1;
            //_printf("[%d]",ms);
            _printf(".");
            _fflush(_stdout);
        end
    end
#endif

    var u64 timestamp = [[ THIS.node.timestamp ]];
    var u64 nonce     = [[ THIS.node.nonce     ]];
#if 1
    await async/thread (zeros,pln,hash, timestamp,nonce)
#endif
    do
        var u64 n = do
            var u64 n_ = 0;
            loop timestamp in [timestamp -> 0xFFffFFffFFffFFff] do
                PUT_HTOBE64(pln, 0, timestamp);

                loop nonce in [nonce -> 0xFFffFFffFFffFFff] do
                    PUT_HTOBE64(pln, sizeof(u64), nonce);

                    _ceu_assert(n_ < 0xFFffFFffFFffFFff, "bug found");
                    n_ = n_ + 1;

                    _crypto_generichash(&&hash[0],HASH_BYTES, &&pln[0],$pln, null,0);
                    if zeros <= _leading_zeros(&&hash[0],HASH_BYTES) then
                        escape n_;
                    end
                end
            end
            _ceu_assert(0, "bug found");
        end;
        _dbg(3, "client: POW rounds: %d\n", n);
    end

    [[
        THIS.node.timestamp = @timestamp
        THIS.node.nonce     = @nonce
        THIS.node.hash      = @hash
        FC.node(THIS.node)
    ]];
end

/*
 * Verifies if the hash has the expected leading zeros and if the pub
 * hash and back hash match the hash.
 */
code/await Node_Check (none) -> none
    // input: [[ ARGS={node={DONE}} ]]
    throws Exception.Freechains.Malformed
do
    [[
        THIS = {
            node = ARGS.node,
        }
    ]];

    var[HASH_BYTES] byte hash = [] .. [[ THIS.node.hash ]];

    var u8 zeros = [[ THIS.node.chain.zeros ]];
    if zeros > _leading_zeros(&&hash[0],HASH_BYTES) then
        var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
        throw e;
    end

    var[] byte pln = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                     [[ THIS.node.pub.hash ]];

    var int n = [[ #THIS.node ]];
    var int i;
    loop i in [1 -> n] do
        pln = pln .. [[ THIS.node[@i].hash ]];
    end

    do
        var u64 timestamp = [[ THIS.node.timestamp ]];
        var u64 nonce     = [[ THIS.node.nonce     ]];
        PUT_HTOBE64(pln, 0, timestamp);
        PUT_HTOBE64(pln, sizeof(u64), nonce);
    end

    _crypto_generichash(&&hash[0],HASH_BYTES, &&pln[0],$pln, null,0);
    var bool ok = [[ THIS.node.hash == @hash ]];
    if not ok then
        var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
        throw e;
    end

    [[
        FC.node(THIS.node)
    ]]
end

#include "fs.ceu"

code/await Subscribe (var& UV_TCP_Server_Data shared) -> none do
    [[
        THIS = {
            chains = {},
        }
        for _, chain in pairs(CFG.chains) do
            THIS.chains[#THIS.chains+1] = chain
        end
    ]]
    var int n = [[ #THIS.chains ]];
    var int i;
    loop i in [1 -> n] do
        [[
            cfg = THIS.chains[@i]
            --assert(not FC.chains[cfg.key])
            FC.chains[cfg.key] = FC.chains[cfg.key] or {
                key  = cfg.key,
                --cfg  = cfg,
                pubs = { [string.rep('\0',@HASH_BYTES)]=true }, -- have all removeds
            }
        ]]
        var int zeros = [[cfg.zeros]];
        var int j;
        //loop j in [zeros -> 255] do
loop j in [zeros -> 22] do
            [[
                j = @j
                has = FC.chains[cfg.key][j]
                if not has then
                    assert(not FC.chains[cfg.key][j])
                    local id = '|'..cfg.key..'|'..j..'|'
                    THIS.sub = {
                        cache = {},
                        key   = cfg.key,
                        zeros = j,
                        id    = id,
                        up    = FC.chains[cfg.key],
                        n     = 0,
                        head  = {},
                    }
                    FC.chains[cfg.key][j] = THIS.sub
                end
            ]]
            var bool has = [[has]];
            if has then
                continue;   // from main.subscribe
            end

            do
                var[HASH_BYTES] byte hash;
                _ceu_vector_setlen(&&hash, HASH_BYTES, 1);
                var[] byte id = [] .. [[ THIS.sub.id ]];
                _crypto_generichash(&&hash[0],HASH_BYTES, &&id[0],$id, null,0);
#if 0
                do
                    var[] byte str = [] .. [[ FC.tostring(@hash) ]] .. [0];
                    _dbg(3, "|| CHAIN_HASH : %s", &&str[0]);
                end
#endif
                [[
                    FC.head_new( FC.node{ chain=THIS.sub, hash=@hash } )
                ]]
            end

            // try to load from file
            // no problem if it fails
            var bool should_read = [[ not CFG.no_persistency ]];
            if should_read then
                var Exception? e;
                catch e do
                    [[
                        ARGS = {
                            chain = THIS.sub
                        }
                    ]]
                    await FS_read_10();
                end
            end

            // TODO: how not to send all chains in all levels?
            // Even if head=base, I don't really know if they are empty in other peers.
            // So, I want to broadcast it so that the peers send me updates as well
            [[ ARGS = { chain=THIS.sub } ]];
            emit shared.go_client_10_pos(0);
        end
    end
end

#include "server/message_10.ceu"
#include "client_10.ceu"

#include "server.ceu"
#include "uv/tcp-server.ceu"

code/await Init (none) -> (event none ok, var UV_TCP_Server_Data shared) -> NEVER
    throws Exception.Freechains.Malformed
do
    shared = _;

    // TODO: HACK-01: avoid fixing all tests
    var bool is_tst_no_daemon = [[ MAIN==nil and CFG.daemon==nil ]];

    [[
        FC = require 'freechains'

        FC['Exception.Freechains.Malformed']      = @({CEU_DATA_Exception__dot__Freechains__dot__Malformed} as int)
        FC['Exception.Freechains.Not_Subscribed'] = @({CEU_DATA_Exception__dot__Freechains__dot__Not_Subscribed} as int)

        CFG.daemon = CFG.daemon or {}

        FC.daemon = {
            address = CFG.daemon.address or arg[2] or 'localhost',
            port    = CFG.daemon.port    or arg[3] or 8330,
        }
        CFG.dir = CFG.dir or '/tmp/freechains/'..FC.daemon.port
        os.execute('mkdir -p '..CFG.dir)
    ]]

#ifdef DETERMINISTIC
    [[ CFG.deterministic = true ]];
#endif

    do
        var[] byte path = []..[[ CFG.dir ]]..[0];
        _dbg(0, "server | persistency in %s", &&path[0]);
    end

    await Subscribe(&shared);

    spawn do
        var int  msg;
        var int  ret;
        every (msg,ret) in shared.err_server do
            _dbg(0, "error | %d %d", msg, ret);
//_ceu_assert(0, "ERROR");
        end
    end
#if 0
    spawn do
        var int  msg;
        var int  ret;
        every (msg,ret) in shared.ok_server do
            _dbg(0, "ok | %d %d", msg, ret);
        end
    end
#endif

    // TODO: HACK-01: avoid fixing all tests
    pool[1] UV_TCP_Server server;
    if not is_tst_no_daemon then
        var[] byte ip      = [] .. "0.0.0.0";
        var   int  port    = [[ FC.daemon.port ]];
        var   int  backlog = [[ CFG.daemon.backlog or 128 ]];
        _dbg(0, "server | listening in %s:%d", &&ip[0], port);
        spawn UV_TCP_Server(&&ip[0], port, backlog, _, &shared) in server;
    end

    spawn Clients_10(&shared);

    await async do end; // with "no_persistency", no files are loaded and no awaits happen until here
    emit ok;

    await FOREVER;
end

#endif
