#ifndef _COMMON_CEU
#define _COMMON_CEU

#define DBG 0
//#define FREECHAINS_NO_MALICIOUS

#include "c.ceu"
#include "uv/uv.ceu"
#include "uv/fs.ceu"
#include "uv/tcp.ceu"
#include "sodium.ceu"

#define MESSAGE_BYTES   4
#define MESSAGE_MAGIC_0 {'P'}
#define MESSAGE_MAGIC_1 {'S'}

#define HASH_BYTES      32
#define NONCE_BYTES     16
#define CHAIN_KEY_BYTES 256

native/nohold _dbg, _dbg_tcp;
native/pure _leading_zeros;
native/const
    _ERR_NONE,
    _ERR_MESSAGE,
    _ERR_REMOTE_BUG_OR_MALICIOUS,
    _MESSAGE10_NOTSUB,
    _MESSAGE10_HAVE,
    _MESSAGE10_LIMIT,
;

native/pre do
    ##define VOID_ALIAS(x) ((void*)&x)

    enum {
        ERR_NONE                    =  0,
        ERR_MESSAGE                 = -1,
        ERR_REMOTE_BUG_OR_MALICIOUS = -2,
    };

    enum {
        MESSAGE10 = 1,
    };

    enum {
        MESSAGE10_NOTSUB = 1,   // [ok ACK] not subscribed to this chain
        MESSAGE10_HAVE,         // [ok ACK] already has it
        MESSAGE10_LIMIT,        // [ok ACK] too big for untrusted client
    };

    void dbg (int level, const char* fmt, ...) {
#ifdef DBG
        if (level < DBG) return;
        fprintf(stderr, "[%d] | ", level);
        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    void dbg_tcp (int level, uv_tcp_t* tcp, char* client_server, const char* fmt, ...) {
#ifdef DBG
        if (level < DBG) return;
        int p1 = ceu_uv_tcp_getsockport(tcp);
        int p2 = ceu_uv_tcp_getpeerport(tcp);
        char str[255];
        char* arrow;
        if (strcmp(client_server,"server") == 0) {
            arrow = "<-";
        } else {
            arrow = "->";
        }
        fprintf(stderr, "[%d] | %s:%d%s%d | ", level, client_server, p1, arrow, p2);

        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    // calculate the number of leading zero bits in "bytes"
    // 00abcdef...  => 2
    int leading_zeros (byte* bytes, int len) {
        int i, j;
        int zeros = 0;
        for (i=0; i<len; i++) {             // loop over "bytes"
            byte b = bytes[i];
            for (j=0; j<8; j++) {           // loop over each bit
                if ((b & (1<<(7-j))) != 0) {
                    return zeros;
                } else {
                    zeros++;
                }
            }
        }
        return zeros;
    }
end
#define G(v) GG[@(&&(v))]
#define THIS GG[@(&&{*_ceu_mem})]

data UV_TCP_Server_Data with
    event void go_client;
    event void unlock;
end

data SourceBlockHash;
data SourceBlockHash.Network;
data SourceBlockHash.File;
data SourceBlockHash.New;

code/await BlockHash (var SourceBlockHash source) -> int
    // input  [[ ARGS = { block={ txs={ tx1, tx2, ... } } }
    // output [[ ARGS = { block={ txs={ tx1_hash, tx2_hash, ... } } }
    // output [[ APP.block[hash]=blk APP.txs[hash]=txs ]]
do
    [[
        THIS = {
            block = ARGS.block,
            chain = APP.chains[ARGS.block.chain_id],
        }
    ]];

    var bool is_genesis = false;

    // => TX_HASH
    var int txs_n = [[ #THIS.block.txs ]];
    var int i;
    loop i in [0 -> txs_n[ do
        [[ THIS.tx = THIS.block.txs[@txs_n-i] ]];

        if source is SourceBlockHash.Network then
            [[
                assert( type(THIS.tx) == 'string' )
                THIS.tx = THIS.block.txs[THIS.tx] or APP.txs[THIS.tx]
                assert( THIS.tx.nonce ~= nil )
            ]];
        else/if source is SourceBlockHash.File then
            [[
                assert( type(THIS.tx) == 'table' )
                assert( THIS.tx.nonce ~= nil )
            ]];
        else/if source is SourceBlockHash.New then
            [[
                assert( type(THIS.tx) == 'table' )
                assert( THIS.tx.nonce == nil )
            ]];
        else
            _ceu_dbg_assert(0);
        end

        var u8 zeros_wanted = [[ THIS.chain.zeros ]];

        if source is SourceBlockHash.Network then
            vector[HASH_BYTES] byte tx_hash;
            tx_hash = [] .. [[ THIS.tx.hash ]];
            if zeros_wanted > _leading_zeros(&&tx_hash[0],HASH_BYTES) then
// TODO: test-case to fail here
// TODO: also change from ">" to "!="
_ceu_dbg_assert(0);
                escape _ERR_REMOTE_BUG_OR_MALICIOUS;
            end
        end

        vector[] byte pln;
        vector[HASH_BYTES] byte back_hash = [] .. [[ THIS.tx.back_hash ]];
        vector[] byte           payload   = [] .. [[ THIS.tx.payload   ]];

        is_genesis = [[ THIS.tx.back_hash == string.rep('\0',HASH_BYTES) ]];
        if is_genesis then
            _ceu_dbg_assert(not (source is SourceBlockHash.Network));
            _ceu_dbg_assert(txs_n == 1);
            [[
                assert( THIS.tx.payload == '' )
                assert( THIS.tx.nonce   == string.rep('\0',NONCE_BYTES) )
            ]];
            break;

        else/if (source is SourceBlockHash.Network) or (source is SourceBlockHash.File) then
            vector[HASH_BYTES] byte nonce = [] .. [[ THIS.tx.nonce ]];
            pln = []..nonce..back_hash..payload;

            vector[HASH_BYTES] byte tx_hash;
            _ceu_vector_setlen(&&tx_hash,HASH_BYTES,1);
            _crypto_generichash(&&tx_hash[0], HASH_BYTES,
                                &&pln[0], $pln,
                                null, 0);

            [[ THIS.tx_hash = @tx_hash ]];
            if source is SourceBlockHash.Network then
                var bool ok = [[ THIS.tx_hash == THIS.tx.hash ]];
                if not ok then
                    // received hash+nonce do not match
#ifdef FREECHAINS_NO_MALICIOUS
                    _ceu_dbg_assert(0);
#endif
                    escape _ERR_REMOTE_BUG_OR_MALICIOUS;
                end
            else
                _ceu_dbg_assert(zeros_wanted <= _leading_zeros(&&tx_hash[0],HASH_BYTES));
// TODO: change from "<=" to "=="
            end
        else
            pln = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ..back_hash..payload;

            // show async/thread progress
            var int ms = 0;
#if 1
            spawn do
                every 100ms do
                    ms = ms + 100;
                    _printf(".");
                    _fflush(_stdout);
                end
            end
#endif

            // calculate nonce for the leading zeros
            vector[HASH_BYTES] byte tx_hash;
#if 1
            await async/thread (pln,tx_hash,zeros_wanted)
#endif
            do
                var usize len;
                atomic do
                    len = $pln;
                end
                _ceu_dbg_assert(len <= 1024);

                vector[1024] _byte plain2 = _;
                _memcpy(&&plain2[0], &&pln[0], len*sizeof(byte));;

                vector[HASH_BYTES] _byte tx_hash2 = _;

                var int zeros_found = 0;
                var u32 n = do
                    var u32 n_ = 0;
                    var int b00; var int b01;
                    var int b02; var int b03;
                    var int b04; var int b05;
                    var int b06; var int b07;
                    var int b08; var int b09;
                    var int b10; var int b11;
                    var int b12; var int b13;
                    var int b14; var int b15;
                    loop b00 in [0->256[ do loop b01 in [0->256[ do
                    loop b02 in [0->256[ do loop b03 in [0->256[ do
                    loop b04 in [0->256[ do loop b05 in [0->256[ do
                    loop b06 in [0->256[ do loop b07 in [0->256[ do
                    loop b08 in [0->256[ do loop b09 in [0->256[ do
                    loop b10 in [0->256[ do loop b11 in [0->256[ do
                    loop b12 in [0->256[ do loop b13 in [0->256[ do
                    loop b14 in [0->256[ do loop b15 in [0->256[ do
                        n_ = n_ + 1;
                        plain2[ 0]=b00; plain2[ 1]=b01; plain2[ 2]=b02; plain2[ 3]=b03;
                        plain2[ 4]=b04; plain2[ 5]=b05; plain2[ 6]=b06; plain2[ 7]=b07;
                        plain2[ 8]=b08; plain2[ 9]=b09; plain2[10]=b10; plain2[11]=b11;
                        plain2[12]=b12; plain2[13]=b13; plain2[14]=b14; plain2[15]=b15;
                        _crypto_generichash(&&tx_hash2[0], HASH_BYTES,
                                            &&plain2[0], len,
                                            null, 0);
                        zeros_found = _leading_zeros(&&tx_hash2[0], HASH_BYTES);
                        if zeros_found >= zeros_wanted then
                            atomic do
                                _ceu_vector_buf_set(&&pln, 0,
                                                    &&plain2[0], len*sizeof(byte));
                                _ceu_vector_setlen(&&tx_hash,HASH_BYTES,1);
                                _ceu_vector_buf_set(&&tx_hash, 0,
                                                    &&tx_hash2[0], HASH_BYTES*sizeof(byte));
                            end
                            escape n_;
                        end
                    end end
                    end end
                    end end
                    end end
                    end end
                    end end
                    end end
                    end end
                    escape 0;
                end;
                _dbg(0, "client: POW rounds: %d\n", n);
            end

            [[ nonce = {} ]];
            var int j;
            loop j in [0 -> NONCE_BYTES[ do
                [[ nonce[@(j+1)] = string.char(@pln[j]) ]];
            end
            [[
                THIS.tx.nonce = table.concat(nonce)
                THIS.tx_hash = @tx_hash
            ]];
        end

        if not (source is SourceBlockHash.Network) then
            [[
                THIS.tx.hash = THIS.tx_hash
                THIS.block.txs[@(txs_n-i)] = THIS.tx_hash
            ]];
        end
        [[
            APP.txs[THIS.tx_hash] = THIS.tx
        ]];
    end

    // => BLOCK_HASH
    do/_
        vector[HASH_BYTES] byte block_hash;
        _ceu_vector_setlen(&&block_hash,HASH_BYTES,1);

        if is_genesis then
            [[ assert( THIS.block.tail_hash == nil ) ]];

            vector[] byte pln = [] .. [[ THIS.chain.id ]];
            _crypto_generichash(&&block_hash[0], HASH_BYTES,
                                &&pln[0], $pln,
                                null, 0);
            vector[HASH_BYTES] byte tx_hash;
            _ceu_vector_setlen(&&tx_hash,HASH_BYTES,1);
            _crypto_generichash(&&tx_hash[0], HASH_BYTES,
                                &&block_hash[0], $block_hash,
                                null, 0);
            [[
                tx = THIS.block.txs[1]
                tx.hash = @tx_hash
                THIS.block.txs[1] = tx.hash
                APP.txs[tx.hash] = tx
            ]];
        else
            //var int txs_n = [[ #THIS.block.txs ]]; // TODO: assert THIS.block.chain.limits.block
            if txs_n == 0 then
// TODO: test-case
_ceu_dbg_assert(0);
                escape _ERR_REMOTE_BUG_OR_MALICIOUS;
            end

            [[
                if not THIS.block.tail_hash then
                    -- relink only after the yielding parts, avoid "head_hash" race
                    THIS.block.tail_hash = APP.chains[THIS.block.chain_id].head_hash
                end
            ]];
            vector[] byte pln = [] .. [[ THIS.block.tail_hash ]];
            var int i;
            loop i in [0 -> txs_n[ do
                vector[HASH_BYTES] byte tx_hash = [] .. [[ THIS.block.txs[@i+1] ]];
                pln = pln..tx_hash;
            end

            _crypto_generichash(&&block_hash[0], HASH_BYTES,
                                &&pln[0], $pln,
                                null, 0);
        end

        [[
            --print('block',string.len(@block_hash),'\n'..tostring2(@block_hash))
            THIS.block.hash = @block_hash
            APP.blocks[THIS.block.hash] = THIS.block
        ]];
    end

    [[ ARGS = { block=THIS.block } ]];

    escape _ERR_NONE;
end

code/await FS_read_10 (vector&[] byte path) -> int
    // output [[ ARGS = { chain_id, head_hash } ]]
do
    [[
        THIS = {
            chain_id = nil,
            head     = nil,
            base     = nil,
        }
    ]];

    var&? UV_FS_Open f = spawn UV_FS_Open(&&path[0], _O_RDONLY, 0);
    var int? err =
        watching f do
            await f!.file.ok;
            if f!.file.fd < 0 then
                escape f!.file.fd;
            end

            var _uv_stat_t stat = _;
            await UV_FS_Fstat(&f!.file, &stat);
            var u64 size = stat.st_size;

            var usize off = 0;

            // => HEADER
            do
                vector[4] byte buf;
                var ssize n = await UV_FS_Read(&f!.file,&buf,$$buf,off);
                _ceu_dbg_assert(buf[0] == MESSAGE_MAGIC_0);
                _ceu_dbg_assert(buf[1] == MESSAGE_MAGIC_1);
                _ceu_dbg_assert(buf[2] == 1);
                _ceu_dbg_assert(buf[3] == 0);
                _ceu_dbg_assert(n == 4);
                off = off + 4;
            end

            // => CHAIN_ID
            do
                vector[1] byte len_;
                do
                    var ssize n = await UV_FS_Read(&f!.file,&len_,$$len_,off);
                    _ceu_dbg_assert(n == 1);
                    off = off + 1;
                end
                var usize len = len_[0] as usize;

await async do end;
                vector[len] byte buf;
                do
                    var ssize n = await UV_FS_Read(&f!.file,&buf,$$buf,off);
                    _ceu_dbg_assert(n == (len as ssize));
                    off = off + len;
                end
                [[ THIS.chain_id = @buf ]];
                //[[ print('>>> chain_id',@buf) ]];
            end

            // => BLOCKS
            loop do
                if off >= size then
                    _ceu_dbg_assert(off == (size as usize));
                    break;  // EOF
                end

                [[
                    THIS.previous = THIS.block
                    THIS.block = {
                        txs = {},
                        tail_hash = (THIS.previous and THIS.previous.hash) or nil,
                    }
                ]];

                // => TXS
                var u32 txs_n = 0;
                do
                    // => TXS_N
                    vector[sizeof(u32)] byte buf;
                    var ssize n = await UV_FS_Read(&f!.file,&buf,$$buf,off);
                    if n <= 0 then
                        break;
                    end
                    _ceu_dbg_assert(n == (sizeof(u32) as ssize));
                    txs_n = *(&&buf[0] as u32&&);
                    off = off + sizeof(u32);
                end
                var u32 i;
                loop i in [0 -> txs_n[ do
                    // => TXS[i]
                    [[
                        THIS.tx = {}
                        THIS.block.txs[@(i+1)] = THIS.tx
                    ]];

                    // => NONCE
                    vector[NONCE_BYTES] byte nonce;
                    do
                        var ssize n = await UV_FS_Read(&f!.file,&nonce,$$nonce,off);
                        _ceu_dbg_assert(n == NONCE_BYTES);
                        [[ THIS.tx.nonce = @nonce ]];
                        //[[ print('nonce','\n'..tostring2(THIS.tx.nonce)) ]];
                        off = off + NONCE_BYTES;
                    end

                    // => TX_BACH_HASH
                    vector[HASH_BYTES] byte tx_back_hash;
                    do
                        var ssize n = await UV_FS_Read(&f!.file,&tx_back_hash,$$tx_back_hash,off);
                        _ceu_dbg_assert(n == HASH_BYTES);
                        [[ THIS.tx.back_hash = @tx_back_hash ]];
                        //[[ print('back_hash','\n'..tostring2(THIS.tx.back_hash)) ]];
                        off = off + HASH_BYTES;
                    end

                    // => TX_PAYLOAD
                    vector[] byte payload;
                    do
                        var u32 payload_len = 0;
                        do
                            vector[sizeof(u32)] byte buf;
                            var ssize n = await UV_FS_Read(&f!.file,&buf,$$buf,off);
                            _ceu_dbg_assert(n == (sizeof(u32) as ssize));
                            payload_len = *(&&buf[0] as u32&&);
                            //[[ print('payload_len', @payload_len) ]];
                            off = off + sizeof(u32);
                        end
                        do
                            _ceu_vector_setlen(&&payload,payload_len,1);
                            var ssize n = await UV_FS_Read(&f!.file,&payload,payload_len as usize,off);
                            _ceu_dbg_assert(n == (payload_len as ssize));
                            [[ THIS.tx.payload = @payload ]];
                            //[[ print('payload', THIS.tx.payload) ]];
                            off = off + (payload_len as usize);
                        end
                    end
                end

                [[
                    THIS.block.chain_id = THIS.chain_id
                    ARGS = {
                        block = THIS.block,
                    }
                ]];
                var int ret = await BlockHash(SourceBlockHash.File());
                _ceu_dbg_assert(ret == _ERR_NONE);

                [[
                    if THIS.previous then
                        THIS.previous.up_hash = THIS.block.hash
                    end
                ]];
            end

            [[
                ARGS = {
                    chain_id  = THIS.chain_id,
                    head_hash = THIS.block.hash,
                }
            ]];
            escape _ERR_NONE;
        end;
    escape err!;
end

code/await FS_write_10 (vector&[] byte path) -> int
    // input [[ ARGS = { chain_id } ]]
do
#if 0
    PS10
    [i]/*BLOCK_HASH*/ (genesis)
        TXS_N
        [j]/*TX_HASH*/ NONCE TX_BACK_HASH TX_PAYLOAD_LEN TX_PAYLOAD
        ...
    ...
    [n]/*BLOCK_HASH*/ (head)
        ...
#endif

    [[
        chain = APP.chains[ ARGS.chain_id ]
        t = GG.chain_head_base_size(chain.head_hash)
        THIS = {
            base  = t.base,
            chain = chain,
        }
    ]];

    // create/truncate file
    do/_
        var int flags = _O_CREAT|_O_WRONLY|_O_TRUNC;
        var _mode_t mode = _S_IRUSR|_S_IWUSR|_S_IRGRP|_S_IWGRP|_S_IROTH;
        var&? UV_FS_Open f = spawn UV_FS_Open(&&path[0], flags, mode);
        var int? err =
            watching f do
                await f!.file.ok;
            end;
        if err? then
            escape err!;
        end
    end

    // <= (append)
    var&? UV_FS_Open f = spawn UV_FS_Open(&&path[0], _O_APPEND|_O_WRONLY, 0);
    watching f do
        await f!.file.ok;
        _ceu_dbg_assert(f!.file.fd >= 0);

        // <= HEADER
        do
            vector[4] byte buf = [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, 1, 0];
            var ssize n = await UV_FS_Write(&f!.file,&buf,$buf,0);
            _ceu_dbg_assert(n == 4);
        end

        // <= CHAIN_ID
        do
            var byte len = [[ string.len(THIS.chain.id) ]];
            vector[1] byte len_ = [len];
            do
                var ssize n = await UV_FS_Write(&f!.file,&len_,1,0);
                _ceu_dbg_assert(n == 1);
            end

await async do end;
            vector[len] byte buf = [] .. [[ THIS.chain.id ]];
            do
                var ssize n = await UV_FS_Write(&f!.file,&buf,$buf,0);
                _ceu_dbg_assert(n == (len as ssize));
            end
        end

        // <= BLOCKS
        loop do
            // <= TXS
            var u32 txs_n = [[ #THIS.base.txs ]];
            do
                // <= TXS_N
                vector[sizeof(u32)] byte buf;
                _ceu_vector_setlen(&&buf, sizeof(u32), 1);
                _ceu_vector_buf_set(&&buf, 0, &&txs_n, sizeof(u32));
                var ssize n = await UV_FS_Write(&f!.file,&buf,$buf,0);
                _ceu_dbg_assert(n == (sizeof(u32) as ssize));
            end
            var u32 i;
            loop i in [0 -> txs_n[ do
                // <= TXS[i]
                // TX_HASH NONCE TX_BACK_HASH TX_PAYLOAD_LEN TX_PAYLOAD

                [[
                    tx_hash = THIS.base.txs[@i+1]
                    THIS.tx = assert(APP.txs[tx_hash])
                ]];

                // <= NONCE
                do
                    vector[NONCE_BYTES] byte buf = [] .. [[ THIS.tx.nonce ]];
                    var ssize n = await UV_FS_Write(&f!.file,&buf,$buf,0);
                    _ceu_dbg_assert(n == NONCE_BYTES);
                end

                // <= TX_BACK_HASH
                do
                    vector[HASH_BYTES] byte buf = [] .. [[ THIS.tx.back_hash ]];
                    var ssize n = await UV_FS_Write(&f!.file,&buf,$buf,0);
                    _ceu_dbg_assert(n == HASH_BYTES);
                end

                // <= TX_PAYLOAD_LEN
                // <= TX_PAYLOAD
                do
                    var u32 len = [[ string.len(THIS.tx.payload) ]];
                    // <= TX_PAYLOAD_LEN
                    do
                        vector[sizeof(u32)] byte buf;
                        _ceu_vector_setlen(&&buf, sizeof(u32), 1);
                        _ceu_vector_buf_set(&&buf, 0, &&len, sizeof(u32));
                        var ssize n = await UV_FS_Write(&f!.file,&buf,$buf,0);
                        _ceu_dbg_assert(n == (sizeof(u32) as ssize));
                    end
                    // <= TX_PAYLOAD
                    do
                        vector[] byte buf = [] .. [[ THIS.tx.payload ]];
                        var ssize n = await UV_FS_Write(&f!.file,&buf,$buf,0);
                        _ceu_dbg_assert(n == (len as ssize));
                    end
                end
            end

            // NEXT BLOCK
            var bool has = [[ THIS.base.up_hash ~= nil ]];
            if not has then
                break;
            end
            [[
                --print('<<<', '|'..tostring2(THIS.base.hash)..'|')
                THIS.base = assert(APP.blocks[THIS.base.up_hash])
            ]];
        end

        escape _ERR_NONE;
    end
    _ceu_dbg_assert(0);
end

native/pre do
    int SERVERS_ALIVE    = 0;
    int CLIENTS_ALIVE    = 0;
    int BLOCKS_RECEIVED  = 0;
    int BLOCKS_RECREATED = 0;
end
spawn do
    every 10s do
        _printf("SERVERS_ALIVE = %d\n", {SERVERS_ALIVE});
        _printf("CLIENTS_ALIVE = %d\n", {CLIENTS_ALIVE});
    end
end

#include "client.ceu"
#include "server.ceu"
#include "uv/tcp-server.ceu"

code/await Init (void) -> void
do
    var int n_chains = [[ #APP.chains ]];
    var int i;
    loop i in [0 -> n_chains[ do
        [[
            chain = APP.chains[@i+1]
            assert(not chain.head_hash)
        ]];

    // TODO: first try to load from file

        [[
            ARGS = {
                block = {
                    chain_id = chain.id,
                    txs = {
                        {
                            nonce     = string.rep('\0',NONCE_BYTES),
                            back_hash = string.rep('\0',HASH_BYTES),
                            payload   = '',
                        }
                    },
                    tail_hash = nil,
                }
            }
        ]];

        var int ret = await BlockHash(SourceBlockHash.File());
        [[ APP.chains[@i+1].head_hash = ARGS.block.hash ]]
    end
end

code/await App (var& UV_TCP_Server_Data shared) -> void
do
    [[
        dofile 'src/common.lua'
        GG.ERR_REMOTE_BUG_OR_MALICIOUS = @(_ERR_REMOTE_BUG_OR_MALICIOUS as int)
        GG.MESSAGE10_NOTSUB = @(_MESSAGE10_NOTSUB as int)
        APP = app_create()
    ]];
#if 0
    await FOREVER;
#else
    pool[3] Client clients;
    every shared.go_client do       // TODO: "await Spawn_Client()"
        [[
            local chain = assert(APP.chains[ARGS.chain_id])
            ARGS = {
                block = assert(APP.blocks[chain.head_hash]),
                chain = chain,
            }
        ]]

        // kill last/idle client
        var int i = 0;
        var&? Client c;
        loop c in clients do
            i = i + 1;
            if i == 3 then
                kill c;
            end
        end

        spawn Client(&shared) in clients;
    end
#endif
end

#endif
