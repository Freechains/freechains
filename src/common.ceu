#ifndef _COMMON_CEU
#define _COMMON_CEU

//#define DBG 0
//#define FREECHAINS_NO_MALICIOUS

#include "c.ceu"
#include "uv/uv.ceu"
#include "uv/fs.ceu"
#include "uv/tcp.ceu"
#include "sodium.ceu"

#define MESSAGE_BYTES   4
#define MESSAGE_MAGIC_0 {'P'}
#define MESSAGE_MAGIC_1 {'S'}

#define HASH_BYTES      32
#define NONCE_BYTES     16
#define CHAIN_KEY_BYTES 256

native/nohold _dbg, _dbg_tcp;
native/pure _leading_zeros;
native/const
    _ERR_NONE,
    _ERR_MESSAGE,
    _ERR_ABORTED,
    _ERR_REMOTE_BUG_OR_MALICIOUS,
    _MESSAGE10_NOTSUB,
    _MESSAGE10_HAVE,
    _MESSAGE10_LIMIT,
;

native/pre do
    ##define VOID_ALIAS(x) ((void*)&x)

    enum {
        ERR_NONE                    =  0,
        ERR_ABORTED                 = -1,
        ERR_MESSAGE                 = -2,
        ERR_REMOTE_BUG_OR_MALICIOUS = -3,
    };

    enum {
        MESSAGE10 = 1,
    };

    enum {
        MESSAGE10_NOTSUB = 1,   // [ok ACK] not subscribed to this chain
        MESSAGE10_HAVE,         // [ok ACK] already has it
        MESSAGE10_LIMIT,        // [ok ACK] too big for untrusted client
    };

    void dbg (int level, const char* fmt, ...) {
#ifdef DBG
        if (level < DBG) return;
        fprintf(stderr, "[%d] | ", level);
        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    void dbg_tcp (int level, uv_stream_t* tcp, char* client_server, const char* fmt, ...) {
#ifdef DBG
        if (level < DBG) return;
        int p1 = ceu_uv_tcp_getsockport((uv_tcp_t*) tcp);
        int p2 = ceu_uv_tcp_getpeerport((uv_tcp_t*) tcp);
        char str[255];
        char* arrow;
        if (strcmp(client_server,"server") == 0) {
            arrow = "<-";
        } else {
            arrow = "->";
        }
        fprintf(stderr, "[%d] | %s:%d%s%d | ", level, client_server, p1, arrow, p2);

        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    // calculate the number of leading zero bits in "bytes"
    // 00abcdef...  => 2
    int leading_zeros (byte* bytes, int len) {
        int i, j;
        int zeros = 0;
        for (i=0; i<len; i++) {             // loop over "bytes"
            byte b = bytes[i];
            for (j=0; j<8; j++) {           // loop over each bit
                if ((b & (1<<(7-j))) != 0) {
                    return zeros;
                } else {
                    zeros++;
                }
            }
        }
        return zeros;
    }
end
#define G(v) GG[@(&&(v))]
#define THIS GG[@(&&{*_ceu_mem})]

data UV_TCP_Server_Data with
    event (int,int) ok;
    event none unlock;
    event none retransmit;
end

data SourceBlockHash;
data SourceBlockHash.Network;
data SourceBlockHash.File;
data SourceBlockHash.New;

code/await BlockHash (var SourceBlockHash source) -> int
    // input  [[ ARGS = { block={ txs={ tx1, tx2, ... } } }
    // output [[ ARGS = { block={ txs={ tx1_hash, tx2_hash, ... } } }
    // output [[ APP.block[hash]=blk APP.txs[hash]=txs ]]
do
    [[
        THIS = {
            block = ARGS.block,
            chain = APP.chains[ARGS.block.chain_id],
        }
    ]];

    var bool is_genesis = false;

    // => TX_HASH
    var int txs_n = [[ #THIS.block.txs ]];
    var int i;
    loop i in [0 -> txs_n[ do
        [[ THIS.tx = THIS.block.txs[@txs_n-i] ]];

        if source is SourceBlockHash.Network then
            [[
                assert( type(THIS.tx) == 'string' )
                THIS.tx = THIS.block.txs[THIS.tx] or APP.txs[THIS.tx]
                assert( THIS.tx.nonce ~= nil )
            ]];
        else/if source is SourceBlockHash.File then
            [[
                assert( type(THIS.tx) == 'table' )
                assert( THIS.tx.nonce ~= nil )
            ]];
        else/if source is SourceBlockHash.New then
            [[
                assert( type(THIS.tx) == 'table' )
                assert( THIS.tx.nonce == nil )
            ]];
        else
            _ceu_dbg_assert(0);
        end

        var u8 zeros_wanted = [[ THIS.chain.zeros ]];

        if source is SourceBlockHash.Network then
            var[HASH_BYTES] byte tx_hash;
            tx_hash = [] .. [[ THIS.tx.hash ]];
            if zeros_wanted > _leading_zeros(&&tx_hash[0],HASH_BYTES) then
// TODO: test-case to fail here
// TODO: also change from ">" to "!="
_ceu_dbg_assert(0);
                escape _ERR_REMOTE_BUG_OR_MALICIOUS;
            end
        end

        var[] byte pln;
        var[HASH_BYTES] byte back_hash = [] .. [[ THIS.tx.back_hash ]];
        var[] byte           payload   = [] .. [[ THIS.tx.payload   ]];

        is_genesis = [[ THIS.tx.back_hash == string.rep('\0',HASH_BYTES) ]];
        if is_genesis then
            _ceu_dbg_assert(not (source is SourceBlockHash.Network));
            _ceu_dbg_assert(txs_n == 1);
            [[
                assert( THIS.tx.payload == '' )
                assert( THIS.tx.nonce   == string.rep('\0',NONCE_BYTES) )
            ]];
            break;

        else/if (source is SourceBlockHash.Network) or (source is SourceBlockHash.File) then
            var[HASH_BYTES] byte nonce = [] .. [[ THIS.tx.nonce ]];
            pln = []..nonce..back_hash..payload;

            var[HASH_BYTES] byte tx_hash;
            _ceu_vector_setlen(&&tx_hash,HASH_BYTES,1);
            _crypto_generichash(&&tx_hash[0], HASH_BYTES,
                                &&pln[0], $pln,
                                null, 0);

            [[ THIS.tx_hash = @tx_hash ]];
            if source is SourceBlockHash.Network then
                var bool ok = [[ THIS.tx_hash == THIS.tx.hash ]];
                if not ok then
                    // received hash+nonce do not match
#ifdef FREECHAINS_NO_MALICIOUS
                    _ceu_dbg_assert(0);
#endif
                    escape _ERR_REMOTE_BUG_OR_MALICIOUS;
                end
            else
                _ceu_dbg_assert(zeros_wanted <= _leading_zeros(&&tx_hash[0],HASH_BYTES));
// TODO: change from "<=" to "=="
            end
        else
            pln = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ..back_hash..payload;

            // show async/thread progress
            var int ms = 0;
#if 1
            spawn do
                every 100ms do
                    ms = ms + 100;
                    _printf(".");
                    _fflush(_stdout);
                end
            end
#endif

            // calculate nonce for the leading zeros
            var[HASH_BYTES] byte tx_hash;

            var usize len = $pln;
            var[] byte plain2 = []..pln;

#if 1
            await async/thread (pln,plain2,len,tx_hash,zeros_wanted)
#endif
            do
                var[HASH_BYTES] _byte tx_hash2 = _;

                var int zeros_found = 0;
                var u32 n = do
                    var u32 n_ = 0;
                    var int b00; var int b01;
                    var int b02; var int b03;
                    var int b04; var int b05;
                    var int b06; var int b07;
                    var int b08; var int b09;
                    var int b10; var int b11;
                    var int b12; var int b13;
                    var int b14; var int b15;
                    loop b00 in [0->256[ do loop b01 in [0->256[ do
                    loop b02 in [0->256[ do loop b03 in [0->256[ do
                    loop b04 in [0->256[ do loop b05 in [0->256[ do
                    loop b06 in [0->256[ do loop b07 in [0->256[ do
                    loop b08 in [0->256[ do loop b09 in [0->256[ do
                    loop b10 in [0->256[ do loop b11 in [0->256[ do
                    loop b12 in [0->256[ do loop b13 in [0->256[ do
                    loop b14 in [0->256[ do loop b15 in [0->256[ do
                        n_ = n_ + 1;
                        plain2[ 0]=b00; plain2[ 1]=b01; plain2[ 2]=b02; plain2[ 3]=b03;
                        plain2[ 4]=b04; plain2[ 5]=b05; plain2[ 6]=b06; plain2[ 7]=b07;
                        plain2[ 8]=b08; plain2[ 9]=b09; plain2[10]=b10; plain2[11]=b11;
                        plain2[12]=b12; plain2[13]=b13; plain2[14]=b14; plain2[15]=b15;
                        _crypto_generichash(&&tx_hash2[0], HASH_BYTES,
                                            &&plain2[0], len,
                                            null, 0);
                        zeros_found = _leading_zeros(&&tx_hash2[0], HASH_BYTES);
                        if zeros_found >= zeros_wanted then
                            atomic do
                                _ceu_vector_buf_set(&&pln, 0,
                                                    &&plain2[0], len*sizeof(byte));
                                _ceu_vector_setlen(&&tx_hash,HASH_BYTES,1);
                                _ceu_vector_buf_set(&&tx_hash, 0,
                                                    &&tx_hash2[0], HASH_BYTES*sizeof(byte));
                            end
                            escape n_;
                        end
                    end end
                    end end
                    end end
                    end end
                    end end
                    end end
                    end end
                    end end
                    escape 0;
                end;
                _dbg(0, "client: POW rounds: %d\n", n);
            end

            [[ nonce = {} ]];
            var int j;
            loop j in [0 -> NONCE_BYTES[ do
                [[ nonce[@(j+1)] = string.char(@pln[j]) ]];
            end
            [[
                THIS.tx.nonce = table.concat(nonce)
                THIS.tx_hash = @tx_hash
            ]];
        end

        if not (source is SourceBlockHash.Network) then
            [[
                THIS.tx.hash = THIS.tx_hash
                THIS.block.txs[@(txs_n-i)] = THIS.tx_hash
            ]];
        end
        [[
            APP.txs[THIS.tx_hash] = THIS.tx
        ]];
    end

    // => BLOCK_HASH
    do/_
        var[HASH_BYTES] byte block_hash;
        _ceu_vector_setlen(&&block_hash,HASH_BYTES,1);

        if is_genesis then
            [[ assert( THIS.block.tail_hash == nil ) ]];

            var[] byte pln = [] .. [[ THIS.chain.id ]];
            _crypto_generichash(&&block_hash[0], HASH_BYTES,
                                &&pln[0], $pln,
                                null, 0);
            var[HASH_BYTES] byte tx_hash;
            _ceu_vector_setlen(&&tx_hash,HASH_BYTES,1);
            _crypto_generichash(&&tx_hash[0], HASH_BYTES,
                                &&block_hash[0], $block_hash,
                                null, 0);
            [[
                tx = THIS.block.txs[1]
                tx.hash = @tx_hash
                THIS.block.txs[1] = tx.hash
                APP.txs[tx.hash] = tx
            ]];
        else
            //var int txs_n = [[ #THIS.block.txs ]]; // TODO: assert THIS.block.chain.limits.block
            if txs_n == 0 then
// TODO: test-case
_ceu_dbg_assert(0);
                escape _ERR_REMOTE_BUG_OR_MALICIOUS;
            end

            [[
                if not THIS.block.tail_hash then
                    -- relink only after the yielding parts, anone "head_hash" race
                    THIS.block.tail_hash = APP.chains[THIS.block.chain_id].head_hash
                end
            ]];
            var[] byte pln = [] .. [[ THIS.block.tail_hash ]];
            var int i;
            loop i in [0 -> txs_n[ do
                var[HASH_BYTES] byte tx_hash = [] .. [[ THIS.block.txs[@i+1] ]];
                pln = pln..tx_hash;
            end

            _crypto_generichash(&&block_hash[0], HASH_BYTES,
                                &&pln[0], $pln,
                                null, 0);
        end

        [[
            --print('block',string.len(@block_hash),'\n'..tostring2(@block_hash))
            THIS.block.hash = @block_hash
            APP.blocks[THIS.block.hash] = THIS.block
        ]];
    end

    [[ ARGS = { block=THIS.block } ]];

    escape _ERR_NONE;
end

code/await FS_read_10 (var&[] byte path) -> none
    throws Exception.Uv
    // output [[ ARGS = { chain_id, head_hash } ]]
do
    [[
        THIS = {
            chain_id = nil,
            head     = nil,
            base     = nil,
        }
    ]];

    var& UV_FS_Open o = spawn UV_FS_Open(&&path[0],_,_,_);
    await o.file.ok;

    var _uv_stat_t stat = _;
    await UV_FS_Fstat(&o.file, &stat);
    var u64 size = stat.st_size;

    // => HEADER
    do
        var ssize n = await UV_FS_Read_N(&o.file, MESSAGE_BYTES);
        _ceu_dbg_assert(o.file.buffer[0] == MESSAGE_MAGIC_0);
        _ceu_dbg_assert(o.file.buffer[1] == MESSAGE_MAGIC_1);
        _ceu_dbg_assert(o.file.buffer[2] == 1);
        _ceu_dbg_assert(o.file.buffer[3] == 0);
        _ceu_dbg_assert(n == MESSAGE_BYTES);
        $o.file.buffer = 0;
    end

    // => CHAIN_ID
    do
        var usize len;
        do
            var ssize n = await UV_FS_Read_N(&o.file, 1);
            _ceu_dbg_assert(n == 1);
            len = o.file.buffer[0] as usize;
            $o.file.buffer = 0;
        end

        do
            var ssize n = await UV_FS_Read_N(&o.file, len);
            _ceu_dbg_assert(n == len);
            [[ THIS.chain_id = @o.file.buffer ]];
            $o.file.buffer = 0;
        end
        //[[ print('>>> chain_id',@buf) ]];
    end

    // => BLOCKS
    loop do
        // => TXS
        var u32 txs_n = _;
        do
            // => TXS_N
            var[sizeof(u32)] byte buf;
            var ssize n = await UV_FS_Read_N(&o.file, sizeof(u32));
            if n <= 0 then
                break;          // EOF
            end
            _ceu_dbg_assert(n == sizeof(u32));
            txs_n = *(&&o.file.buffer[0] as u32&&);
            $o.file.buffer = 0;
        end

        // OK, non-emtpy block
        [[
            THIS.previous = THIS.block
            THIS.block = {
                txs = {},
                tail_hash = (THIS.previous and THIS.previous.hash) or nil,
            }
        ]];

        var u32 i;
        loop i in [0 -> txs_n[ do
            // => TXS[i]
            [[
                THIS.tx = {}
                THIS.block.txs[@(i+1)] = THIS.tx
            ]];

            // => NONCE
            do
                var ssize n = await UV_FS_Read_N(&o.file, NONCE_BYTES);
                _ceu_dbg_assert(n == NONCE_BYTES);
                [[ THIS.tx.nonce = @o.file.buffer ]];
                //[[ print('nonce','\n'..tostring2(THIS.tx.nonce)) ]];
                $o.file.buffer = 0;
            end

            // => TX_BACH_HASH
            do
                var ssize n = await UV_FS_Read_N(&o.file, HASH_BYTES);
                _ceu_dbg_assert(n == HASH_BYTES);
                [[ THIS.tx.back_hash = @o.file.buffer ]];
                //[[ print('back_hash','\n'..tostring2(THIS.tx.back_hash)) ]];
                $o.file.buffer = 0;
            end

            // => TX_PAYLOAD
            do
                var u32 payload_len;
                do
                    var ssize n = await UV_FS_Read_N(&o.file, sizeof(u32));
                    _ceu_dbg_assert(n == sizeof(u32));
                    payload_len = *(&&o.file.buffer[0] as u32&&);
                    //[[ print('payload_len', @payload_len) ]];
                    $o.file.buffer = 0;
                end
                do
                    var ssize n = await UV_FS_Read_N(&o.file, payload_len as usize);
                    _ceu_dbg_assert(n == (payload_len as ssize));
                    [[ THIS.tx.payload = @o.file.buffer ]];
                    //[[ print('payload', THIS.tx.payload) ]];
                    $o.file.buffer = 0;
                end
            end
        end

        [[
            THIS.block.chain_id = THIS.chain_id
            ARGS = {
                block = THIS.block,
            }
        ]];
        var int ret = await BlockHash(SourceBlockHash.File());
        _ceu_dbg_assert(ret == _ERR_NONE);

        [[
            if THIS.previous then
                THIS.previous.up_hash = THIS.block.hash
            else
                --assert(not THIS.genesis_hash)
                --THIS.genesis_hash = THIS.block.hash
            end
        ]];
    end

    [[
        ARGS = {
            chain_id  = THIS.chain_id,
            head_hash = THIS.block.hash,
            --genesis_hash = THIS.genesis_hash,
        }
    ]];
end

code/await FS_write_10 (var&[] byte path) -> none
    throws Exception.Uv
    // input [[ ARGS = { chain_id } ]]
do
#if 0
    PS10
    [i]/*BLOCK_HASH*/ (genesis)
        TXS_N
        [j]/*TX_HASH*/ NONCE TX_BACK_HASH TX_PAYLOAD_LEN TX_PAYLOAD
        ...
    ...
    [n]/*BLOCK_HASH*/ (head)
        ...
#endif

    [[
        chain = APP.chains[ ARGS.chain_id ]
        t = GG.chain_head_base_size(chain.head_hash)
        THIS = {
            base  = t.base,
            chain = chain,
        }
    ]];

    // create/truncate file
    do/_
        var int flags = _O_CREAT|_O_WRONLY|_O_TRUNC;
        var _mode_t mode = _S_IRUSR|_S_IWUSR|_S_IRGRP|_S_IWGRP|_S_IROTH;
        var& UV_FS_Open o = spawn UV_FS_Open(&&path[0], _, flags, mode);
        await o.file.ok;
    end

    // <= (append)
    var& UV_FS_Open o = spawn UV_FS_Open(&&path[0], _, _O_APPEND|_O_WRONLY, 0);
    await o.file.ok;
    _ceu_dbg_assert(o.file.handle >= 0);

    // <= HEADER
    do
        o.file.buffer = [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, 1, 0];
        var ssize n = await UV_FS_Write_N(&o.file, MESSAGE_BYTES);
        _ceu_dbg_assert(n == 4);
    end

    // <= CHAIN_ID
    do
        var byte len = [[ string.len(THIS.chain.id) ]];
        do
            o.file.buffer = [len];
            var ssize n = await UV_FS_Write_N(&o.file, 1);
            _ceu_dbg_assert(n == 1);
        end
        do
            o.file.buffer = [] .. [[ THIS.chain.id ]];
            var ssize n = await UV_FS_Write_N(&o.file, len as usize);
            _ceu_dbg_assert(n == (len as ssize));
        end
    end

    // <= BLOCKS
    loop do
        // <= TXS
        var u32 txs_n = [[ #THIS.base.txs ]];
        do
            // <= TXS_N
            _ceu_vector_setlen(&&o.file.buffer, sizeof(u32), 1);
            _ceu_vector_buf_set(&&o.file.buffer, 0, (&&txs_n as byte&&), sizeof(u32));
            var ssize n = await UV_FS_Write_N(&o.file, sizeof(u32));
            _ceu_dbg_assert(n == sizeof(u32));
        end
        var u32 i;
        loop i in [0 -> txs_n[ do
            // <= TXS[i]
            // TX_HASH NONCE TX_BACK_HASH TX_PAYLOAD_LEN TX_PAYLOAD

            [[
                tx_hash = THIS.base.txs[@i+1]
                THIS.tx = assert(APP.txs[tx_hash])
            ]];

            // <= NONCE
            do
                o.file.buffer = [] .. [[ THIS.tx.nonce ]];
                var ssize n = await UV_FS_Write_N(&o.file, NONCE_BYTES);
                _ceu_dbg_assert(n == NONCE_BYTES);
            end

            // <= TX_BACK_HASH
            do
                o.file.buffer = [] .. [[ THIS.tx.back_hash ]];
                var ssize n = await UV_FS_Write_N(&o.file, HASH_BYTES);
                _ceu_dbg_assert(n == HASH_BYTES);
            end

            // <= TX_PAYLOAD_LEN
            // <= TX_PAYLOAD
            do
                var u32 len = [[ string.len(THIS.tx.payload) ]];
                // <= TX_PAYLOAD_LEN
                do
                    _ceu_vector_setlen(&&o.file.buffer, sizeof(u32), 1);
                    _ceu_vector_buf_set(&&o.file.buffer, 0, (&&len as byte&&), sizeof(u32));
                    var ssize n = await UV_FS_Write_N(&o.file, sizeof(u32));
                    _ceu_dbg_assert(n == sizeof(u32));
                end
                // <= TX_PAYLOAD
                do
// TODO: may not fit default buffer length (1024)
                    o.file.buffer = [] .. [[ THIS.tx.payload ]];
                    var ssize n = await UV_FS_Write_N(&o.file, len as usize);
                    _ceu_dbg_assert(n == (len as usize));
                end
            end
        end

        // NEXT BLOCK
        var bool has = [[ THIS.base.up_hash ~= nil ]];
        if not has then
            break;
        end
        [[
            --print('<<<', '|'..tostring2(THIS.base.hash)..'|')
            THIS.base = assert(APP.blocks[THIS.base.up_hash])
        ]];
    end
end

native/pre do
    int SERVERS_ALIVE    = 0;
    int CLIENTS_ALIVE    = 0;
    int BLOCKS_RECEIVED  = 0;
    int BLOCKS_RECREATED = 0;
    int TXS_RECREATED = 0;
end
#if 0
spawn do
    every 10s do
        _printf("SERVERS_ALIVE = %d\n", {SERVERS_ALIVE});
        _printf("CLIENTS_ALIVE = %d\n", {CLIENTS_ALIVE});
    end
end
#endif

#include "client.ceu"
#include "server.ceu"
#include "uv/tcp-server.ceu"

code/await Init (none) -> none
do
    [[
        GG.ERR_REMOTE_BUG_OR_MALICIOUS = @(_ERR_REMOTE_BUG_OR_MALICIOUS as int)
        GG.MESSAGE10_NOTSUB = @(_MESSAGE10_NOTSUB as int)
    ]]

    var int n_chains = [[ #APP.chains ]];
    var int i;
    loop i in [0 -> n_chains[ do
        [[
            chain = APP.chains[@i+1]
            assert(not chain.head_hash)

            path = APP.chains.files..'/'..chain.id..'.chain'
        ]]
        var[] byte path = [] .. [[path]];
        var Exception? e;
        catch e do
            await FS_read_10(&path);
        end
        if not e? then
            [[
                -- TODO: assert chain.id==file header
                --chain.genesis_hash = ARGS.genesis_hash
                chain.head_hash = ARGS.head_hash
            ]];
        else
            //_dbg(0, "main: file not found: %s", &&path[0]);
            [[
                ARGS = {
                    block = {
                        chain_id = chain.id,
                        txs = {
                            {
                                nonce     = string.rep('\0',NONCE_BYTES),
                                back_hash = string.rep('\0',HASH_BYTES),
                                payload   = '',
                            }
                        },
                        tail_hash = nil,
                    }
                }
            ]];
            var int ret = await BlockHash(SourceBlockHash.File());
            _ceu_dbg_assert(ret == _ERR_NONE);
            [[
                --chain.genesis_hash = ARGS.block.genesis_hash
                chain.head_hash = ARGS.block.hash
            ]];
        end
    end
end

#endif
