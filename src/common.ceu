#ifndef _COMMON_CEU
#define _COMMON_CEU

//#define DBG 0

#include "c.ceu"
#include "uv.ceu"
#include "sodium.ceu"

#define MESSAGE_BYTES   4
#define MESSAGE_MAGIC_0 'P'
#define MESSAGE_MAGIC_1 'S'

#define HASH_BYTES      32
#define NONCE_BYTES     16
#define CHAIN_KEY_BYTES 256

native @pure _leading_zeros();
native @nohold _dbg(), _dbg_tcp();
native do
    ##define VOID_ALIAS(x) ((void*)&x)

    enum {
        ERR_NONE                    =  0,
        ERR_MESSAGE                 = -1,
        ERR_REMOTE_BUG_OR_MALICIOUS = -2,
    };

    enum {
        MESSAGE10 = 1,
    };

    enum {
        MESSAGE10_NOTSUB = 1,   // [ok ACK] not subscribed to this chain
        MESSAGE10_HAVE,         // [ok ACK] already has it
        MESSAGE10_LIMIT,        // [ok ACK] too big for untrusted client
    };

    void dbg (int level, const char* fmt, ...) {
#ifdef DBG
        if (level < DBG) return;
        fprintf(stderr, "[%d] | ", level);
        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    void dbg_tcp (int level, uv_tcp_t* tcp, char* client_server, const char* fmt, ...) {
#ifdef DBG
        if (level < DBG) return;
        int p1 = ceu_uv_tcp_getsockport(tcp);
        int p2 = ceu_uv_tcp_getpeerport(tcp);
        char str[255];
        char* arrow;
        if (strcmp(client_server,"server") == 0) {
            arrow = "<-";
        } else {
            arrow = "->";
        }
        fprintf(stderr, "[%d] | %s:%d%s%d | ", level, client_server, p1, arrow, p2);

        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    // calculate the number of leading zero bits in "bytes"
    // 00abcdef...  => 2
    int leading_zeros (byte* bytes, int len) {
        int i, j;
        int zeros = 0;
        for (i=0; i<len; i++) {             // loop over "bytes"
            byte b = bytes[i];
            for (j=0; j<8; j++) {           // loop over each bit
                if ((b & (1<<(7-j))) != 0) {
                    return zeros;
                } else {
                    zeros++;
                }
            }
        }
        return zeros;
    }
end
#define G(v) GG[@(&&(v))]

interface Global with
    event void recv_chain_unlocked;
    event void send_chain_unlocked;
end
event void recv_chain_unlocked;
event void send_chain_unlocked;

class FS_read_10 with
    var char[]& path;
    // output [[ ARGS = { head_hash } ]]
    function (char[]& path)=>FS_read_10 run;
do
    function (char[]& path)=>FS_read_10 run do
        this.path = &path;
    end

    [[
        G(this) = {
            head = nil,
            base = nil,
        }
    ]];

    var UV_FS_open o = UV_FS_open.build(&this.path, _O_RDONLY, 0);
    await o.ok;
    if o.fd < 0 then
        escape o.fd;
    end

    var _uv_stat_t stat = _uv_stat_t();
    do UV_FS_fstat.run(&o, &stat);
    var u64 size = stat.st_size;

    var int off = size;

    // => HEADER
    do
        var byte[4] buf;
        var int n = do UV_FS_read.run(&o,&buf,$$buf,0);
        _assert(buf[0] == MESSAGE_MAGIC_0);
        _assert(buf[1] == MESSAGE_MAGIC_1);
        _assert(buf[2] == 1);
        _assert(buf[3] == 0);
        _assert(n == 4);
    end

    // => BLOCKS
    loop do
        if off == 4 then
            break;  // back to the header
        end

        [[
            G(this).block = {
                txs = {}
            }
        ]];

        // => TXS
        var u32 txs_n = 0;
        do
            // => TXS_N
            off = off - sizeof(u32);
            var byte[sizeof(u32)] buf;
            var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
            if n <= 0 then
                break;
            end
            _assert(n == sizeof(u32));
            txs_n = *((u32&&)(_byte&&)&&buf);
        end
        loop i in txs_n do
            // => TXS[i]
            [[ G(this).tx = {} ]];

            // => TX_PAYLOAD
            var char[] payload;
            do
                var u32 payload_len = 0;
                do
                    off = off - sizeof(u32);
                    var byte[sizeof(u32)] buf;
                    var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
                    _assert(n == sizeof(u32));
                    payload_len = *((u32&&)(_byte&&)&&buf);
                    //[[ print('payload_len', @payload_len) ]];
                end
                do
                    off = off - payload_len;
                    $payload := payload_len;
                    var int n = do UV_FS_read.run(&o,&payload,payload_len,off);
                    _assert(n == payload_len);
                    [[ G(this).tx.payload = @payload ]];
                    //[[ print('payload', G(this).tx.payload) ]];
                end
            end

            // => TX_BACH_HASH
            var char[HASH_BYTES] tx_back_hash;
            do
                off = off - HASH_BYTES;
                var int n = do 
                UV_FS_read.run(&o,&tx_back_hash,$$tx_back_hash,off); _assert(n == HASH_BYTES);
                [[ G(this).tx.back_hash = @tx_back_hash ]];
                //[[ print('back_hash','\n'..tostring2(G(this).tx.back_hash)) ]];
            end

            // => NONCE
            var char[NONCE_BYTES] nonce;
            do
                off = off - NONCE_BYTES;
                var int n = do UV_FS_read.run(&o,&nonce,$$nonce,off);
                _assert(n == NONCE_BYTES);
                [[ G(this).tx.nonce = @nonce ]];
                //[[ print('nonce','\n'..tostring2(G(this).tx.nonce)) ]];
            end

            // => TX_HASH
            do
                var char[HASH_BYTES] hash;
                var byte[] plain = []..nonce..tx_back_hash..payload;
                $hash := HASH_BYTES;
                _crypto_generichash((_byte&&)(_char&&)&&hash, HASH_BYTES,
                                    (_byte&&)&&plain, $plain,
                                    null, 0);
                [[
                    tx_hash = @hash
                    G(this).tx.hash = tx_hash
                    G(this).block.txs[@(txs_n-i)] = tx_hash
                    APP.txs[tx_hash] = G(this).tx
                ]];
            end
        end

        // => HASH
        do
            var char[HASH_BYTES] hash;
            var byte[]           plain;

            var int n = [[ #G(this).block.txs ]]; // TODO: assert ARGS.block.chain.limits.block
            loop i in n do
                var char[HASH_BYTES] tx_hash = [[ G(this).block.txs[@i+1] ]];
                plain = []..plain..tx_hash;
            end

            $hash := HASH_BYTES;
            _crypto_generichash((_byte&&)(_char&&)&&hash, HASH_BYTES,
                                (_byte&&)&&plain, $plain,
                                null, 0);

            [[
                hash = @hash;
                --print('block',string.len(hash),'\n'..tostring2(hash))
                G(this).block.hash = hash
                APP.blocks[hash] = G(this).block

                if not G(this).head then
                    G(this).head = G(this).block
                end
                if G(this).base then
                    G(this).base.tail_hash = G(this).block.hash
                    G(this).block.up_hash = G(this).base.hash
                end
                G(this).base = G(this).block
            ]];
        end
    end

    [[
        ARGS = {
            head_hash = G(this).head.hash
        }
    ]];
    escape _ERR_NONE;
end

class FS_write_10 with
    var char[]& path;
    // input [[ ARGS = { head_hash } ]]
    function (char[]& path)=>FS_write_10 run;
do
    function (char[]& path)=>FS_write_10 run do
        this.path = &path;
    end

    #if 0
    PS10
    [i]/*BLOCK_HASH*/ (genesis)
        TXS_N
        [j]/*TX_HASH*/ NONCE TX_BACK_HASH TX_PAYLOAD_LEN TX_PAYLOAD
        ...
    ...
    [n]/*BLOCK_HASH*/ (head)
        ...
    #endif

    [[
        t = GG.chain_head_base_size(ARGS.head_hash)
        G(this) = {
            base = t.base,
        }
    ]];

    // create/truncate file
    do
        var int flags = _O_CREAT|_O_WRONLY|_O_TRUNC;
        var _mode_t mode = _S_IRUSR|_S_IWUSR|_S_IRGRP|_S_IWGRP|_S_IROTH;
        var UV_FS_open o = UV_FS_open.build(&this.path, flags, mode);
        await o.ok;
        if o.fd < 0 then
            escape o.fd;
        end
    end

    // <= (append)
    var UV_FS_open o = UV_FS_open.build(&this.path, _O_APPEND|_O_WRONLY, 0);
    await o.ok;
    _assert(o.fd >= 0);

    // <= HEADER
    do
        var byte[4] buf = [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, 1, 0];
        var int n = do UV_FS_write.run(&o,&buf,$buf,0);
        _assert(n == 4);
    end
    // <= BLOCKS
    loop do
        // <= TXS
        var u32 txs_n = [[ #G(this).base.txs ]];
        loop i in txs_n do
            // <= TXS[i]
            // TX_HASH NONCE TX_BACK_HASH TX_PAYLOAD_LEN TX_PAYLOAD

            [[
                tx_hash = G(this).base.txs[@i+1]
                tx      = assert(APP.txs[tx_hash])
            ]];

            // <= NONCE
            do
                var char[NONCE_BYTES] buf = [[ tx.nonce ]];
                var int n = do UV_FS_write.run(&o,&buf,$buf,0);
                _assert(n == NONCE_BYTES);
            end

            // <= TX_BACK_HASH
            do
                var char[HASH_BYTES] buf = [[ tx.back_hash ]];
                var int n = do UV_FS_write.run(&o,&buf,$buf,0);
                _assert(n == HASH_BYTES);
            end

            // <= TX_PAYLOAD
            // <= TX_PAYLOAD_LEN
            do
                var u32 len = [[ string.len(tx.payload) ]];
                // <= TX_PAYLOAD
                do
                    var char[] buf = [[ tx.payload ]];
                    var int n = do UV_FS_write.run(&o,&buf,$buf,0);
                    _assert(n == len);
                end
                // <= TX_PAYLOAD_LEN
                do
                    var char[sizeof(u32)] buf;
                    _ceu_vector_copy_buffer(&&buf, 0, (byte&&)&&len, sizeof(u32), 1);
                    var int n = do UV_FS_write.run(&o,&buf,$buf,0);
                    _assert(n == sizeof(u32));
                end
            end
        end
        do
            // <= TXS_N
            var char[sizeof(u32)] buf;
            _ceu_vector_copy_buffer(&&buf, 0, (byte&&)&&txs_n, sizeof(u32), 1);
            var int n = do UV_FS_write.run(&o,&buf,$buf,0);
            _assert(n == sizeof(u32));
        end

        // NEXT BLOCK
        var bool has = [[ G(this).base.up_hash ~= nil ]];
        if not has then
            break;
        end
        [[
            --print('<<<', '|'..tostring2(G(this).base.hash)..'|')
            G(this).base = assert(APP.blocks[G(this).base.up_hash])
        ]];
    end

    escape _ERR_NONE;
end

#include "client.ceu"
#define UV_TCP_SERVER_HANDLER_CEU server.ceu
#include "uv-server.ceu"

[[
    dofile'src/common.lua'
    GG.ERR_REMOTE_BUG_OR_MALICIOUS = @((int)_ERR_REMOTE_BUG_OR_MALICIOUS)
    GG.MESSAGE10_NOTSUB = @((int)_MESSAGE10_NOTSUB)
]];

#endif
