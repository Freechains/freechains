#ifndef _COMMON_CEU
#define _COMMON_CEU

//#define DBG 2
//#define FREECHAINS_NO_MALICIOUS

#include "c.ceu"
#include "uv/tcp.ceu"
#include "sodium.ceu"

#define MESSAGE_BYTES   4
#define MESSAGE_MAGIC_0 'P'
#define MESSAGE_MAGIC_1 'S'

#define HASH_BYTES      32
#define NONCE_BYTES     16
#define CHAIN_KEY_BYTES 256

#define G(v) GG[@(&&(v))]

native _byte;
native/const _ERR_NONE, _ERR_MESSAGE, _ERR_REMOTE_BUG_OR_MALICIOUS;
native/pure _leading_zeros;
native/nohold _dbg;
native/pre do
    enum {
        ERR_NONE                    =  0,
        ERR_MESSAGE                 = -1,
        ERR_REMOTE_BUG_OR_MALICIOUS = -2,
    };

    void dbg (int level, const char* fmt, ...) {
#ifdef DBG
        if (level < DBG) return;
        fprintf(stderr, "[%d] | ", level);
        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    // calculate the number of leading zero bits in "bytes"
    // 00abcdef...  => 2
    int leading_zeros (byte* bytes, int len) {
        int i, j;
        int zeros = 0;
        for (i=0; i<len; i++) {             // loop over "bytes"
            byte b = bytes[i];
            for (j=0; j<8; j++) {           // loop over each bit
                if ((b & (1<<(7-j))) != 0) {
                    return zeros;
                } else {
                    zeros++;
                }
            }
        }
        return zeros;
    }
end

[[
    dofile'src/common.lua'
#if 0
    GG.ERR_REMOTE_BUG_OR_MALICIOUS = @(_ERR_REMOTE_BUG_OR_MALICIOUS as int)
    GG.MESSAGE10_NOTSUB = @(_MESSAGE10_NOTSUB as int)
#endif
]];

data BlockHashSource;
data BlockHashSource.Network;
data BlockHashSource.File;
data BlockHashSource.New;

code/await BlockHash (var BlockHashSource source) => int
    // input  [[ ARGS = { block={ txs={ tx1, tx2, ... } } }
    // output [[ ARGS = { block={ txs={ tx1_hash, tx2_hash, ... } } }
    // output [[ APP.block[hash]=blk APP.txs[hash]=txs ]]
do
    var int this = 0;
    [[
        G(this) = {
            block = ARGS.block,
            chain = APP.chains[ARGS.block.chain_id],
        }
    ]];

    var bool is_genesis = false;

    // => TX_HASH
    var int txs_n = [[ #G(this).block.txs ]];
    loop i in [0 -> txs_n[ do
        [[ G(this).tx = G(this).block.txs[@txs_n-i] ]];

        if source is BlockHashSource.Network then
            [[
                assert( type(G(this).tx) == 'string' )
                G(this).tx = G(this).block.txs[G(this).tx] or APP.txs[G(this).tx]
                assert( G(this).tx.nonce ~= nil )
            ]];
        else/if source is BlockHashSource.File then
            [[
                assert( type(G(this).tx) == 'table' )
                assert( G(this).tx.nonce ~= nil )
            ]];
        else/if source is BlockHashSource.New then
            [[
                assert( type(G(this).tx) == 'table' )
                assert( G(this).tx.nonce == nil )
            ]];
        else
            _ceu_dbg_assert(0);
        end

        var u8 zeros_wanted = [[ G(this).chain.zeros ]];

        if source is BlockHashSource.Network then
            vector[HASH_BYTES] byte tx_hash;
            tx_hash = []..[[ G(this).tx.hash ]];
            if zeros_wanted > _leading_zeros(&&tx_hash[0],HASH_BYTES) then
// TODO: test-case to fail here
// TODO: also change from ">" to "!="
_ceu_dbg_assert(0);
                escape _ERR_REMOTE_BUG_OR_MALICIOUS;
            end
        end

        vector[]           byte plain;
        vector[HASH_BYTES] byte back_hash = []..[[ G(this).tx.back_hash ]];
        vector[]           byte payload   = []..[[ G(this).tx.payload   ]];

        is_genesis = [[ G(this).tx.back_hash == string.rep('\0',HASH_BYTES) ]];
        if is_genesis then
            _ceu_dbg_assert(not (source is BlockHashSource.Network));
            _ceu_dbg_assert(txs_n == 1);
            [[
                assert( G(this).tx.payload == '' )
                assert( G(this).tx.nonce   == string.rep('\0',NONCE_BYTES) )
            ]];
            break;

        else/if (source is BlockHashSource.Network) or
                (source is BlockHashSource.File)
        then
            vector[HASH_BYTES] byte nonce = []..[[ G(this).tx.nonce ]];
            plain = []..nonce..back_hash..payload;

            vector[HASH_BYTES] byte tx_hash;
            _ceu_vector_setlen(&&tx_hash, HASH_BYTES, 1);
            _crypto_generichash(&&tx_hash[0], HASH_BYTES,
                                &&plain[0], $plain,
                                null, 0);

            [[ G(this).tx_hash = @tx_hash ]];
            if source is BlockHashSource.Network then
                var bool ok = [[ G(this).tx_hash == G(this).tx.hash ]];
                if not ok then
                    // received hash+nonce do not match
#ifdef FREECHAINS_NO_MALICIOUS
                    _ceu_dbg_assert(0);
#endif
                    escape _ERR_REMOTE_BUG_OR_MALICIOUS;
                end
            else
                _ceu_dbg_assert(zeros_wanted <= _leading_zeros(&&tx_hash[0],HASH_BYTES));
// TODO: change from "<=" to "=="
            end
        else
            plain = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ..back_hash..payload;

            // show async/thread progress
            var int ms = 0;
#if 1
            spawn do
                every 100ms do
                    ms = ms + 100;
                    _printf(".");
                    _fflush(_stdout);
                end
            end
#endif

            // calculate nonce for the leading zeros
            vector[HASH_BYTES] byte tx_hash;
#if 0
            await async/thread (plain,tx_hash,zeros_wanted)
#endif
            do
                var usize len;
                atomic do
                    len = $plain;
                end
                _ceu_dbg_assert(len <= 1024);

                vector[1024] _byte plain2 = _;
                _memcpy(&&plain2[0], &&plain[0], len*sizeof(byte));;

                vector[HASH_BYTES] _byte tx_hash2 = _;

                var int zeros_found = 0;
                var u32 n = do
                    var u32 n_ = 0;
                    loop b00 in [0->256] do loop b01 in [0->256] do loop b02 in [0->256] do loop b03 in [0->256] do
                    loop b04 in [0->256] do loop b05 in [0->256] do loop b06 in [0->256] do loop b07 in [0->256] do
                    loop b08 in [0->256] do loop b09 in [0->256] do loop b10 in [0->256] do loop b11 in [0->256] do
                    loop b12 in [0->256] do loop b13 in [0->256] do loop b14 in [0->256] do loop b15 in [0->256] do
                        n_ = n_ + 1;
                        plain2[ 0]=b00; plain2[ 1]=b01; plain2[ 2]=b02; plain2[ 3]=b03;
                        plain2[ 4]=b04; plain2[ 5]=b05; plain2[ 6]=b06; plain2[ 7]=b07;
                        plain2[ 8]=b08; plain2[ 9]=b09; plain2[10]=b10; plain2[11]=b11;
                        plain2[12]=b12; plain2[13]=b13; plain2[14]=b14; plain2[15]=b15;
                        _crypto_generichash(&&tx_hash2[0], HASH_BYTES,
                                            &&plain2[0], len,
                                            null, 0);
                        zeros_found = _leading_zeros(&&tx_hash2[0], HASH_BYTES);
                        if zeros_found >= zeros_wanted then
                            atomic do
                                _ceu_vector_buf_set(&&plain, 0,
                                                    &&plain2[0], len*sizeof(byte));
                                _ceu_vector_setlen(&&tx_hash, HASH_BYTES, 1);
                                _ceu_vector_buf_set(&&tx_hash, 0,
                                                    &&tx_hash2[0], HASH_BYTES*sizeof(byte));
                            end
                            escape n_;
                        end
                    end end end end
                    end end end end
                    end end end end
                    end end end end
                    escape 0;
                end;
                _dbg(0, "client: POW rounds: %d\n", n);
            end
            [[ nonce = {} ]];
            loop j in [1 -> NONCE_BYTES] do
                var byte c = plain[j];
                [[ nonce[@j] = string.char(@c) ]];
            end
            [[
                G(this).tx.nonce = table.concat(nonce)
                G(this).tx_hash = @tx_hash
            ]];
        end

        if not (source is BlockHashSource.Network) then
            [[
                G(this).tx.hash = G(this).tx_hash
                G(this).block.txs[@(txs_n-i)] = G(this).tx_hash
            ]];
        end
        [[
            APP.txs[G(this).tx_hash] = G(this).tx
        ]];
    end

    // => BLOCK_HASH
    do/_
        vector[HASH_BYTES] byte block_hash;
        _ceu_vector_setlen(&&block_hash, HASH_BYTES, 1);

_printf("\t>1>\n");
        if is_genesis then
_printf("\t>3>\n");
            [[ assert( G(this).block.tail_hash == nil ) ]];

            vector[] byte plain = []..[[ G(this).chain.id ]];
            _crypto_generichash(&&block_hash[0], HASH_BYTES,
                                &&plain[0], $plain,
                                null, 0);
            vector[HASH_BYTES] byte tx_hash;
            _ceu_vector_setlen(&&tx_hash, HASH_BYTES, 1);
            _crypto_generichash(&&tx_hash[0], HASH_BYTES,
                                &&block_hash[0], $block_hash,
                                null, 0);
            [[
                tx = G(this).block.txs[1]
                tx.hash = @tx_hash
                G(this).block.txs[1] = tx.hash
                APP.txs[tx.hash] = tx
            ]];
_printf("\t<3<\n");
        else
            //var int txs_n = [[ #G(this).block.txs ]]; // TODO: assert G(this).block.chain.limits.block
            if txs_n == 0 then
// TODO: test-case
_ceu_dbg_assert(0);
                escape _ERR_REMOTE_BUG_OR_MALICIOUS;
            end

            [[
                if not G(this).block.tail_hash then
                    -- relink only after the yielding parts, avoid "head_hash" race
                    G(this).block.tail_hash = APP.chains[G(this).block.chain_id].head_hash
                end
            ]];
            vector[] byte plain = []..[[ G(this).block.tail_hash ]];
            loop i in [1 -> txs_n] do
                vector[HASH_BYTES] byte tx_hash = []..[[ G(this).block.txs[@i] ]];
                plain = plain..tx_hash;
            end

            _crypto_generichash(&&block_hash[0], HASH_BYTES,
                                &&plain[0], $plain,
                                null, 0);
        end

_printf("\t|2|\n");
        [[
            --print('block',string.len(@block_hash),'\n'..tostring2(@block_hash))
            G(this).block.hash = @block_hash
            APP.blocks[G(this).block.hash] = G(this).block
        ]];
_printf("\t<1<\n");
    end

    [[ ARGS = { block=G(this).block } ]];

    escape _ERR_NONE;
end

code/await Init (void) => void do
    var int n_chains = [[ #APP.chains ]];
    loop i in [1 -> n_chains] do
        [[
            chain = APP.chains[@i]
            assert(not chain.head_hash)
        ]];

    // TODO: first try to load from file

        [[
            ARGS = {
                block = {
                    chain_id = chain.id,
                    txs = {
                        {
                            nonce     = string.rep('\0',NONCE_BYTES),
                            back_hash = string.rep('\0',HASH_BYTES),
                            payload   = '',
                        }
                    },
                    tail_hash = nil,
                }
            }
        ]];

_printf(">>> %d\n", i);
        var int ret = await BlockHash(BlockHashSource.File());
_printf("<<< %d\n", i);
        [[ APP.chains[@i].head_hash = ARGS.block.hash ]]
    end
_ceu_dbg_assert(0);
end

#if 0
native _SERVERS_ALIVE, _CLIENTS_ALIVE, _BLOCKS_RECEIVED, _BLOCKS_RECREATED;
native/pre do
    int SERVERS_ALIVE    = 0;
    int CLIENTS_ALIVE    = 0;
    int BLOCKS_RECEIVED  = 0;
    int BLOCKS_RECREATED = 0;
end
spawn do
    every 10s do
        _printf("SERVERS_ALIVE = %d\n", _SERVERS_ALIVE);
        _printf("CLIENTS_ALIVE = %d\n", _CLIENTS_ALIVE);
    end
end

#include "client.ceu"
#endif

code/await App (void) => FOREVER do
    var int this = 0;
    [[
        G(this) = app_create()
        APP = G(this)
    ]];
    await FOREVER;
end

#endif
