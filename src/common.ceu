#ifndef _COMMON_CEU
#define _COMMON_CEU

//#define DBG 0

#include "c.ceu"
#include "uv.ceu"
#include "sodium.ceu"

#define MESSAGE_BYTES   4
#define MESSAGE_MAGIC_0 'P'
#define MESSAGE_MAGIC_1 'S'

#define HASH_BYTES      32
#define NONCE_BYTES     16
#define CHAIN_KEY_BYTES 256

native @pure _leading_zeros();
native @nohold _dbg(), _dbg_tcp();
native do
    ##define VOID_ALIAS(x) ((void*)&x)

    enum {
        ERR_NONE                    =  0,
        ERR_MESSAGE                 = -1,
        ERR_REMOTE_BUG_OR_MALICIOUS = -2,
    };

    enum {
        MESSAGE10 = 1,
    };

    enum {
        MESSAGE10_NOTSUB = 1,   // [ok ACK] not subscribed to this chain
        MESSAGE10_HAVE,         // [ok ACK] already has it
        MESSAGE10_LIMIT,        // [ok ACK] too big for untrusted client
    };

    void dbg (int level, const char* fmt, ...) {
#ifdef DBG
        if (level < DBG) return;
        fprintf(stderr, "[%d] | ", level);
        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    void dbg_tcp (int level, uv_tcp_t* tcp, char* client_server, const char* fmt, ...) {
#ifdef DBG
        if (level < DBG) return;
        int p1 = ceu_uv_tcp_getsockport(tcp);
        int p2 = ceu_uv_tcp_getpeerport(tcp);
        char str[255];
        char* arrow;
        if (strcmp(client_server,"server") == 0) {
            arrow = "<-";
        } else {
            arrow = "->";
        }
        fprintf(stderr, "[%d] | %s:%d%s%d | ", level, client_server, p1, arrow, p2);

        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    // calculate the number of leading zero bits in "bytes"
    // 00abcdef...  => 2
    int leading_zeros (byte* bytes, int len) {
        int i, j;
        int zeros = 0;
        for (i=0; i<len; i++) {             // loop over "bytes"
            byte b = bytes[i];
            for (j=0; j<8; j++) {           // loop over each bit
                if ((b & (1<<(7-j))) != 0) {
                    return zeros;
                } else {
                    zeros++;
                }
            }
        }
        return zeros;
    }
end
#define G(v) GG[@(&&(v))]

interface Global with
    event void recv_chain_unlocked;
    event void send_chain_unlocked;
end
event void recv_chain_unlocked;
event void send_chain_unlocked;

data SourceBlockHash with
    tag NETWORK;
or
    tag FILE;
or
    tag NEW;
end

class BlockHash with
    // input  [[ ARGS = { block={ txs={ tx1, tx2, ... } } }
    // output [[ ARGS = { block={ txs={ tx1_hash, tx2_hash, ... } } }
    // output [[ APP.block[hash]=blk APP.txs[hash]=txs ]]
    var SourceBlockHash source;
do
    [[
        G(this) = {
            block = ARGS.block,
            chain = APP.chains[ARGS.block.chain_id],
        }
    ]];

    var bool is_genesis = false;

    // => TX_HASH
    var int txs_n = [[ #G(this).block.txs ]];
    loop i in txs_n do
        [[ G(this).tx = G(this).block.txs[@txs_n-i] ]];

        if this.source.NETWORK then
            [[
                assert( type(G(this).tx) == 'string' )
                G(this).tx = G(this).block.txs[G(this).tx] or APP.txs[G(this).tx]
                assert( G(this).tx.nonce ~= nil )
            ]];
        else/if this.source.FILE then
            [[
                assert( type(G(this).tx) == 'table' )
                assert( G(this).tx.nonce ~= nil )
            ]];
        else/if this.source.NEW then
            [[
                assert( type(G(this).tx) == 'table' )
                assert( G(this).tx.nonce == nil )
            ]];
        else
            _assert(0);
        end

        var u8 zeros_wanted = [[ G(this).chain.zeros ]];

        if this.source.NETWORK then
            var char[HASH_BYTES] tx_hash;
            tx_hash = [[ G(this).tx.hash ]];
            if zeros_wanted > _leading_zeros((_char&&)&&tx_hash,HASH_BYTES) then
// TODO: test-case to fail here
// TODO: also change from ">" to "!="
_assert(0);
                escape _ERR_REMOTE_BUG_OR_MALICIOUS;
            end
        end

        var byte[] plain;
        var char[HASH_BYTES] back_hash = [[ G(this).tx.back_hash ]];
        var char[]           payload   = [[ G(this).tx.payload   ]];

        is_genesis = [[ G(this).tx.back_hash == string.rep('\0',HASH_BYTES) ]];
        if is_genesis then
            _assert(not this.source.NETWORK);
            _assert(txs_n == 1);
            [[
                assert( G(this).tx.payload == '' )
                assert( G(this).tx.nonce   == string.rep('\0',NONCE_BYTES) )
            ]];
            break;

        else/if this.source.NETWORK or this.source.FILE then
            var char[HASH_BYTES] nonce = [[ G(this).tx.nonce ]];
            plain = []..nonce..back_hash..payload;

            var char[HASH_BYTES] tx_hash;
            $tx_hash := HASH_BYTES;
            _crypto_generichash((_byte&&)(_char&&)&&tx_hash, HASH_BYTES,
                                (_byte&&)&&plain, $plain,
                                null, 0);

            [[ tx_hash = @tx_hash ]];
            if this.source.NETWORK then
                var bool ok = [[ tx_hash == G(this).tx.hash ]];
                if not ok then
                    // received hash+nonce do not match
                    escape _ERR_REMOTE_BUG_OR_MALICIOUS;
                end
            else
                _assert(zeros_wanted <= _leading_zeros((_char&&)&&tx_hash,HASH_BYTES));
// TODO: change from "<=" to "=="
            end
        else
            plain = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ..back_hash..payload;

            // show async/thread progress
            var int ms = 0;
#if 1
            spawn do
                every 100ms do
                    ms = ms + 100;
                    _printf(".");
                    _fflush(_stdout);
                end
            end
#endif

            // calculate nonce for the leading zeros
            var byte[HASH_BYTES] tx_hash;
#if 1
            async/thread (plain,tx_hash,zeros_wanted)
#endif
            do
                var int len;
                atomic do
                    len = $plain;
                end
                _assert(len <= 1024);

                var _byte[1024] plain2 = [];
                _memcpy(plain2, (_byte&&)&&plain, len*sizeof(byte));;

                var _byte[HASH_BYTES] tx_hash2 = [];

                var int zeros_found = 0;
                var u32 n = do
                    var u32 n_ = 0;
                    loop b00 in 256 do loop b01 in 256 do loop b02 in 256 do loop b03 in 256 do
                    loop b04 in 256 do loop b05 in 256 do loop b06 in 256 do loop b07 in 256 do
                    loop b08 in 256 do loop b09 in 256 do loop b10 in 256 do loop b11 in 256 do
                    loop b12 in 256 do loop b13 in 256 do loop b14 in 256 do loop b15 in 256 do
                        n_ = n_ + 1;
                        plain2[ 0]=b00; plain2[ 1]=b01; plain2[ 2]=b02; plain2[ 3]=b03;
                        plain2[ 4]=b04; plain2[ 5]=b05; plain2[ 6]=b06; plain2[ 7]=b07;
                        plain2[ 8]=b08; plain2[ 9]=b09; plain2[10]=b10; plain2[11]=b11;
                        plain2[12]=b12; plain2[13]=b13; plain2[14]=b14; plain2[15]=b15;
                        _crypto_generichash(tx_hash2, HASH_BYTES,
                                            plain2, len,
                                            null, 0);
                        zeros_found = _leading_zeros(tx_hash2, HASH_BYTES);
                        if zeros_found >= zeros_wanted then
                            atomic do
                                _ceu_vector_copy_buffer(&&plain, 0,
                                                        plain2, len*sizeof(byte), 0);
                                $tx_hash := HASH_BYTES;
                                _ceu_vector_copy_buffer(&&tx_hash, 0,
                                                        tx_hash2, HASH_BYTES*sizeof(byte), 0);
                            end
                            escape n_;
                        end
                    end end end end
                    end end end end
                    end end end end
                    end end end end
                    escape 0;
                end;
                _dbg(0, "client: POW rounds: %d\n", n);
            end

            [[ nonce = {} ]];
            loop j in NONCE_BYTES do
                [[ nonce[@(j+1)] = string.char(@(plain[j])) ]];
            end
            [[
                G(this).tx.nonce = table.concat(nonce)
                tx_hash = @tx_hash
            ]];
        end

        if not this.source.NETWORK then
            [[
                G(this).tx.hash = tx_hash
                G(this).block.txs[@(txs_n-i)] = tx_hash
            ]];
        end
        [[
            APP.txs[tx_hash] = G(this).tx
        ]];
    end

    // => BLOCK_HASH
    do
        var char[HASH_BYTES] block_hash;
        $block_hash := HASH_BYTES;

        if is_genesis then
            [[ assert( G(this).block.tail_hash == nil ) ]];

            var char[] plain = [[ G(this).chain.id ]];
            _crypto_generichash((_byte&&)(_char&&)&&block_hash, HASH_BYTES,
                                (_byte&&)(_char&&)&&plain, $plain,
                                null, 0);
            var byte[HASH_BYTES] tx_hash;
            $tx_hash := HASH_BYTES;
            _crypto_generichash((_byte&&)&&tx_hash, HASH_BYTES,
                                (_byte&&)(_char&&)&&block_hash, $block_hash,
                                null, 0);
            [[
                tx = G(this).block.txs[1]
                tx.hash = @tx_hash
                G(this).block.txs[1] = tx.hash
                APP.txs[tx.hash] = tx
            ]];
        else
            [[ assert( G(this).block.tail_hash ~= nil ) ]];
            //var int txs_n = [[ #G(this).block.txs ]]; // TODO: assert G(this).block.chain.limits.block
            if txs_n == 0 then
// TODO: test-case
_assert(0);
                escape _ERR_REMOTE_BUG_OR_MALICIOUS;
            end

            var char[] plain = [[ G(this).block.tail_hash ]];
            loop i in txs_n do
                var char[HASH_BYTES] tx_hash = [[ G(this).block.txs[@i+1] ]];
                plain = []..plain..tx_hash;
            end

            _crypto_generichash((_byte&&)(_char&&)&&block_hash, HASH_BYTES,
                                (_byte&&)(_char&&)&&plain, $plain,
                                null, 0);
        end

        [[
            --print('block',string.len(@block_hash),'\n'..tostring2(@block_hash))
            G(this).block.hash = @block_hash
            APP.blocks[G(this).block.hash] = G(this).block
        ]];
    end

    [[ ARGS = { block=G(this).block } ]];

    escape _ERR_NONE;
end

class FS_read_10 with
    var char[]& path;
    // output [[ ARGS = { chain_id, head_hash } ]]
    function (char[]& path)=>FS_read_10 run;
do
    function (char[]& path)=>FS_read_10 run do
        this.path = &path;
    end

    [[
        G(this) = {
            chain_id = nil,
            head     = nil,
            base     = nil,
        }
    ]];

    var UV_FS_open o = UV_FS_open.build(&this.path, _O_RDONLY, 0);
    await o.ok;
    if o.fd < 0 then
        escape o.fd;
    end

    var _uv_stat_t stat = _uv_stat_t();
    do UV_FS_fstat.run(&o, &stat);
    var u64 size = stat.st_size;

    var int off = 0;

    // => HEADER
    do
        var byte[4] buf;
        var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
        _assert(buf[0] == MESSAGE_MAGIC_0);
        _assert(buf[1] == MESSAGE_MAGIC_1);
        _assert(buf[2] == 1);
        _assert(buf[3] == 0);
        _assert(n == 4);
        off = off + 4;
    end

    // => CHAIN_ID
    do
        var u8[1] len_;
        do
            var int n = do UV_FS_read.run(&o,&len_,$$len_,off);
            _assert(n == sizeof(u8));
            off = off + 1;
        end
        var u8 len = len_[0];

        var char[len] buf;
        do
            var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
            _assert(n == len);
            off = off + len;
        end
        [[ G(this).chain_id = @buf ]];
    end

    // => BLOCKS
    loop do
        if off >= size then
            _assert(off == size);
            break;  // EOF
        end

        [[
            G(this).previous = G(this).block
            G(this).block = {
                txs = {},
                tail_hash = (G(this).previous and G(this).previous.hash) or nil,
            }
        ]];

        // => TXS
        var u32 txs_n = 0;
        do
            // => TXS_N
            var byte[sizeof(u32)] buf;
            var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
            if n <= 0 then
                break;
            end
            _assert(n == sizeof(u32));
            txs_n = *((u32&&)(_byte&&)&&buf);
            off = off + sizeof(u32);
        end
        loop i in txs_n do
            // => TXS[i]
            [[
                G(this).tx = {}
                G(this).block.txs[@(i+1)] = G(this).tx
            ]];

            // => NONCE
            var char[NONCE_BYTES] nonce;
            do
                var int n = do UV_FS_read.run(&o,&nonce,$$nonce,off);
                _assert(n == NONCE_BYTES);
                [[ G(this).tx.nonce = @nonce ]];
                //[[ print('nonce','\n'..tostring2(G(this).tx.nonce)) ]];
                off = off + NONCE_BYTES;
            end

            // => TX_BACH_HASH
            var char[HASH_BYTES] tx_back_hash;
            do
                var int n = do UV_FS_read.run(&o,&tx_back_hash,$$tx_back_hash,off);
                _assert(n == HASH_BYTES);
                [[ G(this).tx.back_hash = @tx_back_hash ]];
                //[[ print('back_hash','\n'..tostring2(G(this).tx.back_hash)) ]];
                off = off + HASH_BYTES;
            end

            // => TX_PAYLOAD
            var char[] payload;
            do
                var u32 payload_len = 0;
                do
                    var byte[sizeof(u32)] buf;
                    var int n = do UV_FS_read.run(&o,&buf,$$buf,off);
                    _assert(n == sizeof(u32));
                    payload_len = *((u32&&)(_byte&&)&&buf);
                    //[[ print('payload_len', @payload_len) ]];
                    off = off + sizeof(u32);
                end
                do
                    $payload := payload_len;
                    var int n = do UV_FS_read.run(&o,&payload,payload_len,off);
                    _assert(n == payload_len);
                    [[ G(this).tx.payload = @payload ]];
                    //[[ print('payload', G(this).tx.payload) ]];
                    off = off + payload_len;
                end
            end
        end

        [[
            G(this).block.chain_id = G(this).chain_id
            ARGS = {
                block = G(this).block,
            }
        ]];
        var int ret = do BlockHash with
            this.source = SourceBlockHash.FILE();
        end;
        _assert(ret == _ERR_NONE);

        [[
            if G(this).previous then
                G(this).previous.up_hash = G(this).block.hash
            end
        ]];
    end

    [[
        ARGS = {
            chain_id  = G(this).chain_id,
            head_hash = G(this).block.hash,
        }
    ]];
    escape _ERR_NONE;
end

class FS_write_10 with
    var char[]& path;
    // input [[ ARGS = { chain_id } ]]
    function (char[]& path)=>FS_write_10 run;
do
    function (char[]& path)=>FS_write_10 run do
        this.path = &path;
    end

    #if 0
    PS10
    [i]/*BLOCK_HASH*/ (genesis)
        TXS_N
        [j]/*TX_HASH*/ NONCE TX_BACK_HASH TX_PAYLOAD_LEN TX_PAYLOAD
        ...
    ...
    [n]/*BLOCK_HASH*/ (head)
        ...
    #endif

    [[
        chain = APP.chains[ ARGS.chain_id ]
        t = GG.chain_head_base_size(chain.head_hash)
        G(this) = {
            base  = t.base,
            chain = chain,
        }
    ]];

    // create/truncate file
    do
        var int flags = _O_CREAT|_O_WRONLY|_O_TRUNC;
        var _mode_t mode = _S_IRUSR|_S_IWUSR|_S_IRGRP|_S_IWGRP|_S_IROTH;
        var UV_FS_open o = UV_FS_open.build(&this.path, flags, mode);
        await o.ok;
        if o.fd < 0 then
            escape o.fd;
        end
    end

    // <= (append)
    var UV_FS_open o = UV_FS_open.build(&this.path, _O_APPEND|_O_WRONLY, 0);
    await o.ok;
    _assert(o.fd >= 0);

    // <= HEADER
    do
        var byte[4] buf = [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, 1, 0];
        var int n = do UV_FS_write.run(&o,&buf,$buf,0);
        _assert(n == 4);
    end

    // <= CHAIN_ID
    do
        var u8 len = [[ string.len(G(this).chain.id) ]];
        var byte[1] len_ = [len];
        do
            var int n = do UV_FS_write.run(&o,&len_,1,0);
            _assert(n == sizeof(u8));
        end

        var char[len] buf = [[ G(this).chain.id ]];
        do
            var int n = do UV_FS_write.run(&o,&buf,$buf,0);
            _assert(n == len);
        end
    end

    // <= BLOCKS
    loop do
        // <= TXS
        var u32 txs_n = [[ #G(this).base.txs ]];
        do
            // <= TXS_N
            var char[sizeof(u32)] buf;
            _ceu_vector_copy_buffer(&&buf, 0, (byte&&)&&txs_n, sizeof(u32), 1);
            var int n = do UV_FS_write.run(&o,&buf,$buf,0);
            _assert(n == sizeof(u32));
        end
        loop i in txs_n do
            // <= TXS[i]
            // TX_HASH NONCE TX_BACK_HASH TX_PAYLOAD_LEN TX_PAYLOAD

            [[
                tx_hash = G(this).base.txs[@i+1]
                tx      = assert(APP.txs[tx_hash])
            ]];

            // <= NONCE
            do
                var char[NONCE_BYTES] buf = [[ tx.nonce ]];
                var int n = do UV_FS_write.run(&o,&buf,$buf,0);
                _assert(n == NONCE_BYTES);
            end

            // <= TX_BACK_HASH
            do
                var char[HASH_BYTES] buf = [[ tx.back_hash ]];
                var int n = do UV_FS_write.run(&o,&buf,$buf,0);
                _assert(n == HASH_BYTES);
            end

            // <= TX_PAYLOAD_LEN
            // <= TX_PAYLOAD
            do
                var u32 len = [[ string.len(tx.payload) ]];
                // <= TX_PAYLOAD_LEN
                do
                    var char[sizeof(u32)] buf;
                    _ceu_vector_copy_buffer(&&buf, 0, (byte&&)&&len, sizeof(u32), 1);
                    var int n = do UV_FS_write.run(&o,&buf,$buf,0);
                    _assert(n == sizeof(u32));
                end
                // <= TX_PAYLOAD
                do
                    var char[] buf = [[ tx.payload ]];
                    var int n = do UV_FS_write.run(&o,&buf,$buf,0);
                    _assert(n == len);
                end
            end
        end

        // NEXT BLOCK
        var bool has = [[ G(this).base.up_hash ~= nil ]];
        if not has then
            break;
        end
        [[
            --print('<<<', '|'..tostring2(G(this).base.hash)..'|')
            G(this).base = assert(APP.blocks[G(this).base.up_hash])
        ]];
    end

    escape _ERR_NONE;
end

#include "client.ceu"
#define UV_TCP_SERVER_HANDLER_CEU server.ceu
#include "uv-server.ceu"

[[
    dofile'src/common.lua'
    GG.ERR_REMOTE_BUG_OR_MALICIOUS = @((int)_ERR_REMOTE_BUG_OR_MALICIOUS)
    GG.MESSAGE10_NOTSUB = @((int)_MESSAGE10_NOTSUB)
]];

class Init with
do
    var int n_chains = [[ #APP.chains ]];
    loop i in n_chains do
        [[
            chain = APP.chains[@i+1]
            assert(not chain.head_hash)
        ]];

    // TODO: first try to load from file

        [[
            ARGS = {
                block = {
                    chain_id = chain.id,
                    txs = {
                        {
                            nonce     = string.rep('\0',NONCE_BYTES),
                            back_hash = string.rep('\0',HASH_BYTES),
                            payload   = '',
                        }
                    },
                    tail_hash = nil,
                }
            }
        ]];

        var int ret = do BlockHash with
            this.source = SourceBlockHash.FILE();
        end;
        [[ APP.chains[@i+1].head_hash = ARGS.block.hash ]]
    end
end

#endif
