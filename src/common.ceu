#ifndef _COMMON_CEU
#define _COMMON_CEU

#define DBG 0

#include "c.ceu"
#include "uv/uv.ceu"
#include "uv/fs.ceu"
#include "uv/tcp.ceu"
#include "sodium.ceu"

#define MESSAGE_BYTES   4
#define MESSAGE_MAGIC_0 {'P'}
#define MESSAGE_MAGIC_1 {'S'}

#define HASH_BYTES      32
#define NONCE_BYTES     16
#define CHAIN_KEY_BYTES 256
#define FORK_LENGTHY    100

#define THIS FC[@(&&{*_ceu_mem})]

native/nohold ___dbg, ___dbg_tcp;
native/pure _leading_zeros;

data Exception.Freechains;
data Exception.Freechains.Unsupported with
    var _char&& message = "unsupported message";
end
data Exception.Freechains.Malformed with
    var _char&& message = "malformed message";
end
data Exception.Freechains.Fork_Lengthy with
    var _char&& message = "fork is too lengthy";
end

#if 0
#define _dbg(a,...)                         \
    do                                      \
        var bool dbg_on = [[DBG_ON==true]]; \
        if dbg_on then                      \
            ___dbg(a, ##__VA_ARGS__);        \
        end                                 \
    end
#define _dbg_tcp(a,...)                     \
    do                                      \
        var bool dbg_on = [[DBG_ON==true]]; \
        if dbg_on then                      \
            ___dbg_tcp(a, ##__VA_ARGS__);    \
        end                                 \
    end
#else
#define _dbg(a,...)     ___dbg(a, ##__VA_ARGS__)
#define _dbg_tcp(a,...) ___dbg_tcp(a, ##__VA_ARGS__)
#endif

native/pre do
    enum {
        MESSAGE10 = 0x100,
    };

    enum {
        MESSAGE10_OK = 0,
        MESSAGE10_NOTSUB,   // [ok ACK] not subscribed to this chain
        MESSAGE10_HAVE,     // [ok ACK] already has it
        MESSAGE10_TIMEOUT,
        //MESSAGE10_ABORTED,  // [?? ???] aborted from external retransmit
    };

    void __dbg (int level, const char* fmt, ...) {
#ifdef DBG
        if (level > DBG) return;
        fprintf(stderr, "[%d] | ", level);
        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    void __dbg_tcp (int level, uv_stream_t* tcp, char* client_server, const char* fmt, ...) {
#ifdef DBG
        if (level > DBG) return;
        int p1 = ceu_uv_tcp_getsockport((uv_tcp_t*) tcp);
        int p2 = ceu_uv_tcp_getpeerport((uv_tcp_t*) tcp);
        char str[255];
        char* arrow;
        if (strcmp(client_server,"server") == 0) {
            arrow = "<-";
        } else {
            arrow = "->";
        }
        fprintf(stderr, "[%d] | %s:%d%s%d | ", level, client_server, p1, arrow, p2);

        va_list args;
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end (args);
        fprintf(stderr, "\n");
#endif
    }

    // calculate the number of leading zero bits in "bytes"
    // 00abcdef...  => 2
    int leading_zeros (byte* bytes, int len) {
        int i, j;
        int zeros = 0;
        for (i=0; i<len; i++) {             // loop over "bytes"
            byte b = bytes[i];
            for (j=0; j<8; j++) {           // loop over each bit
                if ((b & (1<<(7-j))) != 0) {
                    return zeros;
                } else {
                    zeros++;
                }
            }
        }
        return zeros;
    }
end

data UV_TCP_Server_Data with
    event (int,bool,int) ok;
    event none unlock;
    event none retransmit;
#if 1
    var int port;   // only for debug
#endif
end

#define CHAIN_LOCK(var_id,shared,lock_id)                       \
    [[ assert(ARGS and ARGS.chain) ]];                          \
    var& Chain_Lock var_id = spawn Chain_Lock(&shared,lock_id); \
    if var_id.is_locked then                                    \
        await var_id.ok;                                        \
    end

code/await Chain_Lock (var& UV_TCP_Server_Data shared, var _char&& id) ->
                        (var bool is_locked, event none ok) ->
                            NEVER
do
    [[
        THIS = {
            chain = ARGS.chain,
            id    = @id,
        }
    ]]
    is_locked = [[ THIS.chain[THIS.id] ]];
    if is_locked then
        loop do
spawn do
    await 30s;
    //{ceu_trace(((tceu_trace){&_ceu_mem->trace, __FILE__, __LINE__}),"alo");};
    [[ error 'locked for too long' ]];
    [[ print 'locked for too long' ]];
end
            await shared.unlock;
            is_locked = [[ THIS.chain[THIS.id] ]];
            if not is_locked then
                break;
            end
        end
    end
    [[ THIS.chain[THIS.id] = true ]];
    do finalize with
        [[ THIS.chain[THIS.id] = false ]];
        emit shared.unlock;
    end
    emit ok;
    await FOREVER;
end

code/await Publication_New (none) -> none
    // input:  [[ ARGS={pub={TODO}} ]]
    // output: [[ ARGS={pub={DONE}} ]]
do
    [[
        THIS = {
            pub = ARGS.pub,
        }
        assert(THIS.pub.removal or string.len(THIS.pub.payload)>0)
    ]];

    var[HASH_BYTES] byte hash;
    _ceu_vector_setlen(&&hash,HASH_BYTES,1);

    var u8 zeros = [[ THIS.pub.chain.zeros ]];

    var[] byte pln = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                     [[ THIS.pub.chain.key ]]   ..
                     [[ (THIS.pub.removal and THIS.pub.removal.pub.payload) or THIS.pub.payload ]];

    // when removing, append the original payload hash to avoid nonce reuse
    var bool is_removal = [[ THIS.pub.removal~=nil ]];
    if is_removal then
        pln = pln .. [[ THIS.pub.removal.pub.hash ]];
    end

    // show async/thread progress
    var int ms = 0;
#if 1
    spawn do
        every 100ms do
            ms = ms + 100;
            _printf(".");
            _fflush(_stdout);
        end
    end
#endif

#if 0
    await async/thread (zeros,pln,hash)
#endif
    do
        var u64 timestamp;
        var u64 nonce;
        atomic do
            timestamp = [[ THIS.pub.timestamp ]];
            nonce     = [[ THIS.pub.nonce     ]];
        end

        var u64 n = do
            var u64 n_ = 0;
            var u64 i;
            loop i in [timestamp -> 0xFFffFFffFFffFFff] do
                PUT_HTOBE64(pln, 0, i);

                var u64 j;
                loop j in [nonce -> 0xFFffFFffFFffFFff] do
                    PUT_HTOBE64(pln, sizeof(u64), j);

                    _ceu_assert(n_ < 0xFFffFFffFFffFFff, "bug found");
                    n_ = n_ + 1;

                    _crypto_generichash(&&hash[0],HASH_BYTES, &&pln[0],$pln, null,0);
                    if zeros <= _leading_zeros(&&hash[0],HASH_BYTES) then
                        atomic do
                            [[
                                THIS.pub.timestamp = @i
                                THIS.pub.nonce     = @j
                                THIS.pub.hash      = @hash
                            ]];
                        end
                        escape n_;
                    end
                end
            end
            _ceu_assert(0, "bug found");
        end;
        _dbg(3, "client: POW rounds: %d\n", n);
    end

    [[ ARGS = THIS ]];
end

/*
 * Verifies if the hash has the expected leading zeros and if the chain key and
 * payload match the hash.
 */
code/await Publication_Check (none) -> none
    // input: [[ ARGS={pub={DONE}} ]]
    throws Exception.Freechains.Malformed
do
    [[
        THIS = {
            pub = ARGS.pub,
        }
    ]];

    var[HASH_BYTES] byte hash = [] .. [[ THIS.pub.hash ]];

    var u8 zeros = [[ THIS.pub.chain.zeros ]];
    if zeros > _leading_zeros(&&hash[0],HASH_BYTES) then
        var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
        throw e;
    end

    var[] byte pln = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                     [[ THIS.pub.chain.key ]]   ..
                     [[ (THIS.pub.removal and THIS.pub.removal.pub.payload) or THIS.pub.payload ]];
    do
        var u64 timestamp = [[ THIS.pub.timestamp ]];
        var u64 nonce     = [[ THIS.pub.nonce     ]];
        PUT_HTOBE64(pln, 0, timestamp);
        PUT_HTOBE64(pln, sizeof(u64), nonce);
    end

    // when removing, append the original pub hash to avoid nonce reuse
    var bool is_removal = [[ THIS.pub.removal~=nil ]];
    if is_removal then
        pln = pln .. [[ THIS.pub.removal.pub.hash ]];
    end

    _crypto_generichash(&&hash[0],HASH_BYTES, &&pln[0],$pln, null,0);
    var bool ok = [[ THIS.pub.hash == @hash ]];
    if not ok then
        var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
        throw e;
    end

    [[
        THIS.pub.chain.up.pubs[THIS.pub.hash] = THIS.pub
    ]]
end

code/await Block_Hash (none) -> none
    // input:  [[ ARGS={block={TODO}} ]]
    // effect: [[ ARGS={block={DONE}} ]]
do
    [[
        THIS = {
            block = ARGS.block,
        }
    ]];

    [[
        assert(THIS.block.prv, THIS.block.chain.id)
        assert(THIS.block.prv.length==THIS.block.length-1)
    ]]

    var[HASH_BYTES] byte hash;
    _ceu_vector_setlen(&&hash, HASH_BYTES, 1);

    var u8 zeros = [[ THIS.block.chain.zeros ]];

    var[] byte pln = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                     [[ THIS.block.pub.hash ]] ..
                     [[ THIS.block.prv.hash ]];

    // show async/thread progress
    var int ms = 0;
#if 1
    spawn do
        every 100ms do
            ms = ms + 100;
            _printf(".");
            _fflush(_stdout);
        end
    end
#endif

#if 0
    await async/thread (zeros,pln,hash)
#endif
    do
        var u64 timestamp;
        var u64 nonce;
        atomic do
            timestamp = [[ THIS.block.timestamp ]];
            nonce     = [[ THIS.block.nonce     ]];
        end

        var u64 n = do
            var u64 n_ = 0;
            var u64 i;
            loop i in [timestamp -> 0xFFffFFffFFffFFff] do
                PUT_HTOBE64(pln, 0, i);

                var u64 j;
                loop j in [nonce -> 0xFFffFFffFFffFFff] do
                    PUT_HTOBE64(pln, sizeof(u64), j);

                    _ceu_assert(n_ < 0xFFffFFffFFffFFff, "bug found");
                    n_ = n_ + 1;

                    _crypto_generichash(&&hash[0],HASH_BYTES, &&pln[0],$pln, null,0);
                    if zeros <= _leading_zeros(&&hash[0],HASH_BYTES) then
                        atomic do
                            [[
                                THIS.block.timestamp = @i
                                THIS.block.nonce     = @j
                                THIS.block.hash      = @hash
                            ]];
                        end
                        escape n_;
                    end
                end
            end
            _ceu_assert(0, "bug found");
        end;
        _dbg(3, "client: POW rounds: %d\n", n);
    end
end

code/await Block_Hash_Link (none) -> none
    // input:  [[ ARGS={block={TODO}} ]]
    // effect: [[ ARGS={block={DONE}} ]]
do
    [[
        THIS = {
            block = ARGS.block,
        }
    ]];

    [[
        assert(not THIS.block.prv)
        assert(not THIS.block.nxt)
        assert(not THIS.block.length)
        THIS.block.prv = THIS.block.chain.head
        THIS.block.length = (THIS.block.prv and THIS.block.prv.length+1) or 1
    ]]

    [[ ARGS = THIS ]]
    await Block_Hash();

    [[
        THIS.block.chain.head.nxt = THIS.block
        THIS.block.chain.head     = THIS.block
    ]]
end

/*
 * Verifies if the hash has the expected leading zeros and if the pub
 * hash and back hash match the hash.
 */
code/await Block_Check (none) -> none
    // input: [[ ARGS={block={DONE}} ]]
    throws Exception.Freechains.Malformed
do
    [[
        THIS = {
            block = ARGS.block,
        }
    ]];

    var[HASH_BYTES] byte hash = [] .. [[ THIS.block.hash ]];

    var u8 zeros = [[ THIS.block.chain.zeros ]];
    if zeros > _leading_zeros(&&hash[0],HASH_BYTES) then
        var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
        throw e;
    end

    var[] byte pln = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ..
                     [[ THIS.block.pub.hash ]] ..
                     [[ THIS.block.prv.hash ]];
    do
        var u64 timestamp = [[ THIS.block.timestamp ]];
        var u64 nonce     = [[ THIS.block.nonce     ]];
        PUT_HTOBE64(pln, 0, timestamp);
        PUT_HTOBE64(pln, sizeof(u64), nonce);
    end

    _crypto_generichash(&&hash[0],HASH_BYTES, &&pln[0],$pln, null,0);
    var bool ok = [[ THIS.block.hash == @hash ]];
    if not ok then
        var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
        throw e;
    end
end

code/await Chain_Fork (none) -> none
    // input:  [[ ARGS={from=., to={first=.,last=.} ]]
do
    [[
        THIS = {
            from = ARGS.from,
            to   = ARGS.to,
        }
    ]]
    loop do
        var bool has = [[ THIS.from~=nil ]];
        if not has then
            break;
        end

        [[
            found = false
            cur = THIS.to.first
            while true do
                if cur.pub.hash == THIS.from.pub.hash then
                    found = true
                    break
                end
                if cur == THIS.to.last then
                    break
                end
                cur = cur.nxt
            end
        ]]
        var bool found = [[ found ]];
        if not found then
            [[
                --print('>>>', tostring2(THIS.from.hash), THIS.from.pub.payload)
                assert(THIS.from.chain == THIS.to.first.chain)
                THIS.block = {
                    version     = '1.0',
                    timestamp   = 0,    -- TODO: 64-bit timestamp
                    nonce       = 0,
                    chain       = THIS.from.chain,
                    pub = THIS.from.pub,
                    hash        = nil,
                    prv         = nil,
                    nxt         = nil,
                    length      = nil,
                }
                ARGS = THIS
            ]]
            await Block_Hash_Link();
        end

        [[ THIS.from = THIS.from.nxt ]]
    end
end

code/await FS_read_10 (none) -> none
    throws Exception.Uv, Exception.Freechains.Malformed
    // input:  [[ ARGS={chain={TODO}} ]]
    // output: [[ ARGS={chain={DONE}} ]]
do
    [[
        THIS = {
            chain = ARGS.chain,
        }
        path = CFG.dir..'/chains/'..THIS.chain.id..'.chain'
    ]];
    var[] byte path = []..[[path]]..[0];

    var& UV_FS_Open o = spawn UV_FS_Open(&&path[0],_,_,_);
    await o.file.ok;

    var _uv_stat_t stat = _;
    await UV_FS_Fstat(&o.file, &stat);
    var u64 size = stat.st_size;

    // => HEADER
    do
        var ssize n = await UV_FS_Read_N(&o.file, MESSAGE_BYTES);
        if n == 0 or
           o.file.buffer[0] != MESSAGE_MAGIC_0 or
           o.file.buffer[1] != MESSAGE_MAGIC_1 or
           o.file.buffer[2] != 1 or
           o.file.buffer[3] != 0
        then
            var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
            throw e;
        end
        $o.file.buffer = 0;
    end

    // => CHAIN_ID
    do
        var usize len;
        await UV_FS_Read_N(&o.file, 1);
        len = o.file.buffer[0] as usize;
        $o.file.buffer = 0;

        await UV_FS_Read_N(&o.file, len);
        [[
            id = @o.file.buffer
            local key,zeros = string.match(id,'|(.*)|(.*)|')
            THIS.chain = assert(FC.chains[key][tonumber(zeros)], id)
        ]];
        $o.file.buffer = 0;
        //[[ print('>>> chain_id',@buf) ]];

        var bool ok = [[ id==ARGS.chain.id ]];
        if not ok then
            var Exception.Freechains.Malformed e = val Exception.Freechains.Malformed(_);
            throw e;
        end
    end

    // => BLOCKS
    [[
        THIS.chain.head = THIS.chain.base
    ]]
    loop do
        var ssize n = await UV_FS_Read_N(&o.file, HASH_BYTES);
        if n <= 0 then
            break;          // EOF
        end

        [[
            THIS.block = {
                version = '1.0',
                timestamp   = nil,
                nonce       = nil,
                chain       = THIS.chain,
                pub         = nil,
                hash        = @o.file.buffer,
                prv         = THIS.chain.head,
                nxt         = nil,
                length      = THIS.chain.head.length + 1,
            }
            THIS.chain.head.nxt = THIS.block
            THIS.chain.head = THIS.block
        ]];

        $o.file.buffer = 0;

        // => TIMESTAMP + NONCE
        await UV_FS_Read_N(&o.file, sizeof(u64));
        var u64 timestamp = GET_BE64TOH(o.file.buffer,0);
        $o.file.buffer = 0;
        await UV_FS_Read_N(&o.file, sizeof(u64));
        var u64 nonce     = GET_BE64TOH(o.file.buffer,0);
        $o.file.buffer = 0;
        [[
            THIS.block.timestamp = @timestamp
            THIS.block.nonce     = @nonce
        ]]

        // => PUBLICATION_HASH
        await UV_FS_Read_N(&o.file, HASH_BYTES);
        [[
            THIS.pub_hash = @o.file.buffer
            --THIS.block.pub = FC.pubs[THIS.pub_hash]
        ]]
        $o.file.buffer = 0;

        var bool is_removed = [[ THIS.pub_hash==string.rep(32,'\0') ]];

        // => PUBLICATION
        if not is_removed then
            // => TIMESTAMP + NONCE + LEN
            await UV_FS_Read_N(&o.file, sizeof(u64));
            var u64 timestamp = GET_BE64TOH(o.file.buffer,0);
            $o.file.buffer = 0;

            await UV_FS_Read_N(&o.file, sizeof(u64));
            var u64 nonce     = GET_BE64TOH(o.file.buffer,0);
            $o.file.buffer = 0;

            await UV_FS_Read_N(&o.file, sizeof(u32));
            var u32 len       = GET_BE32TOH(o.file.buffer,0);
            $o.file.buffer = 0;

            // => PAYLOAD
            if len == 0 then
                await UV_FS_Read_N(&o.file, HASH_BYTES);
            else
                await UV_FS_Read_N(&o.file, len as usize);
            end

            [[
                is_removal = (@len == 0);
                payload = @o.file.buffer,
                THIS.block.pub = {
                    chain     = THIS.chain,
                    timestamp = @timestamp,
                    nonce     = @nonce,
                    payload   = (is_removal and nil) or payload,
                    removal   = (is_removal and assert(FC.chain_block_get(THIS.chain,payload))) or nil,
                    hash      = THIS.pub_hash,
                }
                ARGS = { pub=THIS.block.pub }
            ]]

            $o.file.buffer = 0;
            [[ ARGS={pub=THIS.block.pub} ]];
            await Publication_Check();
        end
    end

    [[ ARGS={block=THIS.block} ]];
    await Block_Check();

    [[
        ARGS = {
            chain = THIS.chain,
        }
    ]];
end

code/await FS_write_10 (none) -> none
    throws Exception.Uv
    // input [[ ARGS = { chain={...} } ]]
do
#if 0
    PS10
    [i]/*BLOCK_HASH*/ (genesis)
        TXS_N
        [j]/*TX_HASH*/ NONCE TX_BACK_HASH TX_PAYLOAD_LEN TX_PAYLOAD
        ...
    ...
    [n]/*BLOCK_HASH*/ (head)
        ...
#endif

    [[
        THIS = {
            chain = ARGS.chain,
        }

        assert(CFG.dir, 'missing configuration directory')
        dir = CFG.dir..'/chains'
        os.execute('mkdir -p '..dir)
    ]];

    var[] byte path = []..[[dir..'/'..THIS.chain.id..'.chain']]..[0];

    // create/truncate file
    do/_
        var int flags = _O_CREAT|_O_WRONLY|_O_TRUNC;
        var _mode_t mode = _S_IRUSR|_S_IWUSR|_S_IRGRP|_S_IWGRP|_S_IROTH;
        var& UV_FS_Open o = spawn UV_FS_Open(&&path[0], _, flags, mode);
        await o.file.ok;
    end

    // <= (append)
    var& UV_FS_Open o = spawn UV_FS_Open(&&path[0], 128000, _O_APPEND|_O_WRONLY, 0);
    await o.file.ok;
    _ceu_assert(o.file.handle >= 0, "bug found");

    // <= HEADER
    do
        o.file.buffer = [MESSAGE_MAGIC_0, MESSAGE_MAGIC_1, 1, 0];
        var ssize n = await UV_FS_Write_N(&o.file, MESSAGE_BYTES);
        _ceu_assert(n == 4, "bug found");
    end

    // <= CHAIN_ID
    do
        var byte len = [[ string.len(THIS.chain.id) ]];
        do
            o.file.buffer = [len];
            var ssize n = await UV_FS_Write_N(&o.file, 1);
            _ceu_assert(n == 1, "bug found");
        end
        do
            o.file.buffer = [] .. [[ THIS.chain.id ]];
            var ssize n = await UV_FS_Write_N(&o.file, len as usize);
            _ceu_assert(n == (len as ssize), "bug found");
        end
    end

    // <= BLOCKS (skip genesis)
    [[ THIS.cur = THIS.chain.base.nxt ]];
    loop do
        var bool has = [[ THIS.cur~=nil ]];
        if not has then
            break;
        end

        // <= HASH
        o.file.buffer = [] .. [[ THIS.cur.hash ]];

        // <= TIMESTAMP
        // <= NONCE
        o.file.buffer = o.file.buffer .. [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
        do
            var u64 timestamp = [[ THIS.cur.timestamp or 0 ]];
            var u64 nonce     = [[ THIS.cur.nonce or 0     ]];
            PUT_HTOBE64(o.file.buffer, HASH_BYTES,             timestamp);
            PUT_HTOBE64(o.file.buffer, HASH_BYTES+sizeof(u64), nonce);
        end

        // <= PUBLICATION_HASH (or 32x0's, if removed)
        o.file.buffer = o.file.buffer .. [[ (THIS.cur.pub and THIS.cur.pub.hash) or string.rep('\0',32) ]];
        await UV_FS_Write_N(&o.file,_);

        var bool is_removed = [[ THIS.cur.pub==nil ]];

        // <= PUBLICATION
        if not is_removed then
            // <= TIMESTAMP
            // <= NONCE
            // <= LEN
            o.file.buffer = [] .. [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
            do
                var u64 timestamp = [[ THIS.cur.pub.timestamp ]];
                var u64 nonce     = [[ THIS.cur.pub.nonce     ]];
                var u32 len = [[ (THIS.cur.pub.removal and 0) or string.len(THIS.cur.pub.payload) ]];
                PUT_HTOBE64(o.file.buffer, 0,               timestamp);
                PUT_HTOBE64(o.file.buffer, 0+sizeof(u64),   nonce);
                PUT_HTOBE32(o.file.buffer, 0+2*sizeof(u64), len);
                _ceu_assert($$o.file.buffer >= len, "FS buffer is too short for payload");
                await UV_FS_Write_N(&o.file,_);
            end

            // <= PAYLOAD
            o.file.buffer = [] .. [[ (THIS.cur.pub.removal and THIS.cur.pub.removal.hash) or THIS.cur.pub.payload ]];
            await UV_FS_Write_N(&o.file,_);
        end

        [[ THIS.cur = THIS.cur.nxt ]];
    end
end

native/pre do
    int SERVERS_ALIVE    = 0;
    int CLIENTS_ALIVE    = 0;
    int BLOCKS_RECEIVED  = 0;
    int BLOCKS_RECREATED = 0;
    int TXS_RECREATED = 0;
end
#if 0
spawn do
    every 10s do
        _printf("SERVERS_ALIVE = %d\n", {SERVERS_ALIVE});
        _printf("CLIENTS_ALIVE = %d\n", {CLIENTS_ALIVE});
    end
end
#endif

#include "client.ceu"
#include "server.ceu"
#include "uv/tcp-server.ceu"

code/await Errors (var& UV_TCP_Server_Data shared) -> none do
    var int  msg;
    var bool err;
    var int  ret;
    every (msg,err,ret) in shared.ok do
            _dbg(0, "error | %d %d %d", err, msg, ret);
        if err then
            _dbg(0, "error | %d %d", msg, ret);
        end
    end
end

code/await Init (none) -> none
    throws Exception.Freechains.Malformed
do
    [[
        THIS = {}
        FC['Exception.Freechains.Malformed'] = @({CEU_DATA_Exception__dot__Freechains__dot__Malformed} as int)
        FC.MESSAGE10_NOTSUB = @({MESSAGE10_NOTSUB} as int)

        local port = CFG.server and CFG.server.port or '0000'
        CFG.dir = CFG.dir or '/tmp/freechains/'..port
    ]]

    var int n = [[ #CFG.chains ]];
    var int i;
    loop i in [1 -> n] do
        [[
            cfg = CFG.chains[@i]
            --assert(not FC.chains[cfg.key])
            FC.chains[cfg.key] = FC.chains[cfg.key] or {
                key  = cfg.key,
                cfg  = cfg,
                pubs = { [string.rep('\0',@HASH_BYTES)]=true }, -- have all removeds
            }
        ]]
        var int zeros = [[cfg.zeros]];
        var int j;
        loop j in [zeros -> 255] do
            [[
                has = FC.chains[cfg.key][@j]
                if not has then
                    assert(not FC.chains[cfg.key][@j])
                    local id = '|'..cfg.key..'|'..@j..'|'
                    THIS.chain = {
                        key   = cfg.key,
                        zeros = @j,
                        id    = id,
                        up    = FC.chains[cfg.key],
                        cfg   = cfg,
                        head  = nil,
                        base  = nil,
                    }
                    FC.chains[cfg.key][@j] = THIS.chain
                end
            ]]
            var bool has = [[has]];
            if has then
                continue;   // from main.subscribe
            end

            do
                var[HASH_BYTES] byte hash;
                _ceu_vector_setlen(&&hash, HASH_BYTES, 1);
                var[] byte id = [] .. [[ THIS.chain.id ]];
                _crypto_generichash(&&hash[0],HASH_BYTES, &&id[0],$id, null,0);
#if 0
                do
                    var[] byte str = [] .. [[ tostring2(@hash) ]] .. [0];
                    _dbg(3, "|| CHAIN_HASH : %s", &&str[0]);
                end
#endif
                [[
                    THIS.chain.base = {
                        chain  = THIS.chain,
                        hash   = @hash,
                        prv    = nil,
                        length = 0,
                    }
                    THIS.chain.head = THIS.chain.base
                    --THIS.chain.cfg.last.output[@j] = THIS.chain.cfg.last.output[@j] or THIS.chain.base.hash
                    --THIS.chain.cfg.last.atom[@j]   = THIS.chain.cfg.last.atom[@j]   or THIS.chain.base.hash
                ]]
            end

            // try to load from file
            // no problem if it fails
            var bool should_read = [[ not CFG.chains.not_persistency ]];
            if should_read then
                var Exception? e;
                catch e do
                    [[
                        ARGS = {
                            chain = THIS.chain
                        }
                    ]]
                    await FS_read_10();
                end
            end
        end
    end
end

#endif
