#if 0
= TODO:
    - merkle tree of all TX_HASH
    - TXS_n => u16
    - remove COMMON, remove up_hash?
    - BLOCK.txs[k] = nil
    -- TODO-LEN:
        - size of chain should consider #tx.payloads
    - symmetric/asymmetric channels
    - serialize to disk
        - BLOCK_HASH .. PAYLOAD_LEN .. [PoW..BACK_HASH..PAYLOAD]
    - verificar backs, pos
        - reverificar backs em rejoins
    - verificar se sequencia de LEN/HASH ultrapassa PAYLOAD_LEN_LIMIT
    - nonce => timestamp s64 => s128
    - BLOCK vs MSG nomenclature
    - Message prepare do client pode ter todos os campos necessarios para o 
      send evita *muitas* copias
    - POS: M[head]=>a + M[head+b]=>c + M[head+c]=>d + ...
        ou M[head]    + M[head+head] + M[head+head+head] + ...
        - JUMP/2 times
    - POS p/ get:
        - quando der HAVE_NO p/ block, responder com POS do passado
    - TTL (em bytes) requer POS
        - parametro do post? ou da chain?
            - no post: nem todas as chains vao poder verificar POS da tx
                - as que verificarem e acharem erro, podem simplesmente
                    - guardar 00000 como payload
                    - responder 00000 para POSs futuras que baterem o offset do 
                      payload
        - JUMP eh parecido mas nao depende disso
            - acho que jump Ã© parametro do protocolo e nao da chain/post
            - jump evita republicacao (spam) e acumulacao (fork)
                - se eh republicado sera verificado que existe e portanto nao 
                  incluido
                - se eh acumulado sera verificado que jump eh muito antigo

= BUGS:
    - common genesis to all chains will conflict on gen.up_hash
        - has to assert before
        - use a hash based on the chain unique identification!

= IDEAS:
    - freechains
    - IPFS + bitcoin
    - esquema de nomes bc/path/, pega mais recente, bc/path/^..., git
    - /bc/dir/#hash/@search/%date/!sort
    - /\*/dir/#hash/@search/%date/!sort
    - aquivos plain, + arquivos meta em lua/binario
    - configurable POW (sha, cuckoo, etc, none, shared, pvt)
    - server "sair" do canal se fork "divergir demais"
    - pbmd: meta-chains,rxLua+template
        - webpage dinamica: v=>channel
    - meta-chain: create,touch,remove,...
    - pbfs, usa meta-chain, stack-based, head->tail
        - dropbox, fuse

= CMDS:
    - while :; do make tests || break; done
    - for i in cfg/message-01-a*.lua; do ./build/main.exe cfg/config.lua cfg/config-aa.lua $i; done
    - while :; do ./build/main.exe cfg/config.lua cfg/config-aa.lua cfg/message-01-01.lua; done
    -
        break _ceu_app.c:14594
        r
        watch XXX
        watch XXX.connect_req
        watch XXX.connect_req->cb
        break __GI___libc_free
        cond 5 (mem==0x639780 || mem==0x62b7f8)
        commands 5
        print mem
        c
        end
        c

        break tst-16.ceu:72
        r
        c

===============================================================================

= Message10_00_chain
- MESSAGE_*:    obligatory
- CHAIN_*:      avoids sequence of unsubscribed hashes
    - ok: not sub
--
= Message10_01_oldest_hash
    - receive many until HAVE_NO
- BLOCK_HASH:   client will typically guess correctly
    - ok: have
- PAYLOAD_LEN
    - ok: too big
---
- POW
- BACK_HASH
- PAYLOAD
    - no: no match
- POS
    - no: no match
(TAIL_HASH: got implicitly from the protocol)
===
- TODO: sig

///////////////////////////////////////////////////////////////////////////////
// MESSAGE_10: client proposes block to the server
///////////////////////////////////////////////////////////////////////////////
    - type of MESSAGE_*: server checks before anything else
    - CHAIN_*:           server checks if it is subscribing to this
    - TXS_PAYLOAD_BYTES: server may not want big messages from untrusted clients
    - block_hash, server may already have it
///////////////////////////////////////////////////////////////////////////////
// CLIENT => SERVER
// identifies this message (protocol, version)
//  - a server may refuse or behave differently
MESSAGE_MAGIC_0 1       // 'P'
MESSAGE_MAGIC_1 1       // 'S'
MESSAGE_MAJOR   1
MESSAGE_MINOR   0
// identifies the blockchain for this block
//  - a server may not be interested in this blockchain
//      - key is unintereresting
//      - zeros is too weak and prone to SPAM
//      - limits are too big for network/machine capacity
CHAIN_LEN       1       // number of bytes for the CHAIN identifier
CHAIN_KEY       <CHAIN_LEN> // CHAIN identifier (pubkey?, topic?) (if signed, must be pubkey)
CHAIN_ZEROS     1       // number of zeros to be trasmitted (or signed)
CHAIN_LIMITS    1       // max number of TXs per block | max bytes of TX payload
    block       4b      // 0=any,1=1,2=10,3=100,4=1k,5=10k,6=100k,7=1M
    payload     4b      // 0=any,1=100b,2=1K,3=10K,4=100K,5=1M,6=10M,7=100M
///////////////////////////////////////////////////////////////////////////////
// CLIENT <= SERVER
//  - server responds if is subscribed to the chain
-               1       // _ERR_NONE | MESSAGE10_NOTSUB
///////////////////////////////////////////////////////////////////////////////
// CLIENT => SERVER
//  - clients sends all BLOCKs
//      - server responds YES/NO for each
//      - if YES
//          - client sends all TX_BYTES+TX_HASH
//              - server responds YES/NO for each
//              - TX_PAYLOAD_BYTES: must be compatible with 
//                CHAIN_LIMITS.payload
//              - TX_HASH: server may already have
//          - loop is bounded to CHAIN_LIMITS.block
//      - loop is bounded to CHAIN_LIMITS.block
///////////////////////////////////////////////////////////////////////////////
LOOP for each BLOCK in CHAIN
    // identifies the block payload
    //  - a server may already have it
    -- CLIENT => SERVER
    BLOCK_HASH      32      // hash of the proposed block
    BLOCK_TXS_N     4 u32   // number of txs in the block
    -- CLIENT <= SERVER
    -               1       // MESSAGE10_HAVE_YES|MESSAGE10_HAVE_NO
    LOOP for each TX in BLOCK
        -- CLIENT => SERVER
        TX_HASH          32     // hash[NONCE..TX_BACK_HASH..TX_PAYLOAD]
        TX_PAYLOAD_BYTES 4 u32
        -- CLIENT <= SERVER
        -               1       // MESSAGE10_HAVE_YES|MESSAGE10_HAVE_NO
        -- CLIENT => SERVER
        NONCE_TIMESTAMP 16 s128 // nonce for TX_HASH
        TX_BACK_HASH    32      // recent back hash
        TX_PAYLOAD      <TX_PAYLOAD_BYTES>
        POS             1       // proof of storage
        TODO-SIGNATURE
    LOOP END
LOOP END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
- BLOCK_HASH
    - genesis
        - HASH(CHAIN_ID)
    - others
        - HASH(TAIL_HASH .. TXS)
        - TXS: merkle tree of all TX_HASH
    - no costs to generate
- TX_HASH
    - univocally identifies a specific PAYLOAD sent to a specific CHAIN
    - back pointers all the way back to GENESIS_HASH
- GENESIS_HASH
    - univocally identifies a chain
    - hash[CHAIN_ZEROS, CHAIN_LEN, CHAIN_KEY]
    - genesis TX hash: hash(block_hash)
- TX_HASH uses recent TX_BACK_HASH
    - TX_HASH->...->TX_BACK_HASH < GLOBAL_TX_BACK_DISTANCE_BYTES
    - server can refuse the whole block
    - attacker wants to create a big fork
        - preprocess TXs starting from TX_HASH_0 in fork point:
            - TX_HASH_0 -> 1 -> 2 -> 3 -> 4 -> ... -> n
        - propose BLOCK with all these
            - TX_HASH_1 is not to distant from TX_HASH_0
                - because the network didn't stop
                    - and created many blocks in between 0->1
- POS = *( PTR(TX_BACK_HASH) - TX_HASH )
    - go to the address of TX_BACK_HASH
    - subtract TX_HASH
        - since TX_HASH is random
            - can end up in any address down to GENESIS
    - get the contents of the pointed memory
    - force nodes willing to publish to keep all data
        - in BTC, miners need to check funds looking all the way back
///////////////////////////////////////////////////////////////////////////////
#endif

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
PS10
[i]BLOCK_HASH (genesis)
    [j]/*TX_HASH*/ NONCE TX_BACK_HASH TX_PAYLOAD TX_PAYLOAD_BYTES
    ...
    TX_N
...
[n]BLOCK_HASH (head)
    ...
