#ifndef _CLIENT_SERVER_CEU
#define _CLIENT_SERVER_CEU

#define AWAIT_UNTIL(r,nxt)          \
    if r.next < nxt then            \
        loop do                     \
            await r.ok;             \
            if r.next >= nxt then   \
                break;              \
            end                     \
        end                         \
    end

class MAGIC_VERSION_send with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>MAGIC_VERSION_send build;
do
    function (_uv_tcp_t& tcp)=>MAGIC_VERSION_send build do
        this.tcp = &tcp;
    end

    var byte[MAGIC_VERSION_BYTES] version =
        [MAGIC_0, MAGIC_1, VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH];
    do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &version);
end

class MAGIC_VERSION_recv with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>MAGIC_VERSION_recv build;
do
    function (_uv_tcp_t& tcp)=>MAGIC_VERSION_recv build do
        this.tcp = &tcp;
    end

    var byte[MAGIC_VERSION_BYTES] version;
    var UV_Stream_Read r = UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&version);
    AWAIT_UNTIL(r,MAGIC_VERSION_BYTES);
    if r.next == MAGIC_VERSION_BYTES then
        if version[0] != MAGIC_0        or
           version[1] != MAGIC_1        or
           version[2] != VERSION_MAJOR  or
           version[3] != VERSION_MINOR  or
           version[4] != VERSION_PATCH
        then
            escape _ERR_VERSION;
        end
    else/if r.next > MAGIC_VERSION_BYTES then
        escape _ERR_EXTRA_BYTES;
    else
        _assert(0);
    end

    // version ok
    escape _SUCCESS;
end

class TX_PROPOSE_send with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>TX_PROPOSE_send build;
do
    function (_uv_tcp_t& tcp)=>TX_PROPOSE_send build do
        this.tcp = &tcp;
    end
    var byte[] bytes;

    // prepare "bytes"
    do
        bytes = [ 5, 1,2,3,4,5, 99 ];
        loop i in HASH_BYTES do
            bytes = []..bytes..[0x00+i];
        end
        loop i in HASH_BYTES do
            bytes = []..bytes..[0x80+i];
        end
    end

    // => TX_PROPOSE
    do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

    // <= OK?
    var int ok = 0;
    do
        $bytes = 0;
        var UV_Stream_Read r = UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&bytes);
        AWAIT_UNTIL(r,1);
        _assert(r.next >= 1);
        if r.next > 1 then
            escape _ERR_EXTRA_BYTES;
        end
        ok = bytes[0];
    end
    _printf("OK = %d\n", ok);

    escape ok;
end

class TX_PROPOSE_recv with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>TX_PROPOSE_recv build;
do
    function (_uv_tcp_t& tcp)=>TX_PROPOSE_recv build do
        this.tcp = &tcp;
    end

    var u8[TX_PROPOSE_BYTES] bytes;
    var UV_Stream_Read r = UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&bytes);

    var int nxt = 0;
    var int off = nxt;

    // <= BC_LEN, BC_DATA
    do
        nxt = nxt + 1;
        AWAIT_UNTIL(r,nxt);
        var int bc_len = bytes[off];
        _printf("BC_LEN = %d\n", bc_len);

        off = nxt;
        nxt = nxt + bc_len;
        AWAIT_UNTIL(r,nxt);
        _printf("BC_DATA = [");
        loop i in bc_len do
            _printf("%2d", bytes[off+i]);
        end
        _printf(" ]\n");
    end

    // <= N_ZEROS
    do
        off = nxt;
        nxt = nxt + 1;
        AWAIT_UNTIL(r,nxt);
        var int n_zeros = bytes[off];
        _printf("N_ZEROS = %d\n", n_zeros);
    end

    // <= BLK_BACK_HASH
    do
        off = nxt;
        nxt = nxt + HASH_BYTES;
        AWAIT_UNTIL(r,nxt);
        _printf("BLK_BACK_HASH = [");
        loop i in HASH_BYTES do
            _printf("%2X", bytes[off+i]);
        end
        _printf(" ]\n");
    end

    // <= DATA_PL_HASH
    do
        off = nxt;
        nxt = nxt + HASH_BYTES;
        AWAIT_UNTIL(r,nxt);
        _printf("DATA_PL_HASH = [");
        loop i in HASH_BYTES do
            _printf("%2X", bytes[off+i]);
        end
        _printf(" ]\n");
    end

    // == END
    _assert(r.next >= nxt);
    if r.next > nxt then
        escape _ERR_EXTRA_BYTES;
    end

    // TODO: check
    bytes = [1];
    do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

    escape _SUCCESS;
end

#endif
