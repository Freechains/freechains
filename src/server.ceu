#ifndef _SERVER_CEU
#define _SERVER_CEU

class Message10_00_chain with
input:
    var byte[]&         bytes;
    var UV_Stream_Read& reader;

    function (byte[]& bytes, UV_Stream_Read& reader)=>Message10_00_chain receive;
do
    function (byte[]& bytes, UV_Stream_Read& reader)=>Message10_00_chain receive do
        this.bytes  = &bytes;
        this.reader = &reader;
    end

    [[
        MSG = {
            id = '1.0',
            chain = {
                key    = nil,
                zeros  = nil,
            },
            block_hash = nil,
            back_hash  = nil,
            tail_hash  = nil,
            up_hash    = nil,
        }
    ]];

    var int err = _ERR_NONE;
    var u32 off = MESSAGE_BYTES;

    // => CHAIN_ZEROS
    // => CHAIN_LEN
    var u8 chain_zeros = 0;
    var u8 chain_len   = 0;
    do
        do UV_Stream_ReadUntil.run(&reader, off+2);
        chain_zeros = bytes[off+0];
        chain_len   = bytes[off+1];
        _printf("[server] CHAIN_ZEROS = %d\n",  chain_zeros);
        _printf("[server] CHAIN_LEN   = %d\n", chain_len);

        off = off + 2;
    end
    [[ MSG.chain.zeros = @chain_zeros ]];

    // => CHAIN_KEY
    var char[] chain_key;
    do
        do UV_Stream_ReadUntil.run(&reader, off+chain_len);
        $chain_key := chain_len;
        native @pure _OFF();
        native do
            ##define OFF(vec,off) ((char*)(vec+off))
        end
        _strncpy((_char&&)&&chain_key, _OFF((_byte&&)&&bytes,off), chain_len);
        _printf("[server] CHAIN_KEY   = %s\n", (_char&&)&&chain_key);

        // [check] Am I subscribed to the message chain?
        [[ CHAIN = APP.server.chains[@chain_key] ]];
        var bool is_sub = [[ CHAIN~=nil and CHAIN.zeros<=@chain_zeros ]];
        if not is_sub then
            err = _MESSAGE10_NOTSUB;    // OK ACK
        end

        off = off + chain_len;
    end
    [[ MSG.chain.key = @chain_key ]];

    escape err;
end

class Message10_01_oldest_hash with
input:
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>Message10_01_oldest_hash receive;
do
    function (_uv_tcp_t& tcp)=>Message10_01_oldest_hash receive do
        this.tcp = &tcp;
    end

    // => HASH
    // <= ACK:
    //      - MESSAGE10_HAVE_YES: found common
    //      - MESSAGE10_HAVE_NO:  keep sending

    var int n_bytes = 0;
    var u32 limit = [[ APP.server.message10_payload_len_limit ]];
    loop i do
        if n_bytes > limit then
_assert(0); // TODO test it
            escape _MESSAGE10_PAYLOAD_LEN_LIMIT;
        end
        n_bytes = n_bytes + HASH_BYTES;

        var u32 payload_len = 0;
        do
            var byte[HASH_BYTES+sizeof(u32)] bs;
            var UV_Stream_Read reader =
                    UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp), &bs);
            do UV_Stream_ReadUntil.run(&reader, HASH_BYTES+sizeof(u32));

            // => BLOCK_HASH
            // this can be the oldest missing
            var byte[HASH_BYTES] hash;
            _ceu_vector_copy_buffer(&&hash, 0,
                                    (_byte&&)&&bs, HASH_BYTES,
                                    1);

            // => PAYLOAD_LEN
            payload_len = GET_HOST_U32(bs, HASH_BYTES);

            [[
                MSG.block_hash  = @hash
                MSG.payload_len = @payload_len
                if MSG.up_hash then
                    APP.blocks[MSG.up_hash].tail_hash = MSG.block_hash
                end
            ]];
        end

        [[
            print('[server] BLOCK_HASH ['..@i..'] = '..MSG.payload_len..' {')
            print(hex_dump(MSG.block_hash))
            print('}')
        ]];

        // [check] Do I have this message hash? [ok ACK]
        var bool have = [[ APP.blocks[MSG.block_hash] ]];
        _printf("[server] OLD-have? [0/1] = %d\n", have);

        var byte[1] send;
        var int err = _ERR_NONE;
        if have then
            send = [ _MESSAGE10_HAVE_YES ];
            if i == 0 then
                // first iteration, I already have all messages...
                err  = _MESSAGE10_HAVE_YES;
            else
                // further iterations, I don't have the previous message
                [[
                    -- save "FORK_HASH" for join
                    -- prepare "MSG" to receive the whole forked chain
                    FORK_HASH = APP.blocks[MSG.up_hash].block_hash
                    MSG       = APP.blocks[FORK_HASH]
                ]];
                err = _MESSAGE10_HAVE_NO;
            end
        else/if payload_len > limit then
            // [check] Is the message too big? [ok ACK]
            send = [ _MESSAGE10_PAYLOAD_LEN_LIMIT ];
            err = _MESSAGE10_PAYLOAD_LEN_LIMIT;
        else
            // I don't have this message
            // OK: continue to the next
            send = [ _MESSAGE10_HAVE_NO  ];
            [[
                APP.blocks[MSG.block_hash] = MSG
                MSG = {
                    id      = MSG.id,
                    chain   = MSG.chain,
                    up_hash = MSG.block_hash,   -- client will transmit all MSG.up.up...
                }
            ]];
        end
        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &send);

        if err != _ERR_NONE then
            escape err;
        end
    end
    _assert(0);
end

class Message10_02_block with
input:
    var UV_Stream_Read& reader;
input/output:
    var byte[]& bytes;
    var u32&    off;

    function (UV_Stream_Read& reader, byte[]& bytes, u32& off)=>Message10_02_block receive;

do
    function (UV_Stream_Read& reader, byte[]& bytes, u32& off)=>Message10_02_block receive do
        this.reader = &reader;
        this.bytes  = &bytes;
        this.off    = &off;
    end

    // => PoW
    var u32 pow = 0;
    do
        do UV_Stream_ReadUntil.run(&this.reader, off + sizeof(u32));
        pow = GET_HOST_U32(bytes,off);
        _printf("[server] POW = %X\n", pow);
        [[ MSG.pow = @pow ]];
        off = off + sizeof(u32);
    end

    // => BACK_HASH
    // TODO: check
    var byte[HASH_BYTES] back_hash;
    do
        do UV_Stream_ReadUntil.run(&this.reader, off + HASH_BYTES);
        _ceu_vector_copy_buffer(&&back_hash, 0,
                                (_byte&&)&&bytes[off], HASH_BYTES,
                                1);
        [[
            MSG.back_hash = @back_hash
            print('[server] BACK_HASH = {')
            print(hex_dump(MSG.back_hash))
            print('}')
        ]];

        // [check] BACK_HASH is young enough? [ok ACK]
        do
#if 1
            _printf("TODO: BLOCK_HASH young enough?\n");
#else
            var int n = [[ APP.server.chains.BACK_HASH_JUMP_LIMIT ]];
            [[ HEAD = APP.server.chains[MSG.chain.key].heads[MSG.chain.zeros] ]];
            loop i in n do
                var bool is_eq = [[ HEAD == MSG.back_hash ]];
                if is_eq then
                    xxx
                end
               [[ HEAD = APP ]]
            end
#endif
        end
        off = off + HASH_BYTES;
    end
    _assert($back_hash == HASH_BYTES);

    // => TAIL_HASH
    // already received from remote responding HAVE_YES
    // => PAYLOAD_LEN
    // already received from remote responding HAVE_NO

    // => PAYLOAD
    var byte[] payload;
    do
        var u32 payload_len = [[ MSG.payload_len ]];
        do UV_Stream_ReadUntil.run(&this.reader, off + payload_len);

        _ceu_vector_copy_buffer(&&payload, 0,
                                &&(((_byte&&)&&bytes)[off]), payload_len,
                                1);
        [[
            MSG.payload = @payload
            print('[server] PAYLOAD {')
            print(hex_dump(MSG.payload))
            print('}')
        ]];
        off = off + payload_len;
    end

    // [check] BLOCK_HASH is correct? [no ACK]
    do
        var byte[] plain;
        PUT_NETWORK_U32(plain, 0, pow);
        plain = []..plain..back_hash..payload;

        var byte[HASH_BYTES] hash;
        _crypto_generichash((_byte&&)&&hash, HASH_BYTES,
                            (_byte&&)&&plain, $plain,
                            null, 0);
//[[print('{\n'..hex_dump(@plain)..'}')]];

        var char[HASH_BYTES] block_hash = [[ MSG.block_hash ]];
        var int ret = _memcmp((_char&&)&&block_hash, (_byte&&)&&hash, HASH_BYTES);
        _printf("[server] POW? %d\n", ret==0);
        if ret != 0 then
            escape _ERR_REMOTE_BUG_OR_MALICIOUS;
        end
    end

    // => PoS
    // TODO: check
    do
        do UV_Stream_ReadUntil.run(&this.reader, off + 1);
        var int pos = bytes[off];
        _printf("[server] POS = %X\n", pos);
        [[ MSG.pos = @pos ]];
#if 1
        _printf("TODO: POS matches?\n");
#endif
        off = off + 1;
    end

    escape _ERR_NONE;
end

class Message10_recv with
input:
    var _uv_tcp_t&      tcp;
    var byte[]&         bytes;
    var UV_Stream_Read& reader;

    function (_uv_tcp_t& tcp, byte[]& bytes, UV_Stream_Read& reader)=>Message10_recv run;
do
    function (_uv_tcp_t& tcp, byte[]& bytes, UV_Stream_Read& reader)=>Message10_recv run do
        this.tcp    = &tcp;
        this.bytes  = &bytes;
        this.reader = &reader;
    end

    ///////////////////////////////////////////////////////////////////////////////
    // CHAIN
    ///////////////////////////////////////////////////////////////////////////////

    // bytes/reader received from message partially parsed
    do
        var int err = do Message10_00_chain.receive(&bytes,&reader);
        do
            _printf("[server] ACK-chain = %d\n", err);
            var byte[1] send = [err];
            do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &send);
        end
        if err == _MESSAGE10_NOTSUB then
            escape err;
        end
    end

    ///////////////////////////////////////////////////////////////////////////////
    // HASHES
    ///////////////////////////////////////////////////////////////////////////////

    // receive oldest hash that I don't have
    do
        // new bytes/reader inside
        var int err = do Message10_01_oldest_hash.receive(&tcp);
        _printf("[server] ACK-oldest = %d\n", err);
        if err != _MESSAGE10_HAVE_NO then
            _assert(err == _MESSAGE10_HAVE_YES or
                    err == _MESSAGE10_PAYLOAD_LEN_LIMIT);
            escape err;
        end
        _assert(err == _MESSAGE10_HAVE_NO);
    end

    // receive oldest=>newest blocks I don't have
    do
        // TODO: buffer for *all* payloads,etc
        var byte[] bytes;
        var u32 off = 0;
        var UV_Stream_Read reader =
                UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);
        loop i do
            _printf("[server] Receiving %d...\n", i);
            var int err = do Message10_02_block.receive(&reader, &bytes, &off);
            _printf("[server] Received %d!\n", i);
            _assert(err == _ERR_NONE);
            var bool up = [[ MSG.up_hash~=nil ]];
            if up then
                [[ MSG = assert(APP.blocks[MSG.up_hash]) ]];
            else
                break;
            end
        end
    end

    ///////////////////////////////////////////////////////////////////////////////
    // CHECK/SET NEW HEAD
    ///////////////////////////////////////////////////////////////////////////////

    [[
        -- COMPARE THE TWO CHAINS
        --  - remote: possible fork from remote host
        --  - common: local chain starting from block in common with remote

        local remote = APP.blocks[FORK_HASH]
        local common = APP.blocks[remote.tail_hash]

        remote = APP.chain_base_head_len(remote)
        common = APP.chain_base_head_len(common)
        assert(remote.len > 0)
        print('[server] COM='..common.len..' vs NEW='..remote.len)

        local SRC, DST
        if remote.len >= common.len then
            -- ">=" because remote also has common_hash
            DST, SRC = remote, common
        else
            DST, SRC = common, remote
        end

        -- CONCATENATE THE TWO CHAINS (DST .. SRC)

        -- DST: ...->1->4->5->K->6
        -- SRC: ...->1->2->K->3
        -- set: ...->1->4->5->K->6->2->3
        --  // TODO: has to check if 2,3 back blocks are still valid!

        local put = DST.head
        do
            local src = SRC.base
            if SRC == common then
                src.up_hash = DST.base.block_hash -- redirect new chain
                src = APP.blocks[src.up_hash]     -- skip common block
            end
            while src ~= nil do
                local to_ins_src = true
                local dst = DST.base
                while dst~=nil and dst.tail_hash~=DST.head.block_hash do
                    if dst.block_hash == src.block_hash then
                        to_ins_src = false
                        break
                    end
                    dst = APP.blocks[dst.up_hash]
                end
                if to_ins_src then
                    put.up_hash   = src.block_hash
                    src.tail_hash = put.block_hash
                    put = APP.blocks[src.block_hash]
                end
                src = APP.blocks[src.up_hash]
            end
        end

        if DST==common and DST.head==put then
            -- no changes
            MSG = nil   -- nothing to retransmit
        else
            -- new chain head
            MSG = APP.blocks[put.block_hash]
            APP.server.chains[MSG.chain.key].heads[MSG.chain.zeros] = put.block_hash
        end
    ]];

    ///////////////////////////////////////////////////////////////////////////////
    // RETRANSMIT NEW HEAD
    ///////////////////////////////////////////////////////////////////////////////

    do
        var bool has = [[ MSG~=nil ]];
        if has then
            var int err = do Client;
            escape err;
        end
    end

    escape _ERR_NONE;
end

class UV_TCP_Server_Handler with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>UV_TCP_Server_Handler build;
do
    function (_uv_tcp_t& tcp)=>UV_TCP_Server_Handler build do
        this.tcp = &tcp;
    end

    var int err = _ERR_NONE;

    var byte[] bytes;
    var UV_Stream_Read reader =
            UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

    // => MESSAGE
    do UV_Stream_ReadUntil.run(&this.reader, MESSAGE_BYTES);

    _printf("[server] MESSAGE = [%d %d %d %d]\n",
                bytes[0], bytes[1], bytes[2], bytes[3]);

    var bool ok = ( bytes[0]==MESSAGE_MAGIC_0 and
                    bytes[1]==MESSAGE_MAGIC_1 );

    if ok and bytes[2]==1 and bytes[3]==0 then
        err = do Message10_recv.run(&this.tcp, &this.bytes, &this.reader);
    else
        err = _ERR_MESSAGE;
    end

    _printf("[server] DONE: %d\n", err);
    escape err;
end

#endif
