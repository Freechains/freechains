#ifndef _SERVER_CEU
#define _SERVER_CEU

code/await Connection (var& _uv_tcp_t tcp)
                        -> (vector[] byte bytes, var usize off, var&? UV_Stream_Read reader)
                            -> FOREVER
do
    off = 0;
    reader = spawn UV_TCP_Read(&tcp, &bytes);
    await FOREVER;
end

code/await Message10_header_recv (var& Connection conn) -> int
do
    // => CHAIN_LEN
    // => CHAIN_KEY
    // => CHAIN_ZEROS
    do/_
        // zeros
        await UV_Stream_ReadUntil(&conn.reader!, conn.off+1);
        var byte chain_zeros = conn.bytes[conn.off];
        _dbg_tcp(2, &&conn.tcp, "server", "CHAIN_ZEROS = %d",  chain_zeros);
        conn.off = conn.off + 1;

        // len
        await UV_Stream_ReadUntil(&conn.reader!, conn.off+1);
        var byte chain_len = conn.bytes[conn.off];
        conn.off = conn.off + 1;
        _dbg_tcp(2, &&conn.tcp, "server", "CHAIN_LEN   = %d", chain_len);

        // key
        vector[] byte chain_key;
        await UV_Stream_ReadUntil(&conn.reader!, conn.off+(chain_len as usize));
        _ceu_vector_setlen(&&chain_key,chain_len,1);
        if chain_len > 0 then
            _memcpy(&&chain_key[0], &&conn.bytes[conn.off], chain_len);
        end
        _dbg_tcp(2, &&conn.tcp, "server", "CHAIN_KEY   = %s", &&chain_key[0]);
        conn.off = conn.off + (chain_len as usize);

        [[
            G(conn.tcp).chain = GG.chain_parse_get( {
                key   = @chain_key,
                zeros = @chain_zeros,
            } )
        ]];

        var bool is_sub = [[ G(conn.tcp).chain ~= nil ]];
        _dbg_tcp(2, &&conn.tcp, "server", "is_sub      = %d", is_sub);
        if not is_sub then
            escape _MESSAGE10_NOTSUB;    // OK ACK
        end

        // TODO: check CHAIN_LIMITS
    end

    escape _ERR_NONE;
end

code/await Message10_block_recv (var& Connection conn) -> int
do
    // => BLOCK_HASH
    // => BLOCK_TXS_N
    do
        // hash
        await UV_Stream_ReadUntil(&conn.reader, conn.off+HASH_BYTES);
        vector[HASH_BYTES] byte hash;
        _ceu_vector_setlen(&&hash, HASH_BYTES, 1);
        _ceu_vector_buf_set(&&hash, 0, &&conn.bytes[conn.off], HASH_BYTES);
        conn.off = conn.off + HASH_BYTES;

        // txs_n
        var u32 txs_n = GET_HOST_U32(conn.bytes, conn.off);
        conn.off = conn.off + sizeof(u32);

        [[
            G(conn.tcp).block.hash = @hash;
            --print('[server] => BLOCK_HASH', string.len(G(conn.tcp).block.hash))
            --print(tostring2(G(conn.tcp).block.hash))
            --print('[server] => BLOCK_TXS_N', @txs_n)
            G(conn.tcp).block.txs_n = @txs_n
        ]];
    end

    // check if block is already on chain
    [[
        have = false
        cur = assert( APP.blocks[ G(conn.tcp).chain.head_hash ] )
        while true do
            if cur.hash == G(conn.tcp).block.hash then
                have = true
                break
            end
            if not cur.tail_hash then
                break
            end
            cur = assert(APP.blocks[cur.tail_hash])
        end
    ]];

    var bool have = [[ have ]];
    if have then
        escape _MESSAGE10_HAVE;    // OK ACK
    else
        escape _ERR_NONE;
    end
end

code/await Message10_tx_recv (var& Connection conn) -> int
do
    // => TX_PAYLOAD_BYTES
    // => TX_HASH
    do/_
        // hash
        await UV_Stream_ReadUntil(&conn.reader, conn.off+HASH_BYTES);
        vector[HASH_BYTES] byte hash;
        _ceu_vector_setlen(&&hash, HASH_BYTES, 1);
        _ceu_vector_buf_set(&&hash, 0, &&conn.bytes[conn.off], HASH_BYTES);
        conn.off = conn.off + HASH_BYTES;

        var int zeros_wanted = [[ G(conn.tcp).chain.zeros ]];
        if zeros_wanted > _leading_zeros(&&hash[0],HASH_BYTES) then
// TODO: test-case to fail here
// TODO: also change from ">" to "!="
_ceu_dbg_assert(0);
            escape _ERR_REMOTE_BUG_OR_MALICIOUS;
        end

        // payload_bytes
        await UV_Stream_ReadUntil(&conn.reader, conn.off+sizeof(u32));
        var u32 payload_bytes = GET_HOST_U32(conn.bytes, conn.off);
        conn.off = conn.off + sizeof(u32);

        // TODO: check payload_bytes vs chain.limits

        [[
            payload_bytes = @payload_bytes
            tx_hash = @hash;
            --print('[server] => TX_HASH', payload_bytes)
            --print(tostring2(tx_hash))

            tx = APP.txs[tx_hash]
            if tx == nil then
                G(conn.tcp).tx = {
                    hash  = tx_hash,
                    bytes = payload_bytes,
                }
            else
                G(conn.tcp).tx = tx
            end
        ]];
        var bool have = [[ tx ~= nil ]];

        // <= ACK-tx
        do
            vector[1] byte send;
            if have then
                send = [ _MESSAGE10_HAVE ];
            else
                send = [ _ERR_NONE  ];
            end
            _dbg_tcp(0, &&conn.tcp, "server", "<= ACK-tx = %d", send[0]);
            await UV_TCP_Write(&conn.tcp, &send);
        end

        // HAVE_YES: next TX
        if have then
            escape _ERR_NONE;
        end
    end
    // HAVE_NO: complete TX

    // => TX_COMPLETE
    do
        // => NONCE/TIMESTAMP: 128 bits
        vector[NONCE_BYTES] byte nonce;
        do
            await UV_Stream_ReadUntil(&conn.reader, conn.off + NONCE_BYTES);
            _ceu_vector_setlen(&&nonce,NONCE_BYTES,1);
            var int i;
            loop i in [0 -> NONCE_BYTES[ do
                nonce[i] = conn.bytes[conn.off+i];
            end
            [[ G(conn.tcp).tx.nonce = @nonce ]];
            //[[ print('NONCE', tostring2(G(conn.tcp).tx.nonce)) ]];
            //_printf("[server] => TIMESTAMP = %X\n", timestamp);
            conn.off = conn.off + NONCE_BYTES;
        end

        // => TX_BACK_HASH
// TODO: check back_hash
        vector[HASH_BYTES] byte back_hash;
        do
            await UV_Stream_ReadUntil(&conn.reader, conn.off + HASH_BYTES);
            _ceu_vector_setlen(&&back_hash, HASH_BYTES, 1);
            _ceu_vector_buf_set(&&back_hash, 0, &&conn.bytes[conn.off], HASH_BYTES);
            conn.off = conn.off + HASH_BYTES;
            _ceu_dbg_assert($back_hash == HASH_BYTES);
            [[
                G(conn.tcp).tx.back_hash = @back_hash;
                --print('[server] => TX_BACK_HASH')
                --print(tostring2(G(conn.tcp).tx.back_hash))
            ]];

            // [check] BACK_HASH is young enough? [ok ACK]
            do
#if 1
                //_printf("TODO: BLOCK_HASH young enough?\n");
#else
                var int n = [[ APP.server.chains.BACK_HASH_JUMP_LIMIT ]];
                [[ head_hash = APP.server.chains[MSG.chain.key].heads[MSG.chain.zeros] ]];
                loop i in n do
                    var bool is_eq = [[ head_hash == MSG.back_hash ]];
                    if is_eq then
                        xxx
                    end
                   [[ head_hash = APP ]]
                end
#endif
            end
        end

        // => TX_PAYLOAD
        vector[] byte tx_payload;
        do
            var usize len = [[ G(conn.tcp).tx.bytes ]];
            await UV_Stream_ReadUntil(&conn.reader, conn.off + len);
            _ceu_vector_setlen(&&tx_payload, len, 1);
            _ceu_vector_buf_set(&&tx_payload, 0,
                                &&((_ID(&&conn.bytes[0]))[conn.off]), len);
            [[
                G(conn.tcp).tx.payload = @tx_payload;
                --print('[server] => PAYLOAD')
                --print(tostring2(G(conn.tcp).tx.payload))
            ]];
            conn.off = conn.off + len;
        end

        // => POS: TODO
        do
            await UV_Stream_ReadUntil(&conn.reader, conn.off + 1);
            var int pos_ = conn.bytes[conn.off];
            //_printf("[server] POS = %X\n", pos_);
            [[ G(conn.tcp).tx.pos = @pos_ ]];
            //_printf("TODO: POS matches?\n");
            conn.off = conn.off + 1;
        end
    end

    escape _ERR_NONE;
end

code/await Message10_recv (var& Connection conn) -> int
do
    [[
        G(conn.tcp) = {
            chain = nil,
        }
    ]];

    ///////////////////////////////////////////////////////////////////////////
    // HEADER
    ///////////////////////////////////////////////////////////////////////////

    // <= ACK-header
    // bytes/reader received from message partially parsed
    var int err = await Message10_header_recv(&conn);
    //call conn.Reset();
_ceu_dbg_assert(0); // Reset
    if err == _MESSAGE10_NOTSUB then
        vector[1] byte send = [err];
        await UV_TCP_Write(&conn.tcp, &send);
        escape err;     // terminate if not subcribed
    end

    // LOCK: only one "receive" per chain
    do
        var bool is_locked = [[ G(conn.tcp).chain.recv_is_locked ]];
        if is_locked then
            loop do
                par/or do
                    await outer.recv_chain_unlocked;
                with
                    await 1s;
                end
                is_locked = [[ G(conn.tcp).chain.recv_is_locked ]];
                if not is_locked then
                    break;
                end
            end
        end
        [[ G(conn.tcp).chain.recv_is_locked = true ]];
    end

// TODO: primitive "lock"
do
{SERVERS_ALIVE++;}
    do finalize with
        //var bool is_locked = [[ G(conn.tcp).chain.recv_is_locked ]];
        //_ceu_dbg_assert(not is_locked);
        [[ G(conn.tcp).chain.recv_is_locked = false ]];
{SERVERS_ALIVE--;}
    end

    do
        vector[1] byte send = [err];
        await UV_TCP_Write(&conn.tcp, &send);
    end

    [[
        G(conn.tcp).remote_head = nil
        G(conn.tcp).remote_base = nil
    ]];

    ///////////////////////////////////////////////////////////////////////////
    // BLOCKS:
    ///////////////////////////////////////////////////////////////////////////

    err = _ERR_NONE;
    err = do
        var int i;
        loop i do
{BLOCKS_RECEIVED++;}
            [[
                G(conn.tcp).previous = G(conn.tcp).block
                G(conn.tcp).block = {
                    id        = '1.0',
                    chain_id  = G(conn.tcp).chain.id,
                    txs       = {},
                    hash      = nil,
                    up_hash   = nil,
                    tail_hash = nil,
                }
            ]];

            // <= ACK-block
            do/_
                var int err2 = await Message10_block_recv(&conn);

                // consolidate previous block
                var bool ok = [[ G(conn.tcp).previous ~= nil ]];
                if ok then
                    [[
                        G(conn.tcp).previous.tail_hash = assert(G(conn.tcp).block.hash)
                        ARGS = { block=G(conn.tcp).previous }
                    ]];
                    var int ret = await BlockHash(SourceBlockHash.Network());
                    if ret != _ERR_NONE then
#ifdef FREECHAINS_NO_MALICIOUS
                        _ceu_dbg_assert(0);
#endif
                        escape ret;
                    end
                end

                //conn.reset();
                _ceu_dbg_assert(0); // Reset

                //[[ print('[server] => BLOCKS['..(@i)..'] : 
                //'..tostring2(G(conn.tcp).block.hash)) ]];

                do
                    _dbg_tcp(0, &&conn.tcp, "server", "<= ACK-block[%d] = %d",
                            _ceu_uv_tcp_getsockport(&&conn.tcp),
                            _ceu_uv_tcp_getpeerport(&&conn.tcp),
                            i, err2);
                    vector[1] byte send = [err2];
                    await UV_TCP_Write(&conn.tcp, &send);
                end

                // FOUND COMMON BLOCK?
                if err2 == _MESSAGE10_HAVE then
                    if i == 0 then
                        escape _MESSAGE10_HAVE;   // nothing new
                    else
                        escape _ERR_NONE;         // check/set new head
                    end
                end

                // received at least one new block
                [[
                    if (@i) == 0 then
                        G(conn.tcp).remote_head = G(conn.tcp).block
                    else
                        G(conn.tcp).remote_base.tail_hash = G(conn.tcp).block.hash
                        G(conn.tcp).block.up_hash = G(conn.tcp).remote_base.hash
                    end

                    G(conn.tcp).remote_base = G(conn.tcp).block
                ]];
            end

            ///////////////////////////////////////////////////////////////////////////
            // TXS
            ///////////////////////////////////////////////////////////////////////////

            do/_
                var int txs_n = [[ G(conn.tcp).block.txs_n ]];
                _dbg_tcp(0, &&conn.tcp, "server", "=> %d txs (ini)", txs_n);
                var int j;
                loop j in [0 -> txs_n[ do
                    _dbg_tcp(0, &&conn.tcp, "server", "=> %d txs[%d]", txs_n, j);
                    var int err2 = await Message10_tx_recv(&conn);
                    if err2 != _ERR_NONE then
                        escape err2;
                    end
                    [[
                        G(conn.tcp).block.txs[@j+1] = G(conn.tcp).tx.hash
                        G(conn.tcp).block.txs[G(conn.tcp).tx.hash] = G(conn.tcp).tx
                    ]];
                end
                _dbg_tcp(0, &&conn.tcp, "server", "=> %d txs (end)", txs_n);
            end
        end
        //_ceu_dbg_assert(0);
        escape _ERR_NONE;
    end;

    kill conn.reader;

    // UNLOCK "receive"
    [[ G(conn.tcp).chain.recv_is_locked = false ]];   // TODO: remove?
end
    emit outer.recv_chain_unlocked;

    if err == _MESSAGE10_HAVE then
        escape _ERR_NONE;   // nothing new, but no error
    else/if err != _ERR_NONE then
        escape err;         // some error
    end

    // BLOCK holds the COMMON node
    [[
        common_hash = G(conn.tcp).block.hash
        assert(G(conn.tcp).remote_head and G(conn.tcp).remote_base, '1')
        G(conn.tcp).remote_base.tail_hash = common_hash
    ]];

    ///////////////////////////////////////////////////////////////////////////////
    // CHECK/SET NEW HEAD
    ///////////////////////////////////////////////////////////////////////////////

    /*
     * LOCAL:  gen <-> 1 <-> 2 <-> 3
     *                       | LOCAL
     *                       \BASE \HEAD
     * REMOTE:         | <-  4 <-> 5 <-> 6
     *                       \BASE       \HEAD
     * common_hash:   "1"
     * (COMMON "1" still ups to LOCAL, but REMOTE tails to "1")
     */

    // compare chains, set longest, apply shortest
    [[
        -- { base=?, head=?, size=? }
        local_ = GG.chain_head_base_size(G(conn.tcp).chain.head_hash)
        remote = GG.chain_head_base_size(G(conn.tcp).remote_head.hash)
        --print('[server] LOC='..local_.size..' vs REM='..remote.size)

        -- dst is the longest
        -- src is the shortest
        -- TODO-LEN:
        dst, src = nil, nil
        if remote.size > local_.size then
            dst, src = remote, local_
        elseif local_.size > remote.size then
            dst, src = local_, remote
        else
            -- break tie on hash value of head
            assert(remote.size == local_.size)
            if remote.head.hash > local_.head.hash then
                dst, src = remote, local_
            else
                dst, src = local_, remote
            end
        end

        -- relink current chain's head/common if longest is remote
        if dst == remote then
            APP.blocks[common_hash].up_hash = G(conn.tcp).remote_base.hash
            G(conn.tcp).chain.head_hash = dst.head.hash
        else
            --print('[server] local wins')
            -- already ok
        end

        -- apply shortest to new block with all missing txs
        block_new = {
            id        = '1.0',  -- TODO
            txs       = {},
            up_hash   = nil,
            chain_id  = G(conn.tcp).chain.id,
            -- set by Message10_block_parse_head
            --tail_hash = dst.head.hash,
            --hash      = error'TODO',
        }

        -- insert all src* txs into block_new.txs if non existent
        cur = src.head
        T = {}  -- txs in base->head order
        while cur.hash ~= common_hash do
            t = {}
            for _, tx in ipairs(cur.txs) do
                assert(type(tx) == 'string')
                if not GG.chain_tx_contains(dst.head.hash,tx) then
                    t[#t+1] = tx
                end
            end
            cur = assert(APP.blocks[cur.tail_hash])
            table.insert(T, 1, t) -- inverse order
        end
        for _, t in ipairs(T) do
            for _, tx in ipairs(t) do
                block_new.txs[#block_new.txs+1] = tx
            end
        end

        ARGS = {
            block = block_new
        }
    ]];
    var bool has_txs = [[ #block_new.txs > 0 ]];
    if has_txs then
{BLOCKS_RECREATED++;}
        [[
            ARGS = { block=block_new }
        ]];
        var int ret = await BlockHash(SourceBlockHash.Network());
        _ceu_dbg_assert(ret == _ERR_NONE);
        [[
            APP.blocks[G(conn.tcp).chain.head_hash].up_hash = ARGS.block.hash
            G(conn.tcp).chain.head_hash = ARGS.block.hash
        ]]
    end

    ///////////////////////////////////////////////////////////////////////////
    // RETRANSMIT NEW HEAD
    ///////////////////////////////////////////////////////////////////////////

    do
        // TODO: conditions to not propagate changes
        //var bool has = [[ block_new ~= dst.head ]];
        //if has then
            [[
                ARGS = {
                    app      = APP,
                    chain_id = G(conn.tcp).chain.id,
                }
            ]];
            emit outer.go_client;
        //end
    end

    escape _ERR_NONE;
end

code/await UV_TCP_Server_Handler (var& _uv_tcp_t tcp) -> int
do
    spawn do
        var _uv_stream_t&& s;
        var int err;
        (s,err) = await UV_STREAM_ERROR until (s==(&&tcp as _uv_stream_t&&));
        //_dbg(2, "server | disconnected from %s:%d", (_char&&)&&ip, port);
        _ceu_dbg_assert(err != _ERR_NONE);
        _dbg(0, "server | %s\n", _uv_strerror(err));
        escape err;
    end

    var int err = _ERR_NONE;

    var& Connection conn = spawn Connection(&tcp);

    // => MESSAGE
    await UV_Stream_ReadUntil(&conn.reader, conn.off + MESSAGE_BYTES);
    conn.off = conn.off + MESSAGE_BYTES;

    //_printf("[server] => MESSAGE = [%d %d %d %d]\n",
                //bytes[0], bytes[1], bytes[2], bytes[3]);

    var bool ok = ( conn.bytes[0]==MESSAGE_MAGIC_0 and
                    conn.bytes[1]==MESSAGE_MAGIC_1 );

    if ok and conn.bytes[2]==1 and conn.bytes[3]==0 then
        err = await Message10_recv(&conn);
    else
        err = _ERR_MESSAGE;
    end

    if err != _ERR_NONE then
        [[ APP.errs[#APP.errs+1] = @err ]];
    end

#ifdef FREECHAINS_NO_MALICIOUS
    _ceu_dbg_assert(err == _ERR_NONE);
#endif

    //_printf("[server] DONE: %d\n", err);
    escape err;
end

#endif
