#ifndef _SERVER_CEU
#define _SERVER_CEU

code/await UV_TCP_Server_Handler (var& UV_Stream tcp, var& UV_TCP_Server_Data shared) -> none
do
    _dbg(3, "server | new handler");

    var int msg = 0;
    var int ret = 0;

    var Exception.Uv? e1;

    par/or do
        var int timeout = [[ CFG.server.timeout or 0 ]];
        if timeout == 0 then
            await FOREVER;
        else
            await (timeout)s;
        end
        emit shared.ok(msg,true,{MESSAGE10_TIMEOUT});
    with
        var Exception.Freechains? e2;
        catch e1,e2 do
            // => MESSAGE
            await UV_Stream_Read_N(&tcp, MESSAGE_BYTES);

            //_printf("[server] => MESSAGE = [%d %d %d %d]\n",
                        //bytes[0], bytes[1], bytes[2], bytes[3]);

            var bool ok = ( tcp.buffer[0]==MESSAGE_MAGIC_0 and
                            tcp.buffer[1]==MESSAGE_MAGIC_1 );

            msg = (tcp.buffer[2]<<8) + (tcp.buffer[3]<<0);

            $tcp.buffer = $tcp.buffer - MESSAGE_BYTES;

            if ok and msg=={MESSAGE10} then
                do ()
                    var int out;
                    out = do/out
                        #include "server/message10_recv.ceu"
                        // output: { ARGS={chain={...}} }
                    end;
                    outer.ret = out;
                end
            else
                var Exception.Freechains.Unsupported e = val Exception.Freechains.Unsupported(_);
                throw e;
            end
        end

        if e1? then
            [[ FC.errs[#FC.errs+1] = @(e1! as int) ]];
            emit shared.ok(msg,true,e1! as int);
        else/if e2? then
            [[ FC.errs[#FC.errs+1] = @(e2! as int) ]];
            emit shared.ok(msg,true,e2! as int);
        else
            if ret != {MESSAGE10_OK} then
                [[ FC.errs[#FC.errs+1] = @ret ]];
            end
            // input: { ARGS={chain={...}} }
            emit shared.ok(msg,false,ret);
        end
    end
end

#endif
