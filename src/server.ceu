#ifndef _SERVER_CEU
#define _SERVER_CEU

code/await UV_TCP_Server_Handler (var& UV_Stream tcp, var& UV_TCP_Server_Data shared) -> none
do
    _dbg(3, "server | new handler");

    var int msg = 0;
    var int ret = 0;

    var Exception? e;
    catch e do
        par/or do
            var int timeout = [[ CFG.daemon.timeout or 0 ]];
            if timeout == 0 then
                await FOREVER;
            else
                await (timeout)s;
            end
            emit shared.err_server(msg, {MESSAGE10_TIMEOUT});
        with
            // => MESSAGE
            await UV_Stream_Read_N(&tcp, MESSAGE_BYTES);

            //_printf("[server] => MESSAGE = [%d %d %d %d]\n",
                        //bytes[0], bytes[1], bytes[2], bytes[3]);

            var bool ok = ( tcp.buffer[0]==MESSAGE_MAGIC_0 and
                            tcp.buffer[1]==MESSAGE_MAGIC_1 );

            msg = (tcp.buffer[2]<<8) + (tcp.buffer[3]<<0);
            _dbg(3, "server | MESSAGE | %d/%X", ok, msg);

            $tcp.buffer = $tcp.buffer - MESSAGE_BYTES;

            if ok then
                if msg=={MESSAGE10} then
                    _dbg(3, "server | MESSAGE 10");
                    do (tcp)
                        var int out;
                        out = do/out
                            #include "server/message_10.ceu"
                            // output: { ARGS={chain={...}} }
                        end;

                        if out == {MESSAGE10_OK} then
                            // broadcast new received head
                            await Client_10(&outer.shared);
                        else/if out == {MESSAGE10_HAVE} then
                            var bool me_greater = [[ ARGS.me_greater ]];
                            var u16  port       = [[ (ARGS.me_greater and ARGS.port) or 0 ]];
                            if me_greater and port!=0 then
                                // send old head to out-of-date peer
                                [[ ARGS = { chain=THIS.chain } ]]
#if 0
                                // TODO: should send only to peer, but don't know his server port
                                await Client_10(&outer.shared);
#else
                                CHAIN_LOCK(l, outer.shared, "lock_send");
                                {
                                    struct sockaddr_in name;
                                    int namelen = sizeof(name);
                                    ceu_assert(uv_tcp_getpeername((uv_tcp_t*)(@&&tcp.handle), (struct sockaddr*) &name, &namelen) == 0, "bug found: uv_tcp_getpeername");
                                    char addr[16];
                                    uv_inet_ntop(AF_INET, &name.sin_addr, addr, sizeof(addr));
                                    //int port = ntohs(name.sin_port);
                                }
                                var[16] byte addr = []..({addr} as _char&&);
                                $addr = $addr - 1;
                                //var int port = {port};
                                [[
                                    ARGS = {
                                        chain = THIS.chain,
                                        peer  = {
                                            address = @addr,
                                            port    = @port,
                                        },
                                    }
                                ]]
                                await Peer_10();
#endif
                            end
                        end

                        outer.ret = out;
                    end
                else/if msg=={MESSAGE20} then
                    _dbg(3, "server | MESSAGE 20");
                    do ()
                        #include "server/message_20.ceu"
                    end
                else/if msg=={MESSAGE30} then
                    _dbg(3, "server | MESSAGE 30");
                    do ()
                        #include "server/message_30.ceu"
                    end
                else/if msg=={MESSAGE40} then
                    _dbg(3, "server | MESSAGE 40");
                    do ()
                        #include "server/message_40.ceu"
                    end
                else/if msg=={MESSAGE50} then
                    _dbg(3, "server | MESSAGE 50");
                    do ()
                        #include "server/message_50.ceu"
                    end
                else/if msg=={MESSAGE60} then
                    _dbg(3, "server | MESSAGE 60");
                    do ()
                        #include "server/message_60.ceu"
                    end
                else/if msg=={MESSAGE70} then
                    _dbg(3, "server | MESSAGE 70");
                    // nothing, main.ceu will terminate
                end
            else
                var Exception.Freechains.Unsupported e_ = val Exception.Freechains.Unsupported(_);
                throw e_;
            end
        end
        if e? then
            [[ FC.errs[#FC.errs+1] = @(e! as int) ]];
            emit shared.err_server(msg, e! as int);
        else
            if ret != {MESSAGE10_OK} then
//[[ print('ERR', @ret) ]]
                [[ FC.errs[#FC.errs+1] = @ret ]];
            end
            [[ ARGS = { chain = THIS and THIS.chain } ]];
            emit shared.ok_server(msg, ret);
        end
    end
end

#endif
