#ifndef _SERVER_CEU
#define _SERVER_CEU

code/await UV_TCP_Server_Handler (var& UV_Stream tcp, var& UV_TCP_Server_Data shared) -> int
do
    spawn do
        var _uv_stream_t&& s;
        var int err;
        (s,err) = await UV_STREAM_ERROR until (s==&&tcp.handle);
        //_dbg(2, "server | disconnected from %s:%d", (_char&&)&&ip, port);
        _ceu_dbg_assert(err != _ERR_NONE);
        _dbg(0, "server | %s\n", _uv_strerror(err));
        escape err;
    end

    var int err = _ERR_NONE;

    // => MESSAGE
    var ssize n = await UV_Stream_Read_N(&tcp, MESSAGE_BYTES);
    _ceu_dbg_assert(n>=0 and $tcp.buffer>=MESSAGE_BYTES);

    //_printf("[server] => MESSAGE = [%d %d %d %d]\n",
                //bytes[0], bytes[1], bytes[2], bytes[3]);

    var bool ok = ( tcp.buffer[0]==MESSAGE_MAGIC_0 and
                    tcp.buffer[1]==MESSAGE_MAGIC_1 );

    var int msg = (tcp.buffer[2]<<8) + (tcp.buffer[3]<<0);

    $tcp.buffer = $tcp.buffer - MESSAGE_BYTES;

    if ok and msg==0x100 then
        err = do ()
            #include "server/message10_recv.ceu"
            // [[ ARGS = { chain=? } ]]
        end;
    else
        err = _ERR_MESSAGE;
    end

    if err != _ERR_NONE then
        [[ APP.errs[#APP.errs+1] = @err ]];
    end
    // [[ ARGS = { chain=? } ]]
    emit shared.ok(msg, err);

#ifdef FREECHAINS_NO_MALICIOUS
    _ceu_dbg_assert(err == _ERR_NONE);
#endif

    //_printf("[server] DONE: %d\n", err);
    escape err;
end

#endif
