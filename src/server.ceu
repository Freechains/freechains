#ifndef _SERVER_CEU
#define _SERVER_CEU

code/await UV_TCP_Server_Handler (var& UV_Stream tcp, var& UV_TCP_Server_Data shared) -> none
do
    _dbg(0, "server | new handler");

    var int msg = 0;
    var int ret = 0;

    var int timeout = [[ APP.server.timeout ]];     // TODO: (msg,e1?,ret) for timeout?

    var Exception.Uv? e1;

    watching (timeout)s do
        var Exception.Freechains? e2;
        catch e1,e2 do
            // => MESSAGE
            await UV_Stream_Read_N(&tcp, MESSAGE_BYTES);

            //_printf("[server] => MESSAGE = [%d %d %d %d]\n",
                        //bytes[0], bytes[1], bytes[2], bytes[3]);

            var bool ok = ( tcp.buffer[0]==MESSAGE_MAGIC_0 and
                            tcp.buffer[1]==MESSAGE_MAGIC_1 );

            msg = (tcp.buffer[2]<<8) + (tcp.buffer[3]<<0);

            $tcp.buffer = $tcp.buffer - MESSAGE_BYTES;

            if ok and msg=={MESSAGE10} then
                do ()
                    var int out;
                    out = do/out
                        #include "server/message10_recv.ceu"
                    end;
                    outer.ret = out;
                end
            else
                var Exception.Freechains.Unsupported e = val Exception.Freechains.Unsupported(_);
                throw e;
            end
        end

        if e1? then
            [[ APP.errs[#APP.errs+1] = @(e1! as int) ]];
            emit shared.ok(msg,true,e1! as int);
        else/if e2? then
            [[ APP.errs[#APP.errs+1] = @(e2! as int) ]];
            emit shared.ok(msg,true,e2! as int);
        else/if ret != {MESSAGE10_OK} then
            [[ APP.errs[#APP.errs+1] = @ret ]];
        end
    end

    emit shared.ok(msg,false,ret);
end

#endif
