#ifndef _SERVER_CEU
#define _SERVER_CEU

class MessageNN with
input:
    var byte[]&         bytes;
    var UV_Stream_Read& reader;

    function (byte[]& bytes, UV_Stream_Read& reader)=>MessageNN receive;
do
    function (byte[]& bytes, UV_Stream_Read& reader)=>MessageNN receive do
        this.bytes  = &bytes;
        this.reader = &reader;
    end

    AWAIT_UNTIL(this.reader, MESSAGE_BYTES);

    _printf("[server] MESSAGE = [%d %d %d %d]\n",
                bytes[0], bytes[1], bytes[2], bytes[3]);

    var bool ok = ( bytes[0]==MESSAGE_MAGIC_0 and
                    bytes[1]==MESSAGE_MAGIC_1 );

    if ok and bytes[2]==1 and bytes[3]==0 then
        escape _MESSAGE10;
    else
        escape _ERR_MESSAGE;
    end
end

class Message10_00_chain with
input:
    var byte[]&         bytes;
    var UV_Stream_Read& reader;

    function (byte[]& bytes, UV_Stream_Read& reader)=>Message10_00_chain receive;
do
    function (byte[]& bytes, UV_Stream_Read& reader)=>Message10_00_chain receive do
        this.bytes  = &bytes;
        this.reader = &reader;
    end

    [[
        MSG = {
            id = '1.0',
            chain = {
                key    = nil,   -- set
                zeros  = nil,   -- set
            },
        }
    ]];

    var int err = _ERR_NONE;
    var u32 off = MESSAGE_BYTES;

    // <= CHAIN_ZEROS
    // <= CHAIN_LEN
    var u8 chain_zeros = 0;
    var u8 chain_len   = 0;
    do
        AWAIT_UNTIL(reader, off+2);
        chain_zeros = bytes[off+0];
        chain_len   = bytes[off+1];
        _printf("[server] CHAIN_ZEROS = %d\n",  chain_zeros);
        _printf("[server] CHAIN_LEN   = %d\n", chain_len);

        off = off + 2;
    end
    [[ MSG.chain.zeros = @chain_zeros ]];

    // <= CHAIN_KEY
    var char[] chain_key;
    do
        AWAIT_UNTIL(reader, off+chain_len);
        $chain_key := chain_len;
        native @pure _OFF();
        native do
            ##define OFF(vec,off) ((char*)(vec+off))
        end
        _strncpy((_char&&)&&chain_key, _OFF((_byte&&)&&bytes,off), chain_len);
        _printf("[server] CHAIN_KEY    = %s\n", (_char&&)&&chain_key);

        // [check] Am I subscribed to the message chain?
        [[ CHAIN = APP.chains[@chain_key] ]];
        var bool is_sub = [[ CHAIN~=nil and CHAIN.zeros<=@chain_zeros ]];
        if not is_sub then
            err = _MESSAGE10_NOTSUB;    // OK ACK
        end

        off = off + chain_len;
    end
    [[ MSG.chain.key = @chain_key ]];

    if reader.next > off then
        _assert(0);     // TODO: global event to kill connection
        escape _ERR_EXTRA_BYTES;
    end

    escape err;
end

class Message10_recv with
input:
    var _uv_tcp_t&      tcp;
    var byte[]&         bytes;
    var UV_Stream_Read& reader;

    function (_uv_tcp_t& tcp, byte[]& bytes, UV_Stream_Read& reader)=>Message10_recv run;
do
    function (_uv_tcp_t& tcp, byte[]& bytes, UV_Stream_Read& reader)=>Message10_recv run do
        this.tcp    = &tcp;
        this.bytes  = &bytes;
        this.reader = &reader;
    end

    // CHAIN

    var int err = do Message10_00_chain.receive(&bytes,&reader);

    _printf("[server] ACK = %d\n", err);
    var byte[1] send = [err];
    do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &send);

    if err == _MESSAGE10_NOTSUB then
        escape err;
    end

    // HASHES

    _assert(err == _ERR_NONE);
    escape err;
end

class Message10_01_hashes with
input:
    var byte[]&         bytes;
    var UV_Stream_Read& reader;

    function (byte[]& bytes, UV_Stream_Read& reader)=>Message10_01_hashes receive;
do
    function (byte[]& bytes, UV_Stream_Read& reader)=>Message10_01_hashes receive do
        this.bytes  = &bytes;
        this.reader = &reader;
    end

    // receive a sequence of hashes until

    var u32 off = MESSAGE_BYTES;
    loop do
        AWAIT_UNTIL(this.reader,off);
        off = off + HASH_BYTES;
    end

    _printf("[server] MESSAGE = [%d %d %d %d]\n",
                bytes[0], bytes[1], bytes[2], bytes[3]);

    var bool ok = ( bytes[0]==MESSAGE_MAGIC_0 and
                    bytes[1]==MESSAGE_MAGIC_1 );

    if ok and bytes[2]==1 and bytes[3]==0 then
        escape _MESSAGE10;
    else
        escape _ERR_MESSAGE;
    end
end

class Message10_receive_ with
input:
    var _uv_tcp_t& tcp;
    var Message&   msg;

    function (_uv_tcp_t& tcp, Message& msg)=>Message10_receive_ build;
do
    function (_uv_tcp_t& tcp, Message& msg)=>Message10_receive_ build do
        this.tcp = &tcp;
        this.msg = &msg;
    end

    [[
        MSG = {
            id = '1.0',
            chain = {
                key    = nil,
                zeros  = nil,
            },
            block_hash = nil,
            back_hash  = nil,
            tail_hash  = nil,
        }
    ]];

    var UV_Stream_Read r = UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),
                                                &this.msg.bytes);

    var char[] chain_key;
    var bool   chain_signed = false;
    var int    zeros        = 0;
    var u32    payload_len  = 0;
    var byte[HASH_BYTES] block_hash;

    var int nxt = 0;
    var int off = 0;

    var s8 err =
do//err

    // <= MESSAGE
    // TODO: with other message, move to outside the class
    do
        // [check] Is this message '1.0'? [no ACK]

        off = nxt;
        nxt = nxt + 1+1+1+1;
        AWAIT_UNTIL(r,nxt);

        if this.msg.bytes[off+0] != MESSAGE_MAGIC_0  or
           this.msg.bytes[off+1] != MESSAGE_MAGIC_1  or
           this.msg.bytes[off+2] != 1                or
           this.msg.bytes[off+3] != 0
        then
            _assert(0);
            //escape _ERR_MESSAGE;
        end
        _printf("[server] MESSAGE = [%d %d %d %d]\n",
                this.msg.bytes[off+0],
                this.msg.bytes[off+1],
                this.msg.bytes[off+2],
                this.msg.bytes[off+3]);
    end

    // <= CHAIN_SIGNED?
    // <= CHAIN_LEN
    // <= CHAIN_KEY
    do
        off = nxt;
        nxt = nxt + 1;
        AWAIT_UNTIL(r,nxt);
        var u8 v = this.msg.bytes[off];
        chain_signed = (v>>7);
        var int chain_len = (v&0x7F);
        _printf("[server] CHAIN_SIGNED = %d\n", chain_signed);
        _printf("[server] CHAIN_LEN    = %d\n", chain_len);

        off = nxt;
        nxt = nxt + chain_len;
        AWAIT_UNTIL(r,nxt);
        $chain_key := chain_len;
        _strncpy((_char&&)&&chain_key, (_char&&)&&this.msg.bytes[off], chain_len);
        _printf("[server] CHAIN_KEY    = %s\n", (_char&&)&&chain_key);

        [[ MSG.chain.key = @chain_key ]];

        // [check] Am I subscribed to the message chain? [ok ACK]
        [[ CHAIN = APP.chains[@chain_key] ]];
        var bool is_sub = [[ CHAIN ~= nil ]];
        if not is_sub then
            escape _MESSAGE10_NOTSUB;   // ok ACK
        end
    end

    // <= PAYLOAD_LEN
    do
        off = nxt;
        nxt = nxt + sizeof(u32);
        AWAIT_UNTIL(r,nxt);
        payload_len = GET_HOST_U32(this.msg.bytes,off);
        _printf("[server] PAYLOAD_LEN = %d\n", payload_len);

        // [check] too big for untrusted client [ok ACK]
        var int limit = [[ APP.server.message10_payload_len_limit ]];
        if payload_len > limit then
            escape _MESSAGE10_PAYLOAD_LEN_LIMIT;
        end
    end

    // <= BLOCK_HASH
    do
        off = nxt;
        nxt = nxt + HASH_BYTES;
        AWAIT_UNTIL(r,nxt);
        $block_hash := HASH_BYTES;
        _ceu_vector_copy_buffer(&&block_hash, 0,
                                (_byte&&)&&this.msg.bytes[off], HASH_BYTES);
        [[
            MSG.block_hash = @block_hash
            print('[server] BLOCK_HASH = {')
            print(hex_dump(MSG.block_hash))
            print('}')
        ]];

        // [check] Do I have this message hash? [ok ACK]
        var bool have = [[ APP.blocks[@block_hash] ]];
        [[ APP.blocks[@block_hash] = true ]];
        if have then
            escape _MESSAGE10_HAVE;
        end

        // [check] Does the message has the required zeros for my interest? [ok ACK]
        zeros = _leading_zeros((_byte&&)&&block_hash, HASH_BYTES);
        var bool is_sub = [[ CHAIN.zeros <= @zeros ]];
        if not is_sub then
            escape _MESSAGE10_NOTSUB;   // ok ACK
        end
        [[ MSG.chain.zeros = @zeros ]];
    end
    _assert($block_hash == HASH_BYTES);

    escape _ERR_NONE;
end;//err

    if err != _ERR_NONE then
        // => ACK
        _printf("[server] ACK = %d\n", err);
        var byte[1] send = [err];
        this.msg.offs = []..this.msg.offs..[nxt];
        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &send);
        escape err;
    end

    // == END
    _assert(err == _ERR_NONE);
    _assert(r.next >= nxt);
    if r.next > nxt then
        escape _ERR_EXTRA_BYTES;
    end

    // => ACK
    _printf("[server] ACK = %d\n", err);
    var byte[1] send = [err];
    this.msg.offs = []..this.msg.offs..[nxt];
    do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &send);

    //////////////////////////////////////////////////////////////////////////

    // <= PoW
    var u32 pow = 0;
    do
        off = nxt;
        nxt = nxt + sizeof(u32);
        AWAIT_UNTIL(r,nxt);
        pow = GET_HOST_U32(this.msg.bytes,off);
        _printf("[server] POW = %X\n", pow);
        [[ MSG.pow = @pow ]];
    end

    // <= PoS
    // TODO: check
    do
        off = nxt;
        nxt = nxt + 1;
        AWAIT_UNTIL(r,nxt);
        var int pos = this.msg.bytes[off];
        _printf("[server] POS = %X\n", pos);
        [[ MSG.pos = @pos ]];
    end

    // <= BACK_HASH
    var byte[HASH_BYTES] back_hash;
    do
        off = nxt;
        nxt = nxt + HASH_BYTES;
        AWAIT_UNTIL(r,nxt);
        $back_hash := HASH_BYTES;
        _ceu_vector_copy_buffer(&&back_hash, 0,
                                (_byte&&)&&this.msg.bytes[off], HASH_BYTES);
        [[
            MSG.back_hash = @back_hash
            print('[server] BACK_HASH = {')
            print(hex_dump(MSG.back_hash))
            print('}')
        ]];

        // [check] BACK_HASH is young enough? [ok ACK]
        do
#if 0
            var int n = [[ APP.chains.BACK_HASH_JUMP_LIMIT ]];
            [[ HEAD = APP.chains[MSG.chain.key].heads[MSG.chain.zeros] ]];
            loop i in n do
                var bool is_eq = [[ HEAD == MSG.back_hash ]];
                if is_eq then
                    xxx
                end
               [[ HEAD = APP ]]
            end
#endif
        end
    end
    _assert($back_hash == HASH_BYTES);

    // <= TAIL_HASH
    var byte[HASH_BYTES] tail_hash;
    do
        off = nxt;
        nxt = nxt + HASH_BYTES;
        AWAIT_UNTIL(r,nxt);
        $tail_hash := HASH_BYTES;
        _ceu_vector_copy_buffer(&&tail_hash, 0,
                                (_byte&&)&&this.msg.bytes[off], HASH_BYTES);
        [[
            MSG.tail_hash = @tail_hash
            print('[server] TAIL_HASH = {')
            print(hex_dump(MSG.tail_hash))
            print('}')
        ]];
    end
    _assert($tail_hash == HASH_BYTES);

    // <= PAYLOAD
    var byte[] payload;
    do
        off = nxt;
        nxt = nxt + payload_len;
        AWAIT_UNTIL(r,nxt);

        $payload := payload_len;
        _ceu_vector_copy_buffer(&&payload, 0,
                                &&(((_byte&&)&&this.msg.bytes)[off]),
                                payload_len);
        [[
            MSG.payload = @payload
            print('[server] PAYLOAD = '..MSG.payload)
        ]];
    end

    // [check] BLOCK_HASH is correct? [no ACK]
    do
        var byte[] plain;
        $plain := sizeof(u32);
        PUT_NETWORK_U32(plain, 0, pow);
        plain = []..plain..[zeros==256]..chain_key..back_hash..payload;

        var byte[] hash;
        $hash := HASH_BYTES;
        _crypto_generichash((_byte&&)&&hash, HASH_BYTES,
                            (_byte&&)&&plain, $plain,
                            null, 0);

        var int ret = _memcmp((_byte&&)&&block_hash, (_byte&&)&&hash, HASH_BYTES);
        _printf("[server] POW = %d\n", ret==0);
        if ret != 0 then
            escape _MESSAGE10_POW_FAIL;
        end
    end

    // == END
    _assert(r.next >= nxt);
    if r.next > nxt then
        escape _ERR_EXTRA_BYTES;
    end

    this.msg.offs = []..this.msg.offs..[nxt];

    escape _ERR_NONE;
end

class Message10_link with
input:
    var Message& msg;

    function (Message& msg)=>Message10_link build;
do
    function (Message& msg)=>Message10_link build do
        this.msg = &msg;
    end

    // == CHECK
    do
        [[ HEAD = APP.chains[MSG.chain.key].heads[MSG.chain.zeros] ]];
        var bool same = [[ HEAD == MSG.block_hash ]];
    end
end

class UV_TCP_Server_Handler with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>UV_TCP_Server_Handler build;
do
    function (_uv_tcp_t& tcp)=>UV_TCP_Server_Handler build do
        this.tcp = &tcp;
    end

    var byte[] bytes;
    var UV_Stream_Read reader =
            UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

    var int ret = do MessageNN.receive(&this.bytes, &this.reader);

    if ret == _MESSAGE10 then
        ret = do Message10_recv.run(&this.tcp, &this.bytes, &this.reader);
    end

    escape ret;

#if 0
    var Message msg;
    var s8 err = do Message10_receive_.build(&this.tcp, &msg);
    _printf("[server] err = %d\n", err);
    _assert(err >= _ERR_NONE);
    if err == _ERR_MESSAGE then
        _assert($msg.offs == 0);
    else/if err != _ERR_NONE then
        _assert($msg.offs == 1);
    else
        _assert(err == _ERR_NONE);
        _assert($msg.offs == 2);
        var int err = do Message10_link.build(&msg);
        if err == _ERR_NONE then
            err = do PeersSend.run(&msg);
            _assert(err == _ERR_NONE);
        end
    end
#endif
end

#endif
