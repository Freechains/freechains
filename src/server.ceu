#ifndef _SERVER_CEU
#define _SERVER_CEU

code/await UV_TCP_Server_Handler (var& UV_Stream tcp, var& UV_TCP_Server_Data shared) -> none
do
    _dbg(3, "server | new handler");

    var int msg = 0;
    var int ret = 0;

    var Exception.Uv? e1;

    par/or do
        var int timeout = [[ CFG.server.timeout or 0 ]];
        if timeout == 0 then
            await FOREVER;
        else
            await (timeout)s;
        end
        emit shared.ok(msg,true,{MESSAGE10_TIMEOUT});
    with
        var Exception.Freechains? e2;
        catch e1,e2 do
            // => MESSAGE
            await UV_Stream_Read_N(&tcp, MESSAGE_BYTES);

            //_printf("[server] => MESSAGE = [%d %d %d %d]\n",
                        //bytes[0], bytes[1], bytes[2], bytes[3]);

            var bool ok = ( tcp.buffer[0]==MESSAGE_MAGIC_0 and
                            tcp.buffer[1]==MESSAGE_MAGIC_1 );

            msg = (tcp.buffer[2]<<8) + (tcp.buffer[3]<<0);

            $tcp.buffer = $tcp.buffer - MESSAGE_BYTES;

            if ok and msg=={MESSAGE10} then
                do (tcp)
                    var int out;
                    out = do/out
                        #include "server/message10_recv.ceu"
                        // output: { ARGS={chain={...}} }
                    end;

                    if out == {MESSAGE10_OK} then
                        // broadcast new received head
                        [[ ARGS = { chain=THIS.chain } ]]
                        await Client_10(&outer.shared);
                    else/if out == {MESSAGE10_HAVE} then
                        var bool me_greater = [[ ARGS.me_greater ]];
                        if me_greater then
                            // send old head to out-of-date peer
                            [[ ARGS = { chain=THIS.chain } ]]
#if 1
                            // TODO: should send only to peer, but don't know his server port
                            await Client_10(&outer.shared);
#else
                            CHAIN_LOCK(l, outer.shared, "lock_send");
                            {
                                struct sockaddr_in name;
                                int namelen = sizeof(name);
                                ceu_assert(uv_tcp_getpeername((uv_tcp_t*)(@&&tcp.handle), (struct sockaddr*) &name, &namelen) == 0, "bug found: uv_tcp_getpeername");
                                char addr[16];
                                uv_inet_ntop(AF_INET, &name.sin_addr, addr, sizeof(addr));
                                int port = ntohs(name.sin_port);
                            }
                            var[16] byte addr = []..({addr} as _char&&);
                            $addr = $addr - 1;
                            var int port = {port};
port = 8330;
                            [[
                                ARGS = {
                                    chain = THIS.chain,
                                    peer  = {
                                        address = @addr,
                                        port    = @port,
                                    },
                                }
                            ]]
                            await Peer_10();
#endif
                        end
                    end

                    outer.ret = out;
                end
            else
                var Exception.Freechains.Unsupported e = val Exception.Freechains.Unsupported(_);
                throw e;
            end
        end

        if e1? then
            [[ FC.errs[#FC.errs+1] = @(e1! as int) ]];
            emit shared.ok(msg,true,e1! as int);
        else/if e2? then
            [[ FC.errs[#FC.errs+1] = @(e2! as int) ]];
            emit shared.ok(msg,true,e2! as int);
        else
            if ret != {MESSAGE10_OK} then
                [[ FC.errs[#FC.errs+1] = @ret ]];
            end
            // input: { ARGS={chain={...}} }
            emit shared.ok(msg,false,ret);
        end
    end
end

#endif
