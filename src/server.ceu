#ifndef _SERVER_CEU
#define _SERVER_CEU

class Message_0_0_receive with
input:
    var _uv_tcp_t& tcp;
    var Message&   msg;

    function (_uv_tcp_t& tcp, Message& msg)=>Message_0_0_receive build;
do
    function (_uv_tcp_t& tcp, Message& msg)=>Message_0_0_receive build do
        this.tcp = &tcp;
        this.msg = &msg;
    end

    var UV_Stream_Read r = UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),
                                                &this.msg.bytes);

    var int nxt = 0;
    var int off = 0;

    // <= MESSAGE
    do
        off = nxt;
        nxt = nxt + 1+1+1+1;
        AWAIT_UNTIL(r,nxt);

        if this.msg.bytes[off+0] != MESSAGE_MAGIC_0  or
           this.msg.bytes[off+1] != MESSAGE_MAGIC_1  or
           this.msg.bytes[off+2] != MESSAGE_MAJOR    or
           this.msg.bytes[off+3] != MESSAGE_MINOR
        then
            escape _ERR_MESSAGE;
        end
        _printf("[server] MESSAGE = [%d %d %d %d]\n",
                this.msg.bytes[off+0],
                this.msg.bytes[off+1],
                this.msg.bytes[off+2],
                this.msg.bytes[off+3]);
    end

    // <= BC_SIGNED?
    // <= BC_LEN
    // <= BC_DATA
    do
        off = nxt;
        nxt = nxt + 1;
        AWAIT_UNTIL(r,nxt);
        var u8 v = this.msg.bytes[off];
        var bool bc_signed = (v>>7);
        var int  bc_len    = (v&0x7F);
        _printf("[server] BC_SIGNED = %d\n", bc_signed);
        _printf("[server] BC_LEN    = %d\n", bc_len);

        off = nxt;
        nxt = nxt + bc_len;
        AWAIT_UNTIL(r,nxt);
        _printf("[server] BC_DATA   = [");
        loop i in bc_len do
            _printf("%2d", this.msg.bytes[off+i]);
        end
        _printf(" ]\n");

        _printf("\n");
    end

    // <= PAYLOAD_HASH
    do
        off = nxt;
        nxt = nxt + HASH_BYTES;
        AWAIT_UNTIL(r,nxt);
        _printf("[server] PAYLOAD_HASH = [");
        loop i in HASH_BYTES do
            _printf("%2X", this.msg.bytes[off+i]);
        end
        _printf(" ]\n");
    end

    // == END
    _assert(r.next >= nxt);
    if r.next > nxt then
        escape _ERR_EXTRA_BYTES;
    end

    // == CHECK
    do
        this.msg.offs = []..this.msg.offs..[nxt];

        // TODO: check
        //  - ainda não tenho PAYLOAD_HASH?
        //  - quero essa BC?
        //      - quero mesmo que unsigned?
        //  - quero com bc_zeros < K?
        //  - BLK_BACK_HASH é suficientemente recente?
        var byte[1] send = [1];
        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &send);
    end

    //////////////////////////////////////////////////////////////////////////

    // <= PoW
    do
        off = nxt;
        nxt = nxt + sizeof(u32);
        AWAIT_UNTIL(r,nxt);
        var u32 pow = GET_HOST_U32(this.msg.bytes,off);
        _printf("[server] POW = %X\n", pow);
    end

    // <= PoS
    do
        off = nxt;
        nxt = nxt + 1;
        AWAIT_UNTIL(r,nxt);
        var int pos = this.msg.bytes[off];
        _printf("[server] POS = %X\n", pos);
    end

    // <= BACK_HASH
    do
        off = nxt;
        nxt = nxt + HASH_BYTES;
        AWAIT_UNTIL(r,nxt);
        _printf("[server] BACK_HASH = [");
        loop i in HASH_BYTES do
            _printf("%2X", this.msg.bytes[off+i]);
        end
        _printf(" ]\n");
    end

    // <= TAIL_HASH
    do
        off = nxt;
        nxt = nxt + HASH_BYTES;
        AWAIT_UNTIL(r,nxt);
        _printf("[server] TAIL_HASH = [");
        loop i in HASH_BYTES do
            _printf("%2X", this.msg.bytes[off+i]);
        end
        _printf(" ]\n");
    end

    // <= PAYLOAD_LEN
    // <= PAYLOAD
    do
        off = nxt;
        nxt = nxt + sizeof(u32);
        AWAIT_UNTIL(r,nxt);
        var u32 payload_len = GET_HOST_U32(this.msg.bytes,off);
        _printf("[server] PAYLOAD_LEN = %d\n", payload_len);

        off = nxt;
        nxt = nxt + payload_len;
        AWAIT_UNTIL(r,nxt);

        // TODO: trick to print the payload as string
        _assert($this.msg.bytes == nxt);
        $this.msg.bytes := $this.msg.bytes + 1;
        this.msg.bytes[nxt] = '\0';
        _printf("[server] PAYLOAD = %s", (_char&&)&&(((_byte&&)&&this.msg.bytes)[off]));
        $this.msg.bytes = $this.msg.bytes - 1;
    end

    // == END
    _assert(r.next >= nxt);
    if r.next > nxt then
        escape _ERR_EXTRA_BYTES;
    end

    // == CHECK
    do
        this.msg.offs = []..this.msg.offs..[nxt];

        // TODO: check
        //  - tudo casa?
        var byte[1] send = [1];
        do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &send);
    end

    escape _ERR_NONE;
end

class UV_TCP_Server_Handler with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>UV_TCP_Server_Handler build;
do
    function (_uv_tcp_t& tcp)=>UV_TCP_Server_Handler build do
        this.tcp = &tcp;
    end

    var Message msg;
    do
        var int err = do Message_0_0_receive.build(&this.tcp, &msg);
        _assert($msg.offs == 2);
        _assert(err == _ERR_NONE);
    end
    do
        var int err = do PeersSend.run(&msg);
        _assert(err == _ERR_NONE);
    end
end

#endif
