#ifndef _SERVER_CEU
#define _SERVER_CEU

class Message10_header_recv with
input:
    var byte[]&         bytes;
    var UV_Stream_Read& reader;

    function (byte[]& bytes, UV_Stream_Read& reader)=>Message10_header_recv run;
do
    function (byte[]& bytes, UV_Stream_Read& reader)=>Message10_header_recv run do
        this.bytes  = &bytes;
        this.reader = &reader;
    end

    var u32 off = MESSAGE_BYTES;

    // => CHAIN_LEN
    // => CHAIN_KEY
    // => CHAIN_ZEROS
    do
        // len
        do UV_Stream_ReadUntil.run(&reader, off+1);
        var u8 chain_len = bytes[off];
        off = off + 1;
        _printf("[server] => CHAIN_LEN   = %d\n", chain_len);

        // key
        var char[] chain_key;
        do UV_Stream_ReadUntil.run(&reader, off+chain_len);
        $chain_key := chain_len;
        _memcpy((_char&&)&&chain_key, (_byte&&)&&bytes[off], chain_len);
        _printf("[server] => CHAIN_KEY   = %s\n", (_char&&)&&chain_key);
        off = off + chain_len;

        // zeros
        do UV_Stream_ReadUntil.run(&reader, off+1);
        var u8 chain_zeros = bytes[off];
        _printf("[server] => CHAIN_ZEROS = %d\n",  chain_zeros);
        off = off + 1;

        [[
            chain = APP.chain_parse( {
                key   = @chain_key,
                zeros = @chain_zeros,
            } )
        ]];

        var bool is_sub = [[ chain~=nil ]];
        if not is_sub then
            escape _MESSAGE10_NOTSUB;    // OK ACK
        end

        // TODO: check CHAIN_LIMITS
    end

    escape _ERR_NONE;
end

class Message10_block_recv with
input:
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>Message10_block_recv run;
do
    function (_uv_tcp_t& tcp)=>Message10_block_recv run do
        this.tcp = &tcp;
    end

    var byte[] bytes;
    var UV_Stream_Read reader =
            UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

    var u32 off = 0;

    // => BLOCK_HASH
    // => BLOCK_TXS_N
    do
        // hash
        do UV_Stream_ReadUntil.run(&reader, off+HASH_BYTES);
        var byte[HASH_BYTES] hash;
        _ceu_vector_copy_buffer(&&hash, 0,
                                (_byte&&)&&bytes[off], HASH_BYTES,
                                1);
        off = off + HASH_BYTES;

        // txs_n
        do UV_Stream_ReadUntil.run(&reader, off+sizeof(u32));
        var u32 txs_n = GET_HOST_U32(bytes, off);
        off = off + sizeof(u32);

        [[
            BLOCK.hash = @hash;
            print('[server] => BLOCK_HASH', string.len(BLOCK.hash))
            print(hex_dump(BLOCK.hash))
            print('[server] => BLOCK_TXS_N', @txs_n)
            BLOCK.txs_n = @txs_n
        ]];
    end

    var bool have = [[ APP.blocks[BLOCK.hash] ~= nil ]];
    if have then
        escape _MESSAGE10_HAVE;    // OK ACK
    else
        escape _ERR_NONE;
    end
end

class Message10_tx_recv with
input:
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>Message10_tx_recv run;
do
    function (_uv_tcp_t& tcp)=>Message10_tx_recv run do
        this.tcp = &tcp;
    end

    var byte[] bytes;
    var UV_Stream_Read reader =
            UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

    var u32 off = 0;

    // => TX_PAYLOAD_BYTES
    // => TX_HASH
    do
        // hash
        do UV_Stream_ReadUntil.run(&reader, off+HASH_BYTES);
        var byte[HASH_BYTES] hash;
        _ceu_vector_copy_buffer(&&hash, 0,
                                (_byte&&)&&bytes[off], HASH_BYTES,
                                1);
        off = off + HASH_BYTES;

        // payload_bytes
        do UV_Stream_ReadUntil.run(&reader, off+sizeof(u32));
        var u32 payload_bytes = GET_HOST_U32(bytes, off);
        off = off + sizeof(u32);
        [[ payload_bytes = @payload_bytes ]];

        // TODO: check payload_bytes vs chain.limits

        [[
            tx_hash = @hash
            print('[server] => TX_HASH', payload_bytes)
            print(hex_dump(tx_hash))
            BLOCK.txs[#BLOCK.txs+1] = tx_hash
        ]];
        var bool have = [[ APP.txs[tx_hash] ~= nil ]];

        // <= ACK-tx
        do
            var byte[1] send;
            if have then
                send = [ _MESSAGE10_HAVE ];
            else
                send = [ _ERR_NONE  ];
            end
            _printf("[server] <= ACK-tx = %d\n", send[0]);
            do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &send);
        end

        // HAVE_YES: next TX
        if have then
            escape _ERR_NONE;
        end
    end
    // HAVE_NO: complete TX

    [[
        TX = {
            hash  = tx_hash,
            bytes = payload_bytes,
        }
    ]];

    // => TX_COMPLETE
    do
        // => TIMESTAMP
        var u32 timestamp = 0;
        do
            do UV_Stream_ReadUntil.run(&this.reader, off + sizeof(u32));
            timestamp = GET_HOST_U32(bytes,off);
            _printf("[server] => TIMESTAMP = %X\n", timestamp);
            [[ TX.timestamp = @timestamp ]];
            off = off + sizeof(u32);
        end

        // => TX_BACK_HASH
        // TODO: check
        var byte[HASH_BYTES] tx_back_hash;
        do
            do UV_Stream_ReadUntil.run(&this.reader, off + HASH_BYTES);
            _ceu_vector_copy_buffer(&&tx_back_hash, 0,
                                    (_byte&&)&&bytes[off], HASH_BYTES,
                                    1);
            off = off + HASH_BYTES;
            _assert($tx_back_hash == HASH_BYTES);
            [[
                TX.back_hash = @tx_back_hash
                print('[server] => TX_BACK_HASH')
                print(hex_dump(TX.back_hash))
            ]];

            // [check] BACK_HASH is young enough? [ok ACK]
            do
#if 1
                _printf("TODO: BLOCK_HASH young enough?\n");
#else
                var int n = [[ APP.server.chains.BACK_HASH_JUMP_LIMIT ]];
                [[ head = APP.server.chains[MSG.chain.key].heads[MSG.chain.zeros] ]];
                loop i in n do
                    var bool is_eq = [[ head == MSG.back_hash ]];
                    if is_eq then
                        xxx
                    end
                   [[ head = APP ]]
                end
#endif
            end
        end

        // => TX_PAYLOAD
        var byte[] tx_payload;
        do
            var u32 len = [[ TX.bytes ]];
            do UV_Stream_ReadUntil.run(&this.reader, off + len);
            _ceu_vector_copy_buffer(&&tx_payload, 0,
                                    &&(((_byte&&)&&bytes)[off]), len,
                                    1);
            [[
                TX.payload = @tx_payload
                print('[server] => PAYLOAD')
                print(hex_dump(TX.payload))
            ]];
            off = off + len;
        end

        // => POS: TODO
        do
            do UV_Stream_ReadUntil.run(&this.reader, off + 1);
            var int pos = bytes[off];
            _printf("[server] POS = %X\n", pos);
            [[ TX.pos = @pos ]];
            _printf("TODO: POS matches?\n");
            off = off + 1;
        end

        // [check] TX_HASH is correct? [no ACK]
        do
            var byte[] plain;
            PUT_NETWORK_U32(plain, 0, timestamp);
            plain = []..plain..tx_back_hash..tx_payload;

            var byte[HASH_BYTES] hash;
            _crypto_generichash((_byte&&)&&hash, HASH_BYTES,
                                (_byte&&)&&plain, $plain,
                                null, 0);

            var char[HASH_BYTES] tx_hash = [[ TX.hash ]];
            var int ret = _memcmp((_char&&)&&tx_hash, (_byte&&)&&hash, HASH_BYTES);
            _printf("[server] POW? %d\n", ret==0);
            if ret != 0 then
                escape _ERR_REMOTE_BUG_OR_MALICIOUS;
            end
        end
    end

    escape _ERR_NONE;
end

class Message10_recv with
input:
    var _uv_tcp_t&      tcp;
    var byte[]&         bytes;
    var UV_Stream_Read& reader;

    function (_uv_tcp_t& tcp, byte[]& bytes, UV_Stream_Read& reader)=>Message10_recv run;
do
    function (_uv_tcp_t& tcp, byte[]& bytes, UV_Stream_Read& reader)=>Message10_recv run do
        this.tcp    = &tcp;
        this.bytes  = &bytes;
        this.reader = &reader;
    end

    ///////////////////////////////////////////////////////////////////////////////
    // HEADER
    ///////////////////////////////////////////////////////////////////////////////

    // <= ACK-header
    // bytes/reader received from message partially parsed
    do
        var int err = do Message10_header_recv.run(&bytes,&reader);
        do
            _printf("[server] <= ACK-header = %d\n", err);
            var byte[1] send = [err];
            do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &send);
        end
        if err == _MESSAGE10_NOTSUB then
            escape err;     // terminate if not subcribed
        end
    end

    ///////////////////////////////////////////////////////////////////////////////
    // BLOCKS
    ///////////////////////////////////////////////////////////////////////////////

    [[
        BLOCK_HEAD = nil
        BLOCK_BASE = nil
    ]];

    loop do
        [[
            BLOCK = {
                id        = '1.0',
                chain     = nil,
                txs       = { },
                hash      = nil,
                up_hash   = nil,
                tail_hash = nil,
            }
        ]];

        // <= ACK-block
        do
            var int err = do Message10_block_recv.run(&tcp);
            [[
                BLOCK_HEAD = BLOCK_HEAD or BLOCK

                if BLOCK_BASE then
                    BLOCK_BASE.tail_hash = BLOCK.hash
                    BLOCK.up_hash        = BLOCK_BASE.hash
                end
                BLOCK_BASE = BLOCK
            ]];
            do
                _printf("[server] <= ACK-block = %d\n", err);
                var byte[1] send = [err];
                do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &send);
            end
            if err == _MESSAGE10_HAVE then
                break;     // found common block
            end
        end

        ///////////////////////////////////////////////////////////////////////////
        // TXS
        ///////////////////////////////////////////////////////////////////////////

        do
            var int txs_n = [[ BLOCK.txs_n ]];
            _printf("[server] => %d txs\n", txs_n);
            loop i in txs_n do
                var int err = do Message10_tx_recv.run(&tcp);
                if err != _ERR_NONE then
                    escape err;
                end
            end
        end
    end

#if 0
    ///////////////////////////////////////////////////////////////////////////////
    // HEAD vs BLOCK
    ///////////////////////////////////////////////////////////////////////////////

        [[ APP.txs[TX.hash] = TX ]];

    ///////////////////////////////////////////////////////////////////////////////
    // HASHES
    ///////////////////////////////////////////////////////////////////////////////

    // receive oldest hash that I don't have
    do
        // new bytes/reader inside
        var int err = do Message10_01_oldest_hash.receive(&tcp);
        _printf("[server] ACK-oldest = %d\n", err);
        if err != _MESSAGE10_HAVE_NO then
            _assert(err == _MESSAGE10_HAVE_YES or
                    err == _MESSAGE10_PAYLOAD_LEN_LIMIT);
            escape err;
        end
        _assert(err == _MESSAGE10_HAVE_NO);
    end

    // receive oldest=>newest blocks I don't have
    do
        // TODO: buffer for *all* payloads,etc
        var byte[] bytes;
        var u32 off = 0;
        var UV_Stream_Read reader =
                UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);
        loop i do
            _printf("[server] Receiving %d...\n", i);
            var int err = do Message10_block.receive(&reader, &bytes, &off);
            _printf("[server] Received %d!\n", i);
            _assert(err == _ERR_NONE);
            var bool up = [[ MSG.up_hash~=nil ]];
            if up then
                [[ MSG = assert(APP.blocks[MSG.up_hash]) ]];
            else
                break;
            end
        end
    end

    ///////////////////////////////////////////////////////////////////////////////
    // CHECK/SET NEW HEAD
    ///////////////////////////////////////////////////////////////////////////////

    [[
        -- COMPARE THE TWO CHAINS
        --  - remote: possible fork from remote host
        --  - common: local chain starting from block in common with remote

        local remote = APP.blocks[FORK_HASH]
        local common = APP.blocks[remote.tail_hash]

        remote = APP.chain_base_head_len(remote)
        common = APP.chain_base_head_len(common)
        assert(remote.len > 0)
        print('[server] COM='..common.len..' vs NEW='..remote.len)

        local SRC, DST
        if remote.len >= common.len then
            -- ">=" because remote also has common_hash
            DST, SRC = remote, common
        else
            DST, SRC = common, remote
        end

        -- CONCATENATE THE TWO CHAINS (DST .. SRC)

        -- DST: ...->1->4->5->K->6
        -- SRC: ...->1->2->K->3
        -- set: ...->1->4->5->K->6->2->3
        --  // TODO: has to check if 2,3 back blocks are still valid!

        local put = DST.head
        do
            local src = SRC.base
            if SRC == common then
                src.up_hash = DST.base.block_hash -- redirect new chain
                src = APP.blocks[src.up_hash]     -- skip common block
            end
            while src ~= nil do
                local to_ins_src = true
                local dst = DST.base
                while dst~=nil and dst.tail_hash~=DST.head.block_hash do
                    if dst.block_hash == src.block_hash then
                        to_ins_src = false
                        break
                    end
                    dst = APP.blocks[dst.up_hash]
                end
                if to_ins_src then
                    put.up_hash   = src.block_hash
                    src.tail_hash = put.block_hash
                    put = APP.blocks[src.block_hash]
                end
                src = APP.blocks[src.up_hash]
            end
        end

        if DST==common and DST.head==put then
            -- no changes
            MSG = nil   -- nothing to retransmit
        else
            -- new chain head
            MSG = APP.blocks[put.block_hash]
            APP.server.chains[MSG.chain.key].heads[MSG.chain.zeros] = put.block_hash
        end
    ]];

    ///////////////////////////////////////////////////////////////////////////////
    // RETRANSMIT NEW HEAD
    ///////////////////////////////////////////////////////////////////////////////

    do
        var bool has = [[ MSG~=nil ]];
        if has then
            var int err = do Client;
            escape err;
        end
    end
#endif

    escape _ERR_NONE;
end

class UV_TCP_Server_Handler with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>UV_TCP_Server_Handler build;
do
    function (_uv_tcp_t& tcp)=>UV_TCP_Server_Handler build do
        this.tcp = &tcp;
    end

    var int err = _ERR_NONE;

    var byte[] bytes;
    var UV_Stream_Read reader =
            UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

    // => MESSAGE
    do UV_Stream_ReadUntil.run(&this.reader, MESSAGE_BYTES);

    _printf("[server] => MESSAGE = [%d %d %d %d]\n",
                bytes[0], bytes[1], bytes[2], bytes[3]);

    var bool ok = ( bytes[0]==MESSAGE_MAGIC_0 and
                    bytes[1]==MESSAGE_MAGIC_1 );

    if ok and bytes[2]==1 and bytes[3]==0 then
        err = do Message10_recv.run(&this.tcp, &this.bytes, &this.reader);
    else
        err = _ERR_MESSAGE;
    end

    _printf("[server] DONE: %d\n", err);
    escape err;
end

#endif
