#ifndef _SERVER_CEU
#define _SERVER_CEU

class CONTENTS_PUT_recv with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>CONTENTS_PUT_recv build;
do
    function (_uv_tcp_t& tcp)=>CONTENTS_PUT_recv build do
        this.tcp = &tcp;
    end

    var byte[CONTENTS_PUT_BYTES] bytes;
    var UV_Stream_Read r = UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&bytes);

    var int nxt = 0;
    var int off = 0;

    // <= VERSION
_printf("1\n");
    do
        off = nxt;
        nxt = nxt + 1+1+1;
        AWAIT_UNTIL(r,nxt);
_printf("2\n");

        if bytes[off+0] != VERSION_MAJOR  or
           bytes[off+1] != VERSION_MINOR  or
           bytes[off+2] != VERSION_PATCH
        then
            escape _ERR_VERSION;
        end
        _printf("VERSION = [%d %d %d]\n", bytes[off+0], bytes[off+1], bytes[off+2]);
    end

    // <= BC_LEN
    // <= BC_DATA
    do
        off = nxt;
        nxt = nxt + 1;
        AWAIT_UNTIL(r,nxt);
        var int bc_len = bytes[off];
        _printf("BC_LEN = %d\n", bc_len);

        off = nxt;
        nxt = nxt + bc_len;
        AWAIT_UNTIL(r,nxt);
        _printf("BC_DATA = [");
        loop i in bc_len do
            _printf("%2d", bytes[off+i]);
        end
        _printf(" ]\n");
    end

    // <= ZEROS_N
    do
        off = nxt;
        nxt = nxt + 1;
        AWAIT_UNTIL(r,nxt);
        var int zeros_n = bytes[off];
        _printf("ZEROS_N = %d\n", zeros_n);
    end

    // <= BLK_BACK_HASH
    do
        off = nxt;
        nxt = nxt + HASH_BYTES;
        AWAIT_UNTIL(r,nxt);
        _printf("BLK_BACK_HASH = [");
        loop i in HASH_BYTES do
            _printf("%2X", bytes[off+i]);
        end
        _printf(" ]\n");
    end

    // <= CONTENTS_DATA_HASH
    do
        off = nxt;
        nxt = nxt + HASH_BYTES;
        AWAIT_UNTIL(r,nxt);
        _printf("CONTENTS_DATA_HASH = [");
        loop i in HASH_BYTES do
            _printf("%2X", bytes[off+i]);
        end
        _printf(" ]\n");
    end

    // == END
    _assert(r.next >= nxt);
    if r.next > nxt then
        escape _ERR_EXTRA_BYTES;
    end

    // TODO: check
    //  - ainda não tenho CONTENTS_DATA_HASH?
    //  - quero essa BC?
    //      - quero mesmo que unsigned?
    //  - quero com zeros_n < K?
    //  - BLK_BACK_HASH é suficientemente recente?
    bytes = [1];
    do UV_Stream_Write.build(&_UV_STREAM_ALIAS(this.tcp), &bytes);

    escape 1;
end

class CONTENTS_DATA_recv with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>CONTENTS_DATA_recv build;
do
    function (_uv_tcp_t& tcp)=>CONTENTS_DATA_recv build do
        this.tcp = &tcp;
    end

    var byte[] bytes;
    var UV_Stream_Read r = UV_Stream_Read.build(&_UV_STREAM_ALIAS(this.tcp),&bytes);

    var int nxt = 0;
    var int off = nxt;

    // <= NOUNCE
    do
        nxt = nxt + 1;
        AWAIT_UNTIL(r,nxt);
        var int nounce = bytes[off];
        _printf("NOUNCE = %d\n", nounce);
    end

    // <= CONTENTS_LEN
    // <= CONTENTS_DATA
    do
        off = nxt;
        nxt = nxt + sizeof(u32);
        AWAIT_UNTIL(r,nxt);
        var u32 contents_len = GET_HOST_U32(bytes,off);
        _printf("CONTENTS_LEN = %d\n", contents_len);

        off = nxt;
        nxt = nxt + contents_len;
        AWAIT_UNTIL(r,nxt);

        // TODO: trick to print the contents
        if $bytes <= nxt then
            $bytes := $bytes + 1;
        end
        var byte old = bytes[nxt];
        bytes[nxt] = '\0';
        _printf("CONTENTS_DATA = %s", (_char&&)&&(((_byte&&)&&bytes)[off]));
        bytes[nxt] = old;
    end

    // == END
    _assert(r.next >= nxt);
    if r.next > nxt then
        escape _ERR_EXTRA_BYTES;
    end

    escape _ERR_NONE;
end

class UV_TCP_Server_Handler with
    var _uv_tcp_t& tcp;
    function (_uv_tcp_t& tcp)=>UV_TCP_Server_Handler build;
do
    function (_uv_tcp_t& tcp)=>UV_TCP_Server_Handler build do
        this.tcp = &tcp;
    end

    var int ok = do CONTENTS_PUT_recv.build(&this.tcp);
    if ok then
        var int err = do CONTENTS_DATA_recv.build(&this.tcp);
        _assert(err == _ERR_NONE);
    end

    escape _ERR_NONE;
end

#endif
